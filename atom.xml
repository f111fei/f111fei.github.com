<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[xzper]]></title>
  <subtitle><![CDATA[前行在被夕阳染红的街道]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xzper.com/"/>
  <updated>2017-03-23T10:49:57.700Z</updated>
  <id>http://xzper.com/</id>
  
  <author>
    <name><![CDATA[xzper]]></name>
    <email><![CDATA[f111fei1@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[EgretWing3入门指南]]></title>
    <link href="http://xzper.com/2016/06/14/wing3/"/>
    <id>http://xzper.com/2016/06/14/wing3/</id>
    <published>2016-06-14T12:03:12.000Z</published>
    <updated>2016-06-15T02:00:35.157Z</updated>
    <content type="html"><![CDATA[<p>EgretWing3是Egret团队基于VSCode开发的最新编辑器，相比于EgretWing2.5最显著的优势就是快。</p>
<p>然而对于习惯使用EgretWing2.5的用户，初次使用EgretWing3可能会觉得难以上手。EgretWing2.5主要是参考eclipse，FlashBuilder等传统IDE设计的，对于习惯使用eclipse系列工具的开发者EgretWing2.5的上手是非常容易的，而EgretWing3的操作方式对于习惯于传统IDE的用户来说，并不是那么友好。本文主要介绍EgretWing3的一些基本用法。</p>
<a id="more"></a>
<h1 id="基本概念">基本概念</h1>
<h2 id="窗口布局">窗口布局</h2>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/1.png" alt=""></p>
<p>如上图，EgretWing窗口主要有下面几个部分组成：</p>
<ul>
<li><strong>菜单栏(Menu Bar)</strong> 可以通过菜单栏执行一些常用命令</li>
<li><strong>左侧栏(Side Bar)</strong> 位于编辑器左侧，由多个子视图组成(文件，搜索，Git，调试)</li>
<li><strong>编辑器(Editor)</strong> 编辑文件的主要区域</li>
<li><strong>面板(Panel)</strong> 位于编辑器下方，也由多个子视图组成(输出，调试，错误，终端)</li>
<li><strong>右侧栏(Utility Bar)</strong> 位于编辑器右侧，由多个子视图组成，子视图目前可以通过插件API扩展</li>
<li><strong>状态栏(Status Bar)</strong> 最下方，显示当前打开项目和文件的一些信息</li>
</ul>
<p><strong>菜单栏</strong>可以通过<strong>切换菜单栏</strong>命令来设置是否显示</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/3.png" alt=""></p>
<p><strong>左侧栏，右侧栏，面板</strong>可以通过视图菜单中的相关命令来切换是否显示</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/28.png" alt=""></p>
<p>还可以通过鼠标操作来打开和关闭，如下图</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/2.gif" alt=""></p>
<h2 id="工作空间">工作空间</h2>
<p>EgretWing可以通过打开一个文件或者文件夹进行代码编写。EgretWing也可以同时打开多个窗口，每个窗口对应一个文件或者文件。当一个窗口打开的是一个文件夹时，这个文件夹被称为当前工作空间。</p>
<p>可以使用菜单栏中的 <strong>文件—-新建窗口</strong> 命令(<code>Ctrl+Shift+N</code>)打开一个新窗口。<br>新建项目(<code>Alt+Shift+P</code>)在项目创建成功后也会自动打开新窗口。</p>
<p>一般来说，每个工作空间就对应一个项目。在工作空间目录下有一个特殊的文件夹 <code>.wing</code>。这个文件夹存放当前工作空间的一些设置和配置文件。常见的几个配置文件如 <code>task.json</code> , <code>launch.json</code> , <code>settings.json</code>，这几个文件的作用下面会具体说明。</p>
<blockquote>
<p>EgretWing和WebStorm都是基于文件夹来表示工作空间，这个工作空间就是文件系统中的一个目录。而Eclipse的工作空间则是由多个项目构成，每个项目对应一个目录，而工作空间是这些目录的集合。几乎所有的IDE都会有一个特殊的文件夹存放工作空间的配置。如 WebStorm的 <code>.idea</code> 文件夹， Eclipse的 <code>.metadata</code> 文件夹。EgretWing中的 <code>.wing</code> 文件夹也是类似，只不过里面的文件一般都是json文件，有时候我们也会手动修改这些配置设置工作空间的行为。</p>
</blockquote>
<h1 id="自定义">自定义</h1>
<h2 id="用户设置和工作空间设置">用户设置和工作空间设置</h2>
<p>EgretWing提供了包括 <strong>编辑器设置，文件设置，窗口设置</strong> 等近200个设置项来满足各种用户习惯。常用的设置如：</p>
<pre><code><span class="comment">// 字体.</span>
<span class="string">"editor.fontFamily"</span>: <span class="string">""</span>,
<span class="comment">// 字体大小.</span>
<span class="string">"editor.fontSize"</span>: <span class="number">0</span>,
<span class="comment">// 显示行号</span>
<span class="string">"editor.lineNumbers"</span>: <span class="literal">true</span>,
<span class="comment">// 一个制表符等于的空格数</span>
<span class="string">"editor.tabSize"</span>: <span class="number">4</span>,
<span class="comment">// 按 "Tab" 时插入空格</span>
<span class="string">"editor.insertSpaces"</span>: <span class="literal">true</span>,

<span class="comment">// 读取或写入文件的默认编码格式.</span>
<span class="string">"files.encoding"</span>: <span class="string">"utf8"</span>,
<span class="comment">// 默认换行符</span>
<span class="string">"files.eol"</span>: <span class="string">"\r\n"</span>
</code></pre><p>可以通过菜单栏，<strong>文件—-首选项</strong>菜单打开<strong>用户设置</strong>或者<strong>工作空间设置</strong></p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/4.png" alt=""></p>
<p>设置分为<strong>用户设置</strong>和<strong>工作空间设置</strong>。用户设置是全局的，在任何地方都可以生效，用户设置会覆盖默认设置。用户设置保存在用户缓存目录的 settings.json 中。<br>工作空间设置是针对某个文件夹的，只对当前工作空间有效，工作空间设置会覆盖用户设置。工作空间设置保存在当前工作空间下的 .wing/settings.json 中。<br>所以最终的优先级是 <strong>工作空间设置  &gt; 用户设置 &gt; 默认设置</strong>。</p>
<p>通过修改 <code>settings.json</code> 文件改变当前的设置。例如我习惯的用户配置就是这样写的</p>
<pre><code>{
    "<span class="attribute">editor.insertSpaces</span>": <span class="value"><span class="literal">false</span></span>,
    "<span class="attribute">files.eol</span>": <span class="value"><span class="string">"\n"</span></span>,
    "<span class="attribute">window.openFilesInNewWindow</span>": <span class="value"><span class="literal">false</span></span>,
    "<span class="attribute">tslint.enable</span>": <span class="value"><span class="literal">false</span>
</span>}
</code></pre><p>每个字段表示的功能可以通过默认配置中的字段说明找到具体的含义。</p>
<h2 id="快捷键设置">快捷键设置</h2>
<p>EgretWing提供了近300个快捷键设置项自定义命令的快捷键。可以通过菜单栏，<code>文件---首选项</code> 菜单打开 <strong>快捷键</strong> 选项。快捷键设置界面将打开两个编辑器，默认快捷键设置在左侧，编辑右侧编辑器中的 <code>keybindings.json</code> 文件自定义快捷键。一般在左侧找到要修改的快捷键命令，然后复制左侧的项到右侧，修改key字段就行。例如：</p>
<pre><code>[
    {
        "<span class="attribute">key</span>": <span class="value"><span class="string">"ctrl+d"</span></span>,
        "<span class="attribute">command</span>": <span class="value"><span class="string">"editor.action.deleteLines"</span></span>,
        "<span class="attribute">when</span>": <span class="value"><span class="string">"editorFocus"</span>
    </span>},
    {
        "<span class="attribute">key</span>": <span class="value"><span class="string">"ctrl+i"</span></span>,
        "<span class="attribute">command</span>": <span class="value"><span class="string">"editor.action.format"</span></span>,
        "<span class="attribute">when</span>": <span class="value"><span class="string">"editorTextFocus"</span>
    </span>},
    {
        "<span class="attribute">key</span>": <span class="value"><span class="string">"f7"</span></span>,
        "<span class="attribute">command</span>": <span class="value"><span class="string">"workbench.action.debug.stepOut"</span></span>,
        "<span class="attribute">when</span>": <span class="value"><span class="string">"inDebugMode"</span>
    </span>},
    {
        "<span class="attribute">key</span>": <span class="value"><span class="string">"f6"</span></span>,
        "<span class="attribute">command</span>": <span class="value"><span class="string">"workbench.action.debug.stepOver"</span></span>,
        "<span class="attribute">when</span>": <span class="value"><span class="string">"inDebugMode"</span>
    </span>},
    {
        "<span class="attribute">key</span>": <span class="value"><span class="string">"f5"</span></span>,
        "<span class="attribute">command</span>": <span class="value"><span class="string">"workbench.action.debug.stepInto"</span></span>,
        "<span class="attribute">when</span>": <span class="value"><span class="string">"inDebugMode"</span>
    </span>}
]
</code></pre><p>在EgretWing3中有很多命令的快捷键与EgretWing2.5的默认快捷键不一样，可以使用 插件菜单中的 <strong>IDE迁移向导 —- 导入其他IDE设置</strong>，选择EgretWing2.5自动修改 <code>keybindings.json</code> 文件导入EgretWing2.5的快捷键。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/9.png" alt=""></p>
<h2 id="任务配置">任务配置</h2>
<p>设置当前工作空间下 <code>.wing/tasks.json</code> 可以自定义任务。常见的任务如 构建，清理，发布。这些任务通过一般是执行命令行程序来实现的。<br>如果当前工作空间下的 <code>.wing</code> 文件夹没有 <code>tasks.json</code> 。可以通过命令面板中的 <strong>Tasks: Configure Task Runner</strong> 命令选择一个任务模板。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/5.png" alt=""></p>
<p>对于一般的Egret项目，在创建项目的时候已经自动生成了与Egret命令行匹配的任务： <strong>构建(Ctrl+Shift+B)，清理，发布</strong>。<code>tasks.json</code> 如下：</p>
<pre><code>{
    "<span class="attribute">version</span>": <span class="value"><span class="string">"0.1.0"</span></span>,
    "<span class="attribute">command</span>": <span class="value"><span class="string">"egret"</span></span>,
    "<span class="attribute">isShellCommand</span>": <span class="value"><span class="literal">true</span></span>,
    "<span class="attribute">tasks</span>": <span class="value">[
        {
            "<span class="attribute">taskName</span>": <span class="value"><span class="string">"build"</span></span>,
            "<span class="attribute">showOutput</span>": <span class="value"><span class="string">"always"</span></span>,
            "<span class="attribute">args</span>": <span class="value">[
                <span class="string">"build"</span>,
                <span class="string">"-sourcemap"</span>
            ]</span>,
            "<span class="attribute">problemMatcher</span>": <span class="value"><span class="string">"$tsc"</span>
        </span>},
        {
            "<span class="attribute">taskName</span>": <span class="value"><span class="string">"clean"</span></span>,
            "<span class="attribute">showOutput</span>": <span class="value"><span class="string">"always"</span></span>,
            "<span class="attribute">args</span>": <span class="value">[
                <span class="string">"build"</span>,
                <span class="string">"-e"</span>
            ]</span>,
            "<span class="attribute">problemMatcher</span>": <span class="value"><span class="string">"$tsc"</span>
        </span>},
        {
            "<span class="attribute">taskName</span>": <span class="value"><span class="string">"publish"</span></span>,
            "<span class="attribute">showOutput</span>": <span class="value"><span class="string">"always"</span></span>,
            "<span class="attribute">args</span>": <span class="value">[
                <span class="string">"publish"</span>
            ]</span>,
            "<span class="attribute">problemMatcher</span>": <span class="value"><span class="string">"$tsc"</span>
        </span>}
    ]
</span>}
</code></pre><h2 id="启动配置">启动配置</h2>
<p>当需要运行或者调试当前项目时，需要设置启动配置。与任务配置类似，启动配置保存在当前工作空间下的 <code>.wing/launch.json</code> 中。<br>默认可以使用快捷键F5，<strong>启动或者调试</strong>当前项目。也可以切换左侧栏到调试选项卡在下拉框中选择一个启动配置，然后点击运行。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/7.png" alt=""></p>
<p>如果当前工作空间下不存在 <code>launch.json</code> 使用F5会出现选择启动配置模板的选择框。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/6.png" alt=""></p>
<p>对于一般的Egret项目，在创建项目的时候已经自动生成了与Egret项目匹配的启动配置： 包含使用内置播放器调试，使用Chrome调试，附加到Chrome进程等配置，轻松调试和启动Egret项目 。<code>tasks.json</code> 如下：</p>
<pre><code>{
    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,
    <span class="string">"configurations"</span>: [
        {
            <span class="string">"name"</span>: <span class="string">"Wing 内置播放器调试"</span>,
            <span class="string">"type"</span>: <span class="string">"chrome"</span>,
            <span class="string">"request"</span>: <span class="string">"launch"</span>,
            <span class="string">"file"</span>: <span class="string">"index.html"</span>,
            //<span class="string">"url"</span>: <span class="string">"http://mysite.com/index.html"</span>, //使用外部服务器时,请注释掉 file, 改用 url, 并将 useBuildInServer 设置为 <span class="literal">false</span>
            <span class="string">"runtimeExecutable"</span>: <span class="string">"<span class="variable">${execPath}</span>"</span>,
            <span class="string">"useBuildInServer"</span>: <span class="literal">true</span>,
            <span class="string">"sourceMaps"</span>: <span class="literal">true</span>,
            <span class="string">"webRoot"</span>: <span class="string">"<span class="variable">${workspaceRoot}</span>"</span>,
            <span class="string">"preLaunchTask"</span>:<span class="string">"build"</span>,
            <span class="string">"port"</span>:<span class="number">5437</span>
        },
        {
            <span class="string">"name"</span>: <span class="string">"使用本机 Chrome 调试"</span>,
            <span class="string">"type"</span>: <span class="string">"chrome"</span>,
            <span class="string">"request"</span>: <span class="string">"launch"</span>,
            <span class="string">"file"</span>: <span class="string">"index.html"</span>,
            //<span class="string">"url"</span>: <span class="string">"http://mysite.com/index.html"</span>, //使用外部服务器时,请注释掉 file, 改用 url, 并将 useBuildInServer 设置为 <span class="literal">false</span>
            <span class="string">"runtimeExecutable"</span>: <span class="string">"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe"</span>, // 改成您的 Chrome 安装路径
            <span class="string">"useBuildInServer"</span>: <span class="literal">true</span>,
            <span class="string">"sourceMaps"</span>: <span class="literal">true</span>,
            <span class="string">"webRoot"</span>: <span class="string">"<span class="variable">${workspaceRoot}</span>"</span>,
            <span class="string">"preLaunchTask"</span>:<span class="string">"build"</span>,
            <span class="string">"userDataDir"</span>:<span class="string">"<span class="variable">${tmpdir}</span>"</span>,
            <span class="string">"port"</span>:<span class="number">5437</span>
        },
        {
            <span class="string">"name"</span>: <span class="string">"附加到 Chrome 进程"</span>,
            <span class="string">"type"</span>: <span class="string">"chrome"</span>,
            <span class="string">"request"</span>: <span class="string">"attach"</span>,
            <span class="string">"port"</span>: <span class="number">9222</span>,
            <span class="string">"webRoot"</span>: <span class="string">"<span class="variable">${workspaceRoot}</span>"</span>
        }
    ]
}
</code></pre><blockquote>
<p>基本上自定义EgretWing都是去修改某一个json文件的内容。这种手动修改的方式对于一些初学者门槛有点高，目前我们正在计划让自定义配置文件可视化让更多人轻松自定义EgretWing。</p>
</blockquote>
<h1 id="常用面板">常用面板</h1>
<h2 id="命令面板">命令面板</h2>
<p>命令面板能方便的查找和执行命令，使用快捷键 <strong>F1</strong> 或者 <strong>Ctrl+Shift+P</strong> 呼出面板。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/8.png" alt=""></p>
<p>面板每一项都是一个命令，如果该命令有快捷键在右侧会显示对应的快捷键。</p>
<h2 id="文件操作">文件操作</h2>
<p>左侧栏的文件选项卡中，包含了当前工作空间的文件列表树。使用右键菜单能显示可以执行的命令。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/10.png" alt=""></p>
<h2 id="全局搜索">全局搜索</h2>
<p>右侧栏的搜索选项卡中能对当前工作空间中的所有文件和内容进行搜索，并且支持正则表达式以及模式匹配和过滤等高级设置选项。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/11.png" alt=""></p>
<h2 id="GIT">GIT</h2>
<p>EgretWing内置Git管理工具， 在右侧栏的GIT选项卡中能直接提交，拉取，推送代码到Git仓库。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/12.png" alt=""></p>
<p>在状态栏左侧也能显示远程仓库与本地仓库的同步状态。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/13.png" alt=""></p>
<p>单击更改的文件列表，在编辑器能打开比较编辑器查看改变的具体细节。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/17.png" alt=""></p>
<h2 id="调试和调试控制台">调试和调试控制台</h2>
<p>如果配置了 <code>launch.json</code> 可以通过快捷键F5 或者 调试面板启动调试。在调试模式下，调试选项卡中的<strong>变量，监视，调用堆栈，断点</strong>折叠菜单都是可用的。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/14.png" alt=""></p>
<p>面板中的调试面板中显示程序运行中的输出和报错信息，在下方的输入框中也能输入表达式并动态执行得到计算结果。这个面板与Chrome开发者工具中的Console面板功能类似。</p>
<h2 id="输出">输出</h2>
<p>输出面板显示一些提示消息，显示当前运行状态。输出面板有多个频道(<code>Channel</code>)区分不同输出的来源。</p>
<p>例如Tasks频道会输出项目编译过程中相关的信息，GIT频道输出Git执行过程中的信息，Project频道输出项目创建相关的信息等。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/15.png" alt=""></p>
<h2 id="终端">终端</h2>
<p>EgretWing内置了一个终端命令行执行窗口，能方便的直接在EgretWing内部使用命令行。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/16.png" alt=""></p>
<p>点击右侧的 <code>+</code> 图标能新建一个命令行窗口，右侧的列表显示当前所有打开的命令行窗口。</p>
<h1 id="代码编辑">代码编辑</h1>
<h2 id="多编辑器">多编辑器</h2>
<p>EgretWing允许最多同时打开三个编辑器，并排在编辑器显示。</p>
<p>如果已经打开了一个编辑器，有多种方式在编辑器的右侧打开一个新的编辑器：</p>
<ul>
<li>在文件选项卡的中按住<code>Ctrl</code>键(Mac下为<code>Cmd</code>键)，并点击要打开的文件</li>
<li>在当前激活的编辑器中使用快捷键 <code>Ctrl+\</code> 将把当前编辑器一分为二</li>
<li>在文件夹选项卡的右键菜单上选择 <strong>在新编辑器中打开</strong></li>
</ul>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/18.png" alt=""></p>
<h2 id="智能提示">智能提示</h2>
<p>EgretWing支持多种语言的自动补全功能，如: JavaScript, JSON, HTML, CSS, Less, Sass, C# and TypeScript。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/19.png" alt=""></p>
<h2 id="参数提示">参数提示</h2>
<p>在 JavaScript，TypeScript中，输入方法的参数时能看到当前输入参数的类型和注释说明。如果是重载方法，可以通过 <code>上箭头</code> 和 <code>下箭头</code> 快捷键选择需要参数。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/20.png" alt=""></p>
<h2 id="悬浮提示">悬浮提示</h2>
<p>当鼠标移动到文字上时，如果该字符是一个变量或者下面例子中的css选择器，将出现一个悬浮提示框。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/21.png" alt=""></p>
<h2 id="跳转到定义">跳转到定义</h2>
<p>如果语言支持,可以按下快捷键<code>F12</code>跳转到光标所在位置的变量或者方法的定义。</p>
<p>也可以按下 <code>Ctrl</code> 键鼠标移动到变量或者方法上，将显示方法定义细节。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/22.png" alt=""></p>
<blockquote>
<p>你还可以使用 <code>Ctrl+Click</code> 调整到定义，或者使用 <code>Ctrl+Alt+Click</code> 在新编辑器中打开定义。如果打开了一个新编辑器窗口，你能够使用 <code>Ctrl+Alt+Left</code> 返回到之前的编辑器。</p>
</blockquote>
<h2 id="快速大纲">快速大纲</h2>
<p>使用快捷键 <code>Ctrl+Shift+O</code> 能够打开快速大纲面板(在之前的EgretWing2.5版本中这个快捷键是<code>Ctrl+O</code>)显示当前文件中定义的所有类，方法和变量。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/23.png" alt=""></p>
<h2 id="查找引用">查找引用</h2>
<p>可以通过执行<strong>查找所有引用</strong>(快捷键<code>Shift+F12</code>)命令找到当前变量或者方法被引用的所有位置。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/24.png" alt=""></p>
<h2 id="重命名变量">重命名变量</h2>
<p>一些语言(如TypeScript)支持全局重命名变量。使用快捷键<code>F2</code>输入变量的新名称并按下<code>Enter</code>，项目中所有使用该变量的位置将被重命名。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/25.png" alt=""></p>
<h2 id="错误和警告">错误和警告</h2>
<p>当文件出现语法错误或者警告时，将提示错误，使用快捷键 <code>Ctrl+Shift+M</code> 查看所有的错误</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/26.png" alt=""></p>
<p>也可以在错误面板中查看出现的错误</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/27.png" alt=""></p>
<h2 id="多选">多选</h2>
<p>EgretWing支持多个光标，可以快速编辑相似的文本。 可以使用 <code>Alt+Click</code> 快捷键添加多个光标，每一个光标都是独立的。 也可以使用 <code>Ctrl+Alt+Down</code> 或者 <code>Ctrl+Alt+Up</code> 在下面或者上面插入光标。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/28.gif" alt=""></p>
<h2 id="跨行选择">跨行选择</h2>
<p>按住 <code>Shift+Alt</code> 移动光标可以选择多行文本。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/29.gif" alt=""></p>
<h2 id="代码折叠">代码折叠</h2>
<p>你可以使用在行号右边的折叠图标来折叠代码。</p>
<p><img src="http://xzper.qiniudn.com/2016/06/wing3/30.gif" alt=""></p>
<p>也可以使用快捷键折叠和展开代码：</p>
<ul>
<li>折叠 (<code>Ctrl+Shift+[</code>)</li>
<li>展开 (<code>Ctrl+Shift+]</code>)</li>
<li>折叠所有 (<code>Ctrl+K Ctrl+O</code>)</li>
<li>展开 (<code>Ctrl+K Ctrl+J</code>)</li>
</ul>
<h2 id="常用快捷键">常用快捷键</h2>
<p>在EgretWing3中编辑器中有很多实用功能的快捷键：</p>
<ul>
<li>切换到上一个编辑器 (<code>Ctrl+Tab</code>)</li>
<li>切换到上一个编辑位置 (<code>Alt+Left</code>)</li>
<li>格式化代码 (<code>Shift+Alt+F</code>)，EgretWing2.5下为<code>Ctrl+I</code></li>
<li>删除当前行 (<code>Ctrl+Shift+k</code>)，EgretWing2.5下为<code>Ctrl+D</code></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>EgretWing3是Egret团队基于VSCode开发的最新编辑器，相比于EgretWing2.5最显著的优势就是快。</p>
<p>然而对于习惯使用EgretWing2.5的用户，初次使用EgretWing3可能会觉得难以上手。EgretWing2.5主要是参考eclipse，FlashBuilder等传统IDE设计的，对于习惯使用eclipse系列工具的开发者EgretWing2.5的上手是非常容易的，而EgretWing3的操作方式对于习惯于传统IDE的用户来说，并不是那么友好。本文主要介绍EgretWing3的一些基本用法。</p>
]]>
    
    </summary>
    
      <category term="vscode" scheme="http://xzper.com/tags/vscode/"/>
    
      <category term="nodejs" scheme="http://xzper.com/tags/nodejs/"/>
    
      <category term="nodejs" scheme="http://xzper.com/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vscode源码剖析]]></title>
    <link href="http://xzper.com/2016/04/17/vscode%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://xzper.com/2016/04/17/vscode源码剖析/</id>
    <published>2016-04-16T16:37:03.000Z</published>
    <updated>2016-06-12T02:24:30.235Z</updated>
    <content type="html"><![CDATA[<p>vscode作为微软推出的现代编辑器已经在GitHub上<a href="https://github.com/Microsoft/vscode" target="_blank" rel="external">开源</a>了。用过vscode的人都纷纷表示速度极快，秒杀同为使用<a href="https://github.com/electron/electron" target="_blank" rel="external">Electron</a>架构的<a href="https://github.com/atom/atom" target="_blank" rel="external">Atom</a>。这次我们从源码级别来剖析为何vscode快速，高效。</p>
<a id="more"></a>
<h2 id="Electron">Electron</h2>
<p><code>Electron</code> 是基于 <code>Node.js</code> 和 <code>Chromium</code> 的跨平台桌面应用开发框架。使用 <code>JavaScipt</code>，<code>HTML</code>，<code>CSS</code> 真正将 <code>Node.js</code> 带到了前端。<code>Electron</code> 通过 <code>BrowserWindow</code> 可以创建一个本地窗口，并加载一个<code>HTML</code>文档，<code>BrowserWindow</code>中的内容就是一个浏览器窗口，不仅能创建<code>DOM</code>元素，同时能使用任意的Node模块，并且还可以通过<code>IPC</code>与主进程通讯。</p>
<h2 id="多进程">多进程</h2>
<p>每一个 <code>Electron</code> 应用都对应一个主进程(main process)， 主进程通过<code>BrowserWindow</code>创建的每个本地窗口对应一个渲染进程(renderer process)。</p>
<p><img src="http://xzper.qiniudn.com/2016/04/1.png" alt=""></p>
<h3 id="主进程">主进程</h3>
<p>vscode的主进程主要负责创建窗口和菜单，生命周期管理，自动更新等与系统相关的功能。</p>
<h3 id="渲染进程">渲染进程</h3>
<p>绝大多数代码都是运行在渲染进程中的，渲染进程负责界面的显示，响应用户操作。前面说到在浏览器中也可以使用Node模块，渲染进程还通过Node创建了一个插件子进程，负责插件的初始化。另外渲染进程还可以创建Worker执行一些复杂的计算，比如markdown的解析。</p>
<h3 id="插件进程">插件进程</h3>
<p>每一个渲染进程同时也对应一个插件进程，插件运行在单独的进程不会对渲染进程造成影响，这也是vscode比atom要快的原因。Atom中插件是直接运行在渲染进程中的，所以当插件很多的时候会卡。同时又由于vscode的插件运行在一个普通的Node进程中，所以对UI的操作能力是比较弱的，这点不及Atom。</p>
<h2 id="VSCode_Loader">VSCode Loader</h2>
<p><a href="https://github.com/Microsoft/vscode-loader" target="_blank" rel="external">VSCode Loader</a>是类似于 <a href="https://github.com/requirejs/requirejs" target="_blank" rel="external">RequireJS</a> 的一个异步加载模块(<a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="external">AMD</a>)。所有的TypeScript源码都被编译成了使用AMD规范的js文件，使用时通过这个loader加载。</p>
<p>虽然主进程(Node进程)是使用CommonJS规范的，但是在浏览器中的代码加载是异步的，所以使用AMD是没有争议的。在vscode中的一些核心代码，基本库都是用TypeScript编写的，也会被编译成AMD规范的js，这些基本代码也会被主进程用到，所以主进程里面也用到了这个loader。同理，插件进程和Worker都会使用这个loader加载代码。</p>
<p>VSCode Loader不仅实现了类似RequireJS的<a href="https://github.com/Microsoft/vscode/blob/master/src/vs/loader.js" target="_blank" rel="external">模块加载</a>功能，还附带几个插件可以加载css(<a href="https://github.com/Microsoft/vscode/blob/master/src/vs/css.js" target="_blank" rel="external">css.js</a>)和<a href="https://github.com/Microsoft/vscode/blob/master/src/vs/text.js" target="_blank" rel="external">文档</a>，以及实现<a href="https://github.com/Microsoft/vscode/blob/master/src/vs/nls.js" target="_blank" rel="external">多语言</a>。</p>
<h2 id="项目结构">项目结构</h2>
<p>vscode的主要目录结构如下:</p>
<pre><code>├── build                 <span class="comment">// gulp打包编译相关脚本</span>
├── node_modules          <span class="comment">// 依赖模块</span>
├── src                   <span class="comment">// 源代码和素材(ts,js,css,svg,html等)</span>
│    ├── typings           <span class="comment">// 常用模块定义</span>
│    ├── vs
│    │    ├── base         <span class="comment">// 核心模块，常用库和基本组件</span>
│    │    ├── editor       <span class="comment">// 编辑器模块</span>
│    │    ├── languages    <span class="comment">// 默认编辑器语言支持</span>
│    │    ├── platform     <span class="comment">// 核心功能接口定义和基本实现</span>
│    │    ├── workbench    <span class="comment">// 业务逻辑功能实现</span>
│    │    ├── loader.js    <span class="comment">// vscode loader</span>
│    │    └── vscode.d.ts  <span class="comment">// 插件API定义</span>
│    └── main.js          <span class="comment">// 主进程入口</span>
├── gulpfile.js          <span class="comment">// gulp打包编译入口</span>
├── product.json         <span class="comment">// 产品描述文件</span>
└── <span class="keyword">package</span>.json
</code></pre><h3 id="base"><a href="https://github.com/Microsoft/vscode/tree/master/src/vs/base" target="_blank" rel="external">base</a></h3>
<p>base包封装了大量API，实现常用功能。在vscode中目录结构都是都是按照browser，common，node，electron的方式划分的。</p>
<ul>
<li>browser 实现浏览器相关的功能。</li>
<li>common 实现不依赖node模块的基本功能。</li>
<li>node 实现需要node模块支持的功能，比如文件操作。</li>
<li>electron 实现需要electron api的功能，比如ipc通讯。</li>
</ul>
<h4 id="browser"><a href="https://github.com/Microsoft/vscode/tree/master/src/vs/base/browser" target="_blank" rel="external">browser</a></h4>
<p>browser中实现了一个简单的UI库，包括 <code>Button</code>，<code>CheckBox</code>，<code>List</code>，<code>Scrollbar</code>等常用组件。并且封装了一套类似JQuery的DOM操作API(参见 <a href="https://github.com/Microsoft/vscode/blob/master/src/vs/base/browser/dom.ts" target="_blank" rel="external">dom.ts</a> 和 <a href="https://github.com/Microsoft/vscode/blob/master/src/vs/base/browser/dom.ts" target="_blank" rel="external">builder.ts</a>)。</p>
<h4 id="common"><a href="https://github.com/Microsoft/vscode/tree/master/src/vs/base/common" target="_blank" rel="external">common</a></h4>
<p>common包中封装了大量实用工具类。如</p>
<ul>
<li><a href="https://github.com/Microsoft/vscode/blob/master/src/vs/base/common/arrays.ts" target="_blank" rel="external">arrays.ts</a>，<a href="https://github.com/Microsoft/vscode/blob/master/src/vs/base/common/strings.ts" target="_blank" rel="external">strings.ts</a>，<a href="https://github.com/Microsoft/vscode/blob/master/src/vs/base/common/objects.ts" target="_blank" rel="external">objects.ts</a> 封装了一套类似underscore的api。</li>
<li><a href="https://github.com/Microsoft/vscode/blob/master/src/vs/base/common/uri.ts" target="_blank" rel="external">uri.ts</a> 和 <a href="https://github.com/Microsoft/vscode/blob/master/src/vs/base/common/paths.ts" target="_blank" rel="external">paths.ts</a> 实现了路径解析功能。</li>
<li><a href="https://github.com/Microsoft/vscode/blob/master/src/vs/base/common/winjs.base.js" target="_blank" rel="external">winjs.base.js</a> 实现了一个功能强大的Promise。</li>
</ul>
<p>另外还有很多其他的工具类，每一个模块的耦合度都很低，基本都可以单独拿出来用，学习起来也和容易。这里就不一一介绍了。</p>
<h4 id="node"><a href="https://github.com/Microsoft/vscode/tree/master/src/vs/base/node" target="_blank" rel="external">node</a></h4>
<p>node包中封装了一些node实现的功能。如</p>
<ul>
<li><a href="https://github.com/Microsoft/vscode/blob/master/src/vs/base/node/extfs.ts" target="_blank" rel="external">extfs.ts</a> 和 <a href="https://github.com/Microsoft/vscode/blob/master/src/vs/base/node/pfs.ts" target="_blank" rel="external">pfs.ts</a> 封装了文件操作相关的api。</li>
<li><a href="https://github.com/Microsoft/vscode/blob/master/src/vs/base/node/request.ts" target="_blank" rel="external">request.ts</a> 封装了网络请求的api，能方便的发送网络请求，加载json，下载文件。</li>
<li><a href="https://github.com/Microsoft/vscode/blob/master/src/vs/base/node/service.cp.ts" target="_blank" rel="external">service.cp.ts</a> 和 <a href="https://github.com/Microsoft/vscode/blob/master/src/vs/base/node/service.net.ts" target="_blank" rel="external">service.net.ts</a> 封装了socket和进程通讯的api。</li>
<li><a href="https://github.com/Microsoft/vscode/blob/master/src/vs/base/node/zip.ts" target="_blank" rel="external">zip.ts</a> 封装了解压缩文件的操作</li>
</ul>
<h4 id="parts"><a href="https://github.com/Microsoft/vscode/tree/master/src/vs/base/parts" target="_blank" rel="external">parts</a></h4>
<p>这个包额外定义了一些复杂的UI组件，tree 和 quickopen。</p>
<h3 id="editor_and_language"><a href="https://github.com/Microsoft/vscode/tree/master/src/vs/editor" target="_blank" rel="external">editor</a> and <a href="https://github.com/Microsoft/vscode/tree/master/src/vs/language" target="_blank" rel="external">language</a></h3>
<p>本篇主要了解vscode基本框架的结构，这两包作为编辑器功能的主要实现，这里面的逻辑太复杂就不细说了。</p>
<h3 id="platform_and_workbench"><a href="https://github.com/Microsoft/vscode/tree/master/src/vs/platform" target="_blank" rel="external">platform</a> and <a href="https://github.com/Microsoft/vscode/tree/master/src/vs/workbench" target="_blank" rel="external">workbench</a></h3>
<p>vscode中基本所有的具体功能实现代码都在这两包中。platform主要定义了一些服务的接口和简单实现，workbench则实现了这些接口，并且创建了一个工作台，构建了一个完整界面结构。</p>
<hr>
<p>下面从程序入口开始，从源码一步一步来看vscode是怎样运行起来的。</p>
<h2 id="启动主进程">启动主进程</h2>
<p>Eletron通过<a href="https://github.com/Microsoft/vscode/blob/master/package.json" target="_blank" rel="external">package.json</a>中的<a href="https://github.com/Microsoft/vscode/blob/master/package.json#L8" target="_blank" rel="external">main字段</a>来定义应用入口。<a href="https://github.com/Microsoft/vscode/blob/master/src/main.js" target="_blank" rel="external">main.js</a> 是vscode的入口。</p>
<h3 id="初始化loader">初始化loader</h3>
<p>这个模块是一个壳，主要解析多语言配置，然后初始化loader，通过loader加载 <a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/electron-main/main.ts" target="_blank" rel="external">main.ts</a>。</p>
<pre><code><span class="comment">// Load our code once ready</span>
app.once(<span class="string">'ready'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">var</span> nlsConfig = getNLSConfiguration();
    process.env[<span class="string">'VSCODE_NLS_CONFIG'</span>] = <span class="built_in">JSON</span>.stringify(nlsConfig);
    <span class="built_in">require</span>(<span class="string">'./bootstrap-amd'</span>).bootstrap(<span class="string">'vs/workbench/electron-main/main'</span>);
});
</code></pre><p>这里的 <a href="https://github.com/Microsoft/vscode/blob/master/src/bootstrap-amd.js" target="_blank" rel="external">bootstrap-amd.js</a> 负责创建一个loader，实现异步加载。</p>
<pre><code>loader.config({
    baseUrl: uriFromPath(path.join(__dirname)),
    catchError: <span class="literal">true</span>,
    nodeRequire: <span class="built_in">require</span>,
    nodeMain: __filename,
    <span class="string">'vs/nls'</span>: nlsConfig
});

......

exports.bootstrap = <span class="function"><span class="keyword">function</span> <span class="params">(entrypoint)</span> </span>{
    <span class="keyword">if</span> (!entrypoint) {
        <span class="keyword">return</span>;
    }

    loader([entrypoint], <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{ }, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>{ <span class="built_in">console</span>.error(err); });
};
</code></pre><h3 id="解析命令行参数">解析命令行参数</h3>
<p>在 <a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/electron-main/main.ts" target="_blank" rel="external">main.ts</a> 中依赖一个 <a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/electron-main/env.ts" target="_blank" rel="external">env</a> 的模块</p>
<pre><code><span class="reserved">import</span> env = <span class="built_in">require</span>(<span class="string">'vs/workbench/electron-main/env'</span>);
</code></pre><p>该模块负责命令行参数的解析，以及读取 <a href="https://github.com/Microsoft/vscode/blob/master/package.json" target="_blank" rel="external">package.json</a> 和 <a href="https://github.com/Microsoft/vscode/blob/master/product.json" target="_blank" rel="external">product.json</a> 保存软件的一些基本信息，主要变量如下：</p>
<pre><code><span class="comment">// 是否是发行版</span>
<span class="keyword">export</span> <span class="keyword">const</span> isBuilt = !process.env.VSCODE_DEV;
<span class="comment">// 应用程序根目录</span>
<span class="keyword">export</span> <span class="keyword">const</span> appRoot = path.dirname(uri.parse(<span class="built_in">require</span>.toUrl(<span class="string">''</span>)).fsPath);
<span class="comment">// 产品配置</span>
<span class="keyword">export</span> <span class="keyword">const</span> product: IProductConfiguration = productContents;
<span class="comment">// 程序版本</span>
<span class="keyword">export</span> <span class="keyword">const</span> version = app.getVersion();
<span class="comment">// 命令行参数</span>
<span class="keyword">export</span> <span class="keyword">const</span> cliArgs = parseCli();
<span class="comment">// 数据文件目录</span>
<span class="keyword">export</span> <span class="keyword">const</span> appHome = app.getPath(<span class="string">'userData'</span>);
<span class="comment">// setting文件路径</span>
<span class="keyword">export</span> <span class="keyword">const</span> appSettingsPath = path.join(appSettingsHome, <span class="string">'settings.json'</span>);
<span class="comment">// keybindings文件路径</span>
<span class="keyword">export</span> <span class="keyword">const</span> appKeybindingsPath = path.join(appSettingsHome, <span class="string">'keybindings.json'</span>);
<span class="comment">// 用户插件目录</span>
<span class="keyword">export</span> <span class="keyword">const</span> userExtensionsHome = cliArgs.extensionsHomePath || path.join(userHome, <span class="string">'extensions'</span>);
</code></pre><h3 id="初始化管理器">初始化管理器</h3>
<p>在main.ts的main方法中，初始化了主进程中的各个管理器</p>
<pre><code>// Lifecycle
lifecycle.manager.ready();

// <span class="operator"><span class="keyword">Load</span> settings
settings.manager.loadSync();</span>

// Propagate to clients
windows.manager.ready(userEnv);

// <span class="operator"><span class="keyword">Install</span> Menu
menu.manager.ready();</span>

.....

// Setup auto <span class="operator"><span class="keyword">update</span>
UpdateManager.initialize();</span>
</code></pre><ul>
<li><a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/electron-main/lifecycle.ts" target="_blank" rel="external">lifecycle</a> 负责管理软件的生命周期，派发<code>onBeforeQuit</code>等事件。</li>
<li><a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/electron-main/settings.ts" target="_blank" rel="external">setting</a> 负责管理用户设置和快捷键绑定的读取和存储。</li>
<li><a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/electron-main/windows.ts" target="_blank" rel="external">windows</a> 负责窗口的创建和管理，非常核心的一个模块。</li>
<li><a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/electron-main/menus.ts" target="_blank" rel="external">menus</a> 负责菜单栏的创建。</li>
<li><a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/electron-main/update-manager.ts" target="_blank" rel="external">update-manager</a> 自动更新功能。</li>
</ul>
<p>以上管理器中大量使用了Eletron的 <code>ipc</code> 模块发送接收渲染进程的消息，来实现主进程和渲染进程的交互。</p>
<h3 id="打开第一个窗口">打开第一个窗口</h3>
<p>在main.ts的main方法的最后</p>
<pre><code><span class="comment">// Open our first window</span>
<span class="keyword">if</span> (<span class="keyword">env</span>.cliArgs.openNewWindow &amp;&amp; <span class="keyword">env</span>.cliArgs.pathArguments.length === <span class="number">0</span>) {
    windows.manager.open({ cli: <span class="keyword">env</span>.cliArgs, forceNewWindow: true, forceEmpty: true }); <span class="comment">// new window if "-n" was used without paths</span>
} <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">global</span>.macOpenFiles &amp;&amp; <span class="keyword">global</span>.macOpenFiles.length &amp;&amp; (!<span class="keyword">env</span>.cliArgs.pathArguments || !<span class="keyword">env</span>.cliArgs.pathArguments.length)) {
    windows.manager.open({ cli: <span class="keyword">env</span>.cliArgs, pathsToOpen: <span class="keyword">global</span>.macOpenFiles }); <span class="comment">// mac: open-file event received on startup</span>
} <span class="keyword">else</span> {
    windows.manager.open({ cli: <span class="keyword">env</span>.cliArgs, forceNewWindow: <span class="keyword">env</span>.cliArgs.openNewWindow, diffMode: <span class="keyword">env</span>.cliArgs.diffMode }); <span class="comment">// default: read paths from cli</span>
}
</code></pre><p>调用了 <code>windows</code> 模块的 <code>open</code> 方法打开了第一个窗口。这里调用了 <code>env.cliArgs</code> 获取命令行参数传递给 <code>open</code> 方法来实现不同的打开方式。</p>
<p>在 <code>open</code> 方法中创建一个了 <code>VSCodeWindow</code> 实例，并且通过 <code>toConfiguration</code> 方法创建了一个 <code>IWindowConfiguration</code> 的对象。</p>
<p><code>IWindowConfiguration</code> 中定义了大量的 <code>env</code> 中的信息，包括环境变量，命令行参数，软件信息等。在之后 <code>IWindowConfiguration</code> 会作为参数传递给 <code>VSCodeWindow</code> 的 <code>load</code> 方法。</p>
<p><code>VSCodeWindow</code> 包装了一个 <code>BrowserWindow</code> 对象。<code>load</code> 方法调用 <code>getUrl</code> 加载了一个的 <a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/electron-browser/index.html" target="_blank" rel="external">html文件</a>。</p>
<pre><code><span class="keyword">private</span> getUrl(config: IWindowConfiguration): <span class="built_in">string</span> {
    <span class="keyword">let</span> url = <span class="built_in">require</span>.toUrl(<span class="string">'vs/workbench/electron-browser/index.html'</span>);

    <span class="comment">// Config</span>
    url += <span class="string">'?config='</span> + <span class="built_in">encodeURIComponent</span>(<span class="built_in">JSON</span>.stringify(config));

    <span class="keyword">return</span> url;
}
</code></pre><p>可以看到 <code>IWindowConfiguration</code> 被序列化成字符串作为参数传递给了 <code>index.html</code>。由于在浏览器进程要获取主进程中 <code>env</code> 模块的数据比较复杂(需要使用 <code>ipc</code> 通讯)。所以这里直接将一些基本信息打包成config传递给了浏览器进程。这时浏览器窗口才正式打开并初始化。</p>
<h2 id="启动浏览器">启动浏览器</h2>
<h3 id="初始化loader-1">初始化loader</h3>
<p>浏览器的入口在 <a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/electron-browser/index.html" target="_blank" rel="external">index.html</a> 中。与主进程类似这里也对loader进行了初始化并加载浏览器主模块 <a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/electron-browser/main.ts" target="_blank" rel="external">main</a> 。主要代码如下：</p>
<pre><code><span class="comment">// 解析config参数</span>
<span class="keyword">var</span> args = parseURLQueryArgs();
<span class="keyword">var</span> configuration = <span class="built_in">JSON</span>.parse(args[<span class="string">'config'</span>]);
......
<span class="comment">// loader的加载根目录</span>
<span class="keyword">var</span> rootUrl = uriFromPath(configuration.appRoot) + <span class="string">'/out'</span>;
<span class="comment">// 加载loader</span>
createScript(rootUrl + <span class="string">'/vs/loader.js'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="comment">// 多语言配置</span>
    <span class="keyword">var</span> nlsConfig;
    <span class="keyword">try</span> {
        <span class="keyword">var</span> config = process.env[<span class="string">'VSCODE_NLS_CONFIG'</span>];
        <span class="keyword">if</span> (config) {
            nlsConfig = <span class="built_in">JSON</span>.parse(config);
        }
    } <span class="keyword">catch</span> (e) {
    }
    <span class="keyword">if</span> (!nlsConfig) {
        nlsConfig = { availableLanguages: {} };
    }
    <span class="comment">// 配置loader</span>
    <span class="built_in">require</span>.config({
        baseUrl: rootUrl,
        <span class="string">'vs/nls'</span>: nlsConfig,
        recordStats: configuration.enablePerformance
    });
    ......
    <span class="built_in">require</span>([
        <span class="comment">// 项目正式发布后大多数的js都被合并进了workbench.main.js中</span>
        <span class="string">'vs/workbench/workbench.main'</span>,
        <span class="string">'vs/nls!vs/workbench/workbench.main'</span>,
        <span class="string">'vs/css!vs/workbench/workbench.main'</span>
    ], <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
        timers.afterLoad = <span class="keyword">new</span> <span class="built_in">Date</span>();

        <span class="comment">// 浏览器主模块</span>
        <span class="keyword">var</span> main = <span class="built_in">require</span>(<span class="string">'vs/workbench/electron-browser/main'</span>);

        <span class="comment">// config作为参数，调用startup启动主模块</span>
        main.startup(configuration, globalSettings).then(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
            mainStarted = <span class="literal">true</span>;
        }, <span class="function"><span class="keyword">function</span><span class="params">(error)</span> </span>{ onError(error, enableDeveloperTools) });
    });
});
</code></pre><h3 id="初始化工作台">初始化工作台</h3>
<p>在 <a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/electron-browser/main.ts" target="_blank" rel="external">main</a> 模块的 <code>startup</code> 方法中进一步加工 <code>config</code>，并创建了一个 <code>workspace</code>。</p>
<pre><code>export function startup(environment: IMainEnvironment, globalSettings: IGlobalSettings): winjs<span class="built_in">.</span>TPromise<span class="subst">&lt;</span><span class="literal">void</span><span class="subst">&gt;</span> {

    <span class="comment">// 将主进程中的环境变量合并到浏览器进程</span>
    assign(process<span class="built_in">.</span>env, environment<span class="built_in">.</span>userEnv);

    <span class="comment">// Shell Configuration</span>
    <span class="keyword">let</span> shellConfiguration: IConfiguration <span class="subst">=</span> {
        env: environment
    };
    <span class="attribute">...</span><span class="attribute">...</span>
    <span class="keyword">let</span> shellOptions: IOptions <span class="subst">=</span> {
        <span class="attribute">...</span><span class="attribute">...</span>
    };
    <span class="attribute">...</span><span class="attribute">...</span>
    <span class="comment">// Open workbench</span>
    <span class="keyword">return</span> openWorkbench(getWorkspace(environment), shellConfiguration, shellOptions);
}

function getWorkspace(environment: IMainEnvironment): IWorkspace {
    <span class="keyword">if</span> (<span class="subst">!</span>environment<span class="built_in">.</span>workspacePath) {
        <span class="keyword">return</span> <span class="built_in">null</span>;
    }
    <span class="attribute">...</span><span class="attribute">...</span>
    <span class="keyword">let</span> workspace: IWorkspace <span class="subst">=</span> {
        <span class="string">'resource'</span>: workspaceResource,
        <span class="string">'id'</span>: platform<span class="built_in">.</span>isLinux <span class="subst">?</span> realWorkspacePath : realWorkspacePath<span class="built_in">.</span>toLowerCase(),
        <span class="string">'name'</span>: folderName,
        <span class="string">'uid'</span>: platform<span class="built_in">.</span>isLinux <span class="subst">?</span> folderStat<span class="built_in">.</span>ino : folderStat<span class="built_in">.</span>birthtime<span class="built_in">.</span>getTime(),
        <span class="string">'mtime'</span>: folderStat<span class="built_in">.</span>mtime<span class="built_in">.</span>getTime()
    };

    <span class="keyword">return</span> workspace;
}
</code></pre><p>这里的 <code>environment</code> 就是上文的 <code>config</code>。 <code>IWorkspace</code> 记录了当前打开的文件夹路径等信息(当打开单文件时 <code>IWorkspace</code> 不存在)。</p>
<pre><code><span class="reserved">function</span> openWorkbench(<span class="attribute">workspace</span>: IWorkspace, <span class="attribute">configuration</span>: IConfiguration, <span class="attribute">options</span>: IOptions): winjs.TPromise&lt;<span class="reserved">void</span>&gt; {
    <span class="reserved">let</span> eventService = <span class="keyword">new</span> EventService();
    <span class="reserved">let</span> contextService = <span class="keyword">new</span> WorkspaceContextService(eventService, workspace, configuration, options);
    <span class="reserved">let</span> configurationService = <span class="keyword">new</span> ConfigurationService(contextService, eventService);

    <span class="keyword">return</span> configurationService.initialize<span class="function"><span class="params">()</span>.<span class="title">then</span><span class="params">(() =&gt; {
            ......
            <span class="reserved">let</span> shell = <span class="keyword">new</span> WorkbenchShell(<span class="built_in">document</span>.body, workspace, {
                configurationService,
                eventService,
                contextService
            }, configuration, options);
            shell.open();
            ......
    })</span>;
}</span>
</code></pre><p>在 <code>openWorkbench</code> 创建了三个基本服务(Service)，并将 <code>config</code>，<code>workspace</code> 等参数传给 <code>WorkbenchShell</code> 。<code>WorkbenchShell</code> 获取html文档的 <code>body</code> 节点准备创建界面。</p>
<h3 id="初始化服务">初始化服务</h3>
<p><a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/electron-browser/shell.ts" target="_blank" rel="external">WorkbenchShell</a> 主要负责初始化各服务(Service)，并创建了一个 <code>Workbench</code> 完成界面的初始化工作。</p>
<p>常用的Service比如</p>
<ul>
<li>IStorageService 浏览器进程数据的持久化存储与读取。</li>
<li>IWorkspaceContextService 获取工作空间数据和config等基本配置信息。</li>
<li>IKeybindingService 管理快捷键相关的注册。</li>
<li>IFileService 封装了文件操作的相关API，并实现 <code>FileWatcher</code> 功能。</li>
<li>IExtensionService 管理插件的初始化，加载和交互。</li>
<li>IInstantiationService 负责创建实例对象，这个Service比较重要，下面单独说明。</li>
</ul>
<p><code>initInstantiationService</code> 方法中创建了各个服务，并返回 <code>IInstantiationService</code>。</p>
<h5 id="IInstantiationService">IInstantiationService</h5>
<p>在vscode中随处可见 <code>IInstantiationService</code> 的应用。以 <code>CloseWindowAction</code> 为例</p>
<pre><code>export <span class="class"><span class="keyword">class</span> <span class="title">CloseWindowAction</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">Action</span> </span>{

    <span class="keyword">public</span> <span class="keyword">static</span> ID = <span class="string">'workbench.action.closeWindow'</span>;
    <span class="keyword">public</span> <span class="keyword">static</span> LABEL = nls.localize(<span class="string">'closeWindow'</span>, <span class="string">"Close Window"</span>);

    constructor(id: string, label: string, @IWindowService <span class="keyword">private</span> windowService: IWindowService) {
        <span class="keyword">super</span>(CloseWindowAction.ID, label);
    }

    <span class="keyword">public</span> run(): TPromise&lt;<span class="keyword">boolean</span>&gt; {
        <span class="keyword">this</span>.windowService.getWindow().close();

        <span class="keyword">return</span> TPromise.as(<span class="keyword">true</span>);
    }
}
</code></pre><p>在构造函数(<code>constructor</code>)中，后面的参数写法比较特殊</p>
<pre><code><span class="annotation">@IWindowService</span> <span class="keyword">private</span> windowService: IWindowService
</code></pre><p>使用了 <code>@IWindowService</code> 这种decorate语法。当要创建 <code>CloseWindowAction</code> 这个实例时，可以使用 <code>IInstantiationService</code> 只需要传入前两个参数，在<code>IInstantiationService</code> 中能获取所有的其他服务对象， <code>windowService</code> 这个参数由 <code>IInstantiationService</code> 传入。</p>
<pre><code><span class="keyword">this</span>.instantiationService.createInstance(CloseWindowAction, CloseWindowAction.ID， CloseWindowAction.LABEL);
</code></pre><h3 id="创建Workbench">创建Workbench</h3>
<p><a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/electron-browser/shell.ts" target="_blank" rel="external">WorkbenchShell</a> 的 <code>createContents</code> 方法还创建了一个 <code>Workbench</code> 负责整个界面的创建。</p>
<pre><code>private createContents(<span class="attribute">parent</span>: Builder): Builder {
    ......
    <span class="regexp">//</span> Instantiation service <span class="reserved">with</span> services
    <span class="reserved">let</span> instantiationService = <span class="keyword">this</span>.initInstantiationService();
    ......
    <span class="regexp">//</span> Workbench
    <span class="keyword">this</span>.workbench = <span class="keyword">new</span> Workbench(workbenchContainer.getHTMLElement(), <span class="keyword">this</span>.workspace, <span class="keyword">this</span>.configuration, <span class="keyword">this</span>.options, instantiationService);
    <span class="keyword">this</span>.workbench.startup({
        <span class="attribute">onServicesCreated</span>: <span class="function"><span class="params">()</span> =&gt;</span> {
            <span class="keyword">this</span>.initExtensionSystem();
        },
        <span class="attribute">onWorkbenchStarted</span>: <span class="function"><span class="params">()</span> =&gt;</span> {
            <span class="keyword">this</span>.onWorkbenchStarted();
        }
    });
    ......
}
</code></pre><p><code>Workbench</code> 是 <code>IPartService</code> 的具体实现。vscode由多个Part组成。</p>
<ul>
<li>activitybar 是最左边(也可以设置到右边)的选项卡。目前有 <code>Explore</code>，<code>Search</code>，<code>Git</code>，<code>Debug</code> 这4个选项卡。</li>
<li>sidebar 是activitybar选中的内容。</li>
<li>editor 是最主要的编辑器部分。</li>
<li>statusbar 是下方的状态栏。</li>
<li>panel 是状态栏上方的面板选项卡，目前主要有 <code>output</code>，<code>debug</code>，<code>errorlist</code> 等几个面板。</li>
<li>quickopen 是悬浮在中上方的弹出界面，常用的命令面板(F1)就是一个<code>quickopen widget</code>。</li>
</ul>
<p><img src="http://xzper.qiniudn.com/2016/04/2.png" alt=""></p>
<p>下面的代码展示了各个part的创建，并添加到显示列表。</p>
<pre><code><span class="keyword">private</span> <span class="title">renderWorkbench</span>(): <span class="keyword">void</span> {
    ......
    <span class="comment">// Create Parts</span>
    <span class="keyword">this</span>.createActivityBarPart();
    <span class="keyword">this</span>.createSidebarPart();
    <span class="keyword">this</span>.createEditorPart();
    <span class="keyword">this</span>.createPanelPart();
    <span class="keyword">this</span>.createStatusbarPart();

    <span class="comment">// Create QuickOpen</span>
    <span class="keyword">this</span>.createQuickOpen();

    <span class="comment">// Add Workbench to DOM</span>
    <span class="keyword">this</span>.workbenchContainer.build(<span class="keyword">this</span>.container);
}
</code></pre><h2 id="扩展点的注册和实现">扩展点的注册和实现</h2>
<p>vscode中几乎每个部分都是可扩展的。例如最常见的有快捷键命令的注册，编辑器类型的扩展，扩展输出面板Channel。下面以 <code>ViewletRegistry</code> 为例，分析 <code>activitybar</code> 和 <code>sidebar</code> 上面的 <code>Explore</code> 文件浏览器是如何显示的。</p>
<h3 id="contribution">contribution</h3>
<p>通常情况下以 <code>.contribution</code> 结尾的模块，都用作扩展点的注册。由于一般情况下这些模块不会被其他模块依赖，所以要提供一个入口来加载这些模块，这个入口就是 <a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/workbench.main.js" target="_blank" rel="external">workbench.main</a>。</p>
<p>其中 <code>Explore</code> 文件浏览器的注册是在 <a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/parts/files/browser/files.contribution.ts" target="_blank" rel="external">files.contribution</a> 中定义的。</p>
<pre><code><span class="comment">// Register Viewlet</span>
(&lt;ViewletRegistry&gt;Registry.<span class="keyword">as</span>(ViewletExtensions.Viewlets)).registerViewlet(<span class="keyword">new</span> ViewletDescriptor(
    <span class="string">'vs/workbench/parts/files/browser/explorerViewlet'</span>,
    <span class="string">'ExplorerViewlet'</span>,
    VIEWLET_ID,
    nls.localize(<span class="string">'explore'</span>, <span class="string">"Explorer"</span>),
    <span class="string">'explore'</span>,
    <span class="number">0</span>
));

(&lt;ViewletRegistry&gt;Registry.<span class="keyword">as</span>(ViewletExtensions.Viewlets)).setDefaultViewletId(VIEWLET_ID);
</code></pre><p><code>explorerViewlet</code> 模块是 <code>Explore</code> 的界面显示入口。</p>
<h3 id="registry">registry</h3>
<p>platform 中定义了 <code>IRegistry</code> 接口及实现。</p>
<pre><code>export interface IRegistry {

    <span class="javadoc">/**
     * Adds the extension functions and properties defined by data to the
     * platform. The provided id must be unique.
     *<span class="javadoctag"> @param</span> id a unique identifier
     *<span class="javadoctag"> @param</span> data a contribution
     */</span>
    add(id: string, data: any): <span class="keyword">void</span>;

    <span class="javadoc">/**
     * Returns true iff there is an extension with the provided id.
     *<span class="javadoctag"> @param</span> id an extension idenifier
     */</span>
    knows(id: string): <span class="keyword">boolean</span>;

    <span class="javadoc">/**
     * Returns the extension functions and properties defined by the specified key or null.
     *<span class="javadoctag"> @param</span> id an extension idenifier
     */</span>
    as(id: string): any;
    as&lt;T&gt;(id: string): T;
}
</code></pre><p><code>add</code> 添加一个注册点， <code>as</code> 方法获取一个注册点对象。</p>
<p><a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/browser/viewlet.ts" target="_blank" rel="external">viewlet</a> 模块添加了 <code>ViewletRegistry</code>。</p>
<pre><code>Registry.<span class="built_in">add</span>(Extensions.Viewlets, <span class="keyword">new</span> ViewletRegistry());
</code></pre><p>之后可以通过 <code>Registry.as(Extensions.Viewlets)</code> 获取 <code>ViewletRegistry</code> 注册不同的 <code>Viewlet</code>。</p>
<h3 id="实现注册功能">实现注册功能</h3>
<p>所有的注册信息储存在 <code>ViewletRegistry</code> 中，使用时通过 <code>getViewlet</code> 或者 <code>getViewlets</code> 方法获取。 <a href="https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/browser/parts/activitybar/activitybarPart.ts" target="_blank" rel="external">activitybarPart</a> 实现了注册点的读取，并填充 <code>ActionBar</code>，显示出来。</p>
<pre><code>private createViewletSwitcher(<span class="attribute">div</span>: Builder): <span class="reserved">void</span> {

    <span class="regexp">//</span> Viewlet switcher <span class="keyword">is</span> <span class="literal">on</span> top
    <span class="keyword">this</span>.viewletSwitcherBar = <span class="keyword">new</span> ActionBar(div, {
        .......
    });
    <span class="keyword">this</span>.viewletSwitcherBar.getContainer().addClass(<span class="string">'position-top'</span>);

    <span class="regexp">//</span> Build Viewlet Actions <span class="keyword">in</span> correct order
    <span class="reserved">let</span> activeViewlet = <span class="keyword">this</span>.viewletService.getActiveViewlet();
    <span class="reserved">let</span> registry = (&lt;ViewletRegistry&gt;Registry.as(ViewletExtensions.Viewlets));
    <span class="reserved">let</span> <span class="attribute">viewletActions</span>: Action[] = registry.getViewlets()     <span class="regexp">//</span> 获取注册的viewlets
        .sort<span class="function"><span class="params">((v1: ViewletDescriptor, v2: ViewletDescriptor) =&gt; v1.order - v2.order)</span>
        .<span class="title">map</span><span class="params">((viewlet: ViewletDescriptor) =&gt; {
            <span class="reserved">let</span> action = <span class="keyword">this</span>.instantiationService.createInstance(ViewletActivityAction, viewlet.id + <span class="string">'.activity-bar-action'</span>, viewlet);
            ......
            <span class="keyword">return</span> action;
        })</span>;

    // <span class="title">Add</span> <span class="title">to</span> <span class="title">viewlet</span> <span class="title">switcher</span>
    <span class="title">this</span>.<span class="title">viewletSwitcherBar</span>.<span class="title">push</span><span class="params">(viewletActions, { label: <span class="literal">true</span>, icon: <span class="literal">true</span> })</span>;
}</span>
</code></pre><p>类似的这种扩展点还有很多，如:</p>
<ul>
<li>IWorkbenchActionRegistry 注册一个action和快捷键，并出现在命令面板中。</li>
<li>IEditorRegistry 注册一种编辑器。</li>
<li>IConfigurationRegistry 注册设置项。</li>
<li>IActionBarRegistry 注册右键菜单。</li>
</ul>
<p>这种通过注册扩展点的架构方式，使得vscode整体变得很容易扩展。</p>
<h2 id="VSCode_PK_Atom">VSCode PK Atom</h2>
<p>vscode整体架构给人一种很清晰明了的感觉。多进程从主进程到浏览器，从浏览器到插件系统，服务驱动，可扩展的结构。</p>
<p>另外无论是UI组件还是工具和加载器都是自身实现的，没有借助第三方模块，使得耦合性和性能都得到了很好的保障。这也是vscode速度比Atom快的原因。</p>
<p>尽管扩展vscode自身是很容易的，但是目前vscode开放的插件接口还是极其有限。由于为了保证渲染进程的安全和速度，插件是一个单独的Node进程，插件进程无法创建UI，这一点使得vscode的插件开放没有Atom灵活，很多需要借助UI的插件功能也无法实现。</p>
<h2 id="结语">结语</h2>
<p>微软大法好</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>vscode作为微软推出的现代编辑器已经在GitHub上<a href="https://github.com/Microsoft/vscode" target="_blank" rel="external">开源</a>了。用过vscode的人都纷纷表示速度极快，秒杀同为使用<a href="https://github.com/electron/electron" target="_blank" rel="external">Electron</a>架构的<a href="https://github.com/atom/atom" target="_blank" rel="external">Atom</a>。这次我们从源码级别来剖析为何vscode快速，高效。</p>
]]>
    
    </summary>
    
      <category term="vscode" scheme="http://xzper.com/tags/vscode/"/>
    
      <category term="nodejs" scheme="http://xzper.com/tags/nodejs/"/>
    
      <category term="nodejs" scheme="http://xzper.com/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gulp流式操作]]></title>
    <link href="http://xzper.com/2016/04/09/gulp%E6%B5%81%E5%BC%8F%E6%93%8D%E4%BD%9C/"/>
    <id>http://xzper.com/2016/04/09/gulp流式操作/</id>
    <published>2016-04-09T09:26:41.000Z</published>
    <updated>2016-06-12T02:24:30.235Z</updated>
    <content type="html"><![CDATA[<p>对于很多刚刚接触<a href="https://github.com/gulpjs/gulp" target="_blank" rel="external">gulp</a>的人来说，常常觉得gulp中的stream操作不可理解。本篇将介绍stream在gulp中的应用，探究gulp中的流式操作。</p>
<p>一般来说gulp插件开发或者自定义任务都需要借助一些stream的包装模块。比较常用的有<a href="https://github.com/dominictarr/event-stream" target="_blank" rel="external">event-stream</a> 和 <a href="https://github.com/rvagg/through2" target="_blank" rel="external">through2</a>。</p>
<a id="more"></a>
<p>下面通过一个简单的task来熟悉这两个模块的用法。先得到如下目录结构：</p>
<pre><code>├── node_modules
│   ├── gulp
│   ├── through2
│   └── event-stream
├── media
│   ├── <span class="constant">one</span>
│   │    └── <span class="number">1.</span>txt
│   └── <span class="constant">two</span>
│        ├── <span class="number">2.</span>txt
│        └── <span class="number">3.</span>txt
├── gulpfile.js
└── package.json
</code></pre><p>我们的目标是将所有的txt文件合并成一个文件out.txt，并输出到目录dist。</p>
<p>首先创建gulp任务：</p>
<pre><code><span class="keyword">var</span> es = <span class="built_in">require</span>(<span class="string">'event-stream'</span>);
<span class="keyword">var</span> through = <span class="built_in">require</span>(<span class="string">'through2'</span>);
<span class="keyword">var</span> rimraf = <span class="built_in">require</span>(<span class="string">'rimraf'</span>);
<span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);

<span class="function"><span class="keyword">function</span> <span class="title">use_es_through</span><span class="params">()</span> </span>{
    <span class="comment">//TODO</span>
}

<span class="function"><span class="keyword">function</span> <span class="title">use_es_map</span><span class="params">()</span> </span>{
    <span class="comment">//TODO</span>
}

<span class="function"><span class="keyword">function</span> <span class="title">use_through2_obj</span><span class="params">()</span> </span>{
    <span class="comment">//TODO    </span>
}

<span class="function"><span class="keyword">function</span> <span class="title">concat</span><span class="params">(fn)</span> </span>{
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">return</span> gulp.src([<span class="string">'media/**/*.txt'</span>])
            .pipe(fn())
            .pipe(gulp.dest(<span class="string">'dist'</span>));
    };
}

gulp.task(<span class="string">'clean'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(cb)</span> </span>{
    rimraf(<span class="string">'dist'</span>, cb);
});

gulp.task(<span class="string">'concat1'</span>, [<span class="string">'clean'</span>], concat(use_es_through));
gulp.task(<span class="string">'concat2'</span>, [<span class="string">'clean'</span>], concat(use_es_map));
gulp.task(<span class="string">'concat3'</span>, [<span class="string">'clean'</span>], concat(use_through2_obj));
</code></pre><p>这里用到了<code>gulp.task</code>定义了4个任务。用法为：</p>
<pre><code>gulp.task(name[, deps], <span class="function"><span class="keyword">fn</span>)</span>
</code></pre><p><code>name</code> 任务的名字，之后可以通过 <code>gulp %taskname%</code> 的方式来执行该任务。</p>
<p><code>deps</code> 一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。</p>
<p><code>fn</code> 该函数定义任务所要执行的一些操作。如果该函数接受一个callback参数，当任务结束时需要调用callback，如上<code>clean</code>任务的用法。该函数也可以返回一个<code>stream</code>或者<code>Promise</code>对象，<code>concat</code>这个函数便是返回的<code>stream</code>对象。</p>
<p><code>concat</code>接受一个function参数，执行实际的合并操作。这个function返回一个<code>WritableStream</code>作为<code>pipe</code>的参数。这里定义了<code>use_es_through</code>， <code>use_es_map</code>， <code>use_through2_obj</code>三个函数演示stream的操作。</p>
<h3 id="vinyl文件系统">vinyl文件系统</h3>
<p>虽然gulp使用的是stream，但却不是普通的Node Stream，实际上，gulp(以及gulp插件)用的应该叫做<a href="https://github.com/gulpjs/vinyl" target="_blank" rel="external">Vinyl File Object Stream</a>。这里的Vinyl，是一种虚拟文件格式。Vinyl主要用两个属性来描述文件，它们分别是路径(<code>path</code>)及内容(<code>contents</code>)。具体来说，Vinyl并不神秘，它仍然是js对象。Vinyl官方给了这样的示例：</p>
<pre><code><span class="keyword">var</span> File = require(<span class="string">'vinyl'</span>);

<span class="keyword">var</span> coffeeFile = <span class="keyword">new</span> File({
  cwd: <span class="string">"/"</span>,
  <span class="keyword">base</span>: <span class="string">"/test/"</span>,
  path: <span class="string">"/test/file.coffee"</span>,
  contents: <span class="keyword">new</span> Buffer(<span class="string">"test = 123"</span>)
});
</code></pre><p>从这段代码可以看出，Vinyl是Object，<code>path</code>和<code>contents</code>也正是这个Object的属性。</p>
<p>File的<code>contents</code>可以是Stream或者Buffer。一般来说在gulp中，都是一个Buffer对象。在gulp的插件规范中，对于<code>contents</code>是Stream的情况也是要做判断的，表示该插件是否支持Stream的File对象。如：</p>
<pre><code><span class="comment">// we don't do streams (yet)</span>
<span class="keyword">if</span> (<span class="keyword">file</span>.isStream()) {
  <span class="keyword">this</span>.emit(<span class="string">'error'</span>, <span class="keyword">new</span> PluginError(<span class="string">'gulp-concat'</span>,  <span class="string">'Streaming not supported'</span>));
  cb();
  <span class="keyword">return</span>;
}
</code></pre><p>通过<code>path</code>和<code>base</code>可以得到一个新的属性<code>relative</code>，表示相对与基本目录的相对路径。</p>
<p>关于File的更多属性及方法请参考<a href="https://github.com/gulpjs/vinyl#constructoroptions" target="_blank" rel="external">官方文档</a>。</p>
<p>gulp管道中传输的数据单位就是File对象。通过修改File属性的path或者contents来实现最终效果。</p>
<h3 id="event-stream">event-stream</h3>
<h4 id="through_(write?,_end?)">through (write?, end?)</h4>
<p>一般用法如下：</p>
<pre><code>es.through(<span class="function"><span class="keyword">function</span> <span class="title">write</span><span class="params">(data)</span> </span>{
    <span class="keyword">this</span>.emit(<span class="string">'data'</span>, data);
  },
  <span class="function"><span class="keyword">function</span> <span class="title">end</span> <span class="params">()</span> </span>{ <span class="comment">//optional</span>
    <span class="keyword">this</span>.emit(<span class="string">'end'</span>);
  })
</code></pre><p><code>write</code> 管道中每有一个data数据都会调用此方法。接受一个data参数，在方法体里面可以对data进行操作，最后通过 <code>this.emit(&#39;data&#39;, data)</code> 将数据提交，否则数据无法进入下一个<code>pipe</code>操作。在gulp中，这里的data即是上文所说的File对象。注意到write方法并没有callback参数，所以该方法是<strong>同步</strong>的，最好<strong>不要在该方法里面包含异步操作</strong>。例如像下面这样就是错误的：</p>
<pre><code>es.through(<span class="function"><span class="keyword">function</span> <span class="title">write</span><span class="params">(data)</span> </span>{
      <span class="keyword">var</span> self = <span class="keyword">this</span>;
      <span class="comment">// 执行异步的操作</span>
      setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
        self.emit(<span class="string">'data'</span>, data);
      }, <span class="number">10</span>);
  },
  <span class="function"><span class="keyword">function</span> <span class="title">end</span> <span class="params">()</span> </span>{ <span class="comment">//optional</span>
    <span class="keyword">this</span>.emit(<span class="string">'end'</span>);
  })
</code></pre><p><code>end</code> 在所有数据完成了pipe之后调用，只会调用一次。最后应当加上 <code>this.emit(&#39;end&#39;);</code> 表示调用已结束，但是这里就可以在调用了一个异步方法之后派发end事件。</p>
<pre><code>gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">return</span> gulp.src([<span class="string">'media/**/*.txt'</span>])
        .pipe(es.through(<span class="function"><span class="keyword">function</span> <span class="params">(file)</span> </span>{
            gutil.log(<span class="string">'write: '</span> + file.relative);
            <span class="keyword">this</span>.emit(<span class="string">'data'</span>, file);
        }, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
            <span class="keyword">var</span> self = <span class="keyword">this</span>;
            setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
                gutil.log(<span class="string">'It is end'</span>);
                self.emit(<span class="string">'end'</span>);
            }, <span class="number">1000</span>);
        }))
        .pipe(gulp.dest(<span class="string">'dist'</span>));
});
</code></pre><p>以上代码将media将所有txt文件复制到dist目录下，这里插入了一个<code>es.through</code>方法来输出gulp的执行顺序。执行<code>gulp</code>，输出如下：</p>
<pre><code>[<span class="number">00</span>:<span class="number">34</span>:<span class="number">13</span>] Starting <span class="string">'default'</span><span class="keyword">...</span>
[<span class="number">00</span>:<span class="number">34</span>:<span class="number">13</span>] write: one\<span class="number">1.</span>txt
[<span class="number">00</span>:<span class="number">34</span>:<span class="number">13</span>] write: two\<span class="number">2.</span>txt
[<span class="number">00</span>:<span class="number">34</span>:<span class="number">13</span>] write: two\<span class="number">3.</span>txt
[<span class="number">00</span>:<span class="number">34</span>:<span class="number">14</span>] It is end
[<span class="number">00</span>:<span class="number">34</span>:<span class="number">14</span>] Finished <span class="string">'default'</span> after <span class="number">1.03</span> s
</code></pre><p>可以看到<code>es.through</code>的write方法被执行了3次，最后才会执行end方法，并且直到派发了end事件才会结束。</p>
<p><code>es.through</code>的这两个参数都是可选参数。</p>
<pre><code><span class="literal">es</span>.through()<span class="comment">;</span>
</code></pre><p>等价于</p>
<pre><code>es.through(<span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>{
    <span class="keyword">this</span>.emit(<span class="string">'data'</span>, data);
}, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">this</span>.emit(<span class="string">'end'</span>);
});
</code></pre><p>我们再来看一下如何使用<code>es.through</code>将这三个文件合并成一个，代码如下：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">use_es_through</span><span class="params">()</span> </span>{
    <span class="keyword">var</span> contents = [];

    <span class="keyword">return</span> es.through(<span class="function"><span class="keyword">function</span> <span class="params">(file)</span> </span>{
        gutil.log(<span class="string">'I am: '</span> + file.relative);
        contents.push(file.contents);
        contents.push(<span class="keyword">new</span> Buffer(<span class="string">'\n'</span>));
    }, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">var</span> joinedContents = Buffer.concat(contents);
        <span class="keyword">var</span> output = <span class="keyword">new</span> File();
        output.contents = joinedContents;
        output.path = <span class="string">'out.txt'</span>;
        <span class="keyword">this</span>.emit(<span class="string">'data'</span>, output);

        gutil.log(<span class="string">'It is concated'</span>);
        <span class="keyword">this</span>.emit(<span class="string">'end'</span>);
    });
}
</code></pre><p>在write方法中并没有使用<code>this.emit(&#39;data&#39;, file);</code>提交当前的文件，只是将文件的<code>contents</code>保存到一个数组中。在最后的end方法中，将所有的contents使用<code>Buffer.concat</code>合并，并构造一个File对象，设置<code>contents</code>为合并后的内容，然后设置<code>path</code>，最后调用<code>this.emit(&#39;data&#39;, output);</code>(也可以换成<code>this.push(output);</code>)。</p>
<p>执行<code>gulp concat</code>，输出如下：</p>
<pre><code>[<span class="number">00</span>:<span class="number">36</span>:<span class="number">47</span>] Starting <span class="string">'clean'</span><span class="keyword">...</span>
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">47</span>] Finished <span class="string">'clean'</span> after <span class="number">4.67</span> ms
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">47</span>] Starting <span class="string">'concat1'</span><span class="keyword">...</span>
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">47</span>] I am: one\<span class="number">1.</span>txt
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">47</span>] I am: two\<span class="number">2.</span>txt
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">47</span>] I am: two\<span class="number">3.</span>txt
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">47</span>] It is concated
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">47</span>] Finished <span class="string">'concat1'</span> after <span class="number">25</span> ms
</code></pre><h4 id="map_(asyncFunction)">map (asyncFunction)</h4>
<p>这个方法解决了<code>es.through</code>中的write不能异步的问题。</p>
<pre><code>var es = <span class="keyword">require</span>(<span class="string">'event-stream'</span>)
es.map(<span class="keyword">function</span> (data, callback) {
  //transform data
  // <span class="keyword">...</span>
  callback(null, data)
})
</code></pre><p>当异步/同步操作完成时，一定要调用callback。callback的第一个参数为一个error或者null。第二个参数为返回的数据。</p>
<p>使用<code>es.map</code>实现文件合并</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">use_es_map</span><span class="params">()</span> </span>{
    <span class="keyword">var</span> contents = [];
    <span class="keyword">return</span> es.map(<span class="function"><span class="keyword">function</span> <span class="params">(file, cb)</span> </span>{
        gutil.log(<span class="string">'I am: '</span> + file.relative);
        contents.push(file.contents);
        contents.push(<span class="keyword">new</span> Buffer(<span class="string">'\n'</span>));
        cb();
    }).pipe(es.through(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">var</span> joinedContents = Buffer.concat(contents);
        <span class="keyword">var</span> output = <span class="keyword">new</span> File();
        output.contents = joinedContents;
        output.path = <span class="string">'out.txt'</span>;
        <span class="keyword">this</span>.emit(<span class="string">'data'</span>, output);

        gutil.log(<span class="string">'It is concated'</span>);
        <span class="keyword">this</span>.emit(<span class="string">'end'</span>);
    }));
}
</code></pre><p>运行<code>gulp connat2</code>。输出结果如下：</p>
<pre><code>[<span class="number">00</span>:<span class="number">38</span>:<span class="number">52</span>] Starting <span class="string">'clean'</span><span class="keyword">...</span>
[<span class="number">00</span>:<span class="number">38</span>:<span class="number">52</span>] Finished <span class="string">'clean'</span> after <span class="number">6.25</span> ms
[<span class="number">00</span>:<span class="number">38</span>:<span class="number">52</span>] Starting <span class="string">'concat2'</span><span class="keyword">...</span>
[<span class="number">00</span>:<span class="number">38</span>:<span class="number">52</span>] It is concated
[<span class="number">00</span>:<span class="number">38</span>:<span class="number">52</span>] Finished <span class="string">'concat2'</span> after <span class="number">29</span> ms
</code></pre><p>仔细看下输出结果会发现没有<code>es.map</code>中的输出信息，也就是<code>es.map</code>的回调并没有执行。再看一下输出目录dist，居然出现了3个txt文件，而且out.txt内容是空的。Oh My Bug。</p>
<p>查看一下node关于pipe的定义：</p>
<pre><code>export <span class="class"><span class="keyword">class</span> <span class="title">Readable</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">events</span>.<span class="title">EventEmitter</span> <span class="inheritance"><span class="keyword">implements</span></span> <span class="title">NodeJS</span>.<span class="title">ReadableStream</span> </span>{
    pipe&lt;T extends NodeJS.WritableStream&gt;(destination: T, options?: { end?: <span class="keyword">boolean</span>; }): T;
}
</code></pre><p><code>Readable</code>的<code>pipe</code>方法接受一个<code>WritableStream</code>的对象参数，最后返回的就是这个参数<code>WritableStream</code>。<code>es.through</code>和<code>es.map</code>返回的都是一个<code>ReadWriteStream</code>对象，所以既可以作为<code>pipe</code>的参数，也能使用<code>pipe</code>方法，实现链式调用。</p>
<p>上面的那段错误代码，返回的实际上就是<code>es.through</code>的结果，等价于：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">use_es_map</span><span class="params">()</span> </span>{
    <span class="keyword">var</span> contents = [];
    <span class="keyword">return</span> es.through(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">var</span> joinedContents = Buffer.concat(contents);
        <span class="keyword">var</span> output = <span class="keyword">new</span> File();
        output.contents = joinedContents;
        output.path = <span class="string">'out.txt'</span>;

        <span class="keyword">this</span>.emit(<span class="string">'data'</span>, output);
        <span class="keyword">this</span>.emit(<span class="string">'end'</span>);
    });
}
</code></pre><p>那怎么样才能使用<code>es.map</code>实现这个合并呢？</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">use_es_map</span><span class="params">()</span> </span>{
    <span class="keyword">var</span> contents = [];

    <span class="keyword">var</span> input = es.through();
    <span class="keyword">var</span> output = input
        .pipe(es.map(<span class="function"><span class="keyword">function</span> <span class="params">(file, cb)</span> </span>{
            gutil.log(<span class="string">'I am: '</span> + file.relative);
            contents.push(file.contents);
            contents.push(<span class="keyword">new</span> Buffer(<span class="string">'\n'</span>));
            cb();
        }))
        .pipe(es.through(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
            <span class="keyword">var</span> joinedContents = Buffer.concat(contents);
            <span class="keyword">var</span> output = <span class="keyword">new</span> File();
            output.contents = joinedContents;
            output.path = <span class="string">'out.txt'</span>;
            <span class="keyword">this</span>.emit(<span class="string">'data'</span>, output);

            gutil.log(<span class="string">'It is concated'</span>);
            <span class="keyword">this</span>.emit(<span class="string">'end'</span>);
        }));
    <span class="keyword">return</span> es.duplex(input, output);
}
</code></pre><p>简化成伪代码：</p>
<pre><code>var <span class="built_in">input</span> = es.through();
var output = <span class="built_in">input</span>
    .pipe(ReadWriteStream1)
    .pipe(ReadWriteStream2);
<span class="keyword">return</span> es.duplex(<span class="built_in">input</span>, output);
</code></pre><p>同样这段代码也等价于：</p>
<pre><code>var <span class="built_in">input</span> = es.through();
var output = ReadWriteStream2；
<span class="built_in">input</span>
    .pipe(ReadWriteStream1)
    .pipe(output);
<span class="keyword">return</span> es.duplex(<span class="built_in">input</span>, output);
</code></pre><p>这里有一个<code>es.duplex</code>方法。</p>
<h4 id="duplex_(writeStream,_readStream)">duplex (writeStream, readStream)</h4>
<p>这个函数返回一个新的<code>ReadWriteStream</code>对象，由第一个参数作为writeStream，第二个参数作为readStream。</p>
<p>当接收到来自<code>gulp.src</code>的数据(3个txt的File对象)时，流入到input中，通过两个pipe加工处理，输出为output(out.txt)。同时output又作为可读取的输入流，pipe到<code>gulp.dest</code>中。</p>
<blockquote>
<p>PS: 这段可能比较难以理解，请自行脑补管道中数据的流动过程。</p>
</blockquote>
<p>用好<code>event-stream</code>中的这三个方法，妈妈再也不用担心我不会gulp了。更多<code>event-stream</code>的用法请参阅<a href="https://github.com/dominictarr/event-stream" target="_blank" rel="external">官网文档</a></p>
<h3 id="gulp中流的执行顺序">gulp中流的执行顺序</h3>
<p>下面再通过一个例子来说明下gulp中的执行顺序：</p>
<pre><code>gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">var</span> first;

    <span class="keyword">return</span> gulp.src([<span class="string">'media/**/*.txt'</span>])
        .pipe(es.through(<span class="function"><span class="keyword">function</span> <span class="params">(file)</span> </span>{
            gutil.log(<span class="string">'1: '</span> + file.relative);
            <span class="keyword">if</span> (!first) {
                first = file;
            } <span class="keyword">else</span> {
                <span class="keyword">this</span>.emit(<span class="string">'data'</span>, file);
            }
        }, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
            <span class="keyword">var</span> self = <span class="keyword">this</span>;
            gutil.log(<span class="string">'It is first end'</span>);
            setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
                self.emit(<span class="string">'data'</span>, first);
                self.emit(<span class="string">'end'</span>);
            }, <span class="number">1000</span>);
        }))
        .pipe(es.map(<span class="function"><span class="keyword">function</span> <span class="params">(file, cb)</span> </span>{
            gutil.log(<span class="string">'2: '</span> + file.relative);
            setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
                cb(<span class="literal">null</span>, file);
            }, <span class="number">2000</span>);
        }))
        .pipe(es.through(<span class="function"><span class="keyword">function</span> <span class="params">(file)</span> </span>{
            gutil.log(<span class="string">'3: '</span> + file.relative);
            <span class="keyword">this</span>.emit(<span class="string">'data'</span>, file);
        }, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
            gutil.log(<span class="string">'It is last end'</span>);
            <span class="keyword">this</span>.emit(<span class="string">'end'</span>);
        }))
        .pipe(gulp.dest(<span class="string">'dist'</span>));
});
</code></pre><p>这里使用了3个pipe，结果如下：</p>
<pre><code>[<span class="number">00</span>:<span class="number">36</span>:<span class="number">51</span>] Starting <span class="string">'default'</span><span class="keyword">...</span>
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">51</span>] pipe1: one\<span class="number">1.</span>txt
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">51</span>] pipe1: two\<span class="number">2.</span>txt
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">51</span>] pipe2: two\<span class="number">2.</span>txt
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">51</span>] pipe1: two\<span class="number">3.</span>txt
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">51</span>] pipe2: two\<span class="number">3.</span>txt
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">51</span>] It is first end
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">52</span>] pipe2: one\<span class="number">1.</span>txt
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">53</span>] pipe3: two\<span class="number">2.</span>txt
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">53</span>] pipe3: two\<span class="number">3.</span>txt
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">54</span>] pipe3: one\<span class="number">1.</span>txt
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">54</span>] It is last end
[<span class="number">00</span>:<span class="number">36</span>:<span class="number">54</span>] Finished <span class="string">'default'</span> after <span class="number">3.04</span> s
</code></pre><p>可以得出以下结论：</p>
<ul>
<li>如果在write方法中不提交数据，那么数据不会出现在下一个pipe的write中。</li>
<li>数据在管道中的流动速度是不确定的，特别是遇到了异步方法，先处理的数据在某个步骤之后可能会落后于某个后处理的数据。 </li>
<li>每一个数据在管道中是按照pipe的顺序流动的。即<code>pipe1 -&gt; pipe2 -&gt; pipe3</code></li>
<li>当遇到了异步方法(如<code>es.map</code>)，会触发end。即<code>pipe1 -&gt; pipe2(异步) -&gt; pipe1(end)</code></li>
<li>在end方法中也可以派发data事件，提交数据。并且提交的数据会进入下一个pipe。即<code>pipe1(end)(this.push(data)) -&gt; pipe2</code></li>
</ul>
<h3 id="through2">through2</h3>
<p><code>through2</code>的用法与<code>event-stream</code>类似</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">use_through2_obj</span><span class="params">()</span> </span>{
    <span class="keyword">var</span> contents = [];

    <span class="keyword">return</span> through.obj(<span class="function"><span class="keyword">function</span> <span class="params">(file, enc, cb)</span> </span>{
        gutil.log(<span class="string">'I am: '</span> + file.relative);
        contents.push(file.contents);
        contents.push(<span class="keyword">new</span> Buffer(<span class="string">'\n'</span>));
        cb();
    }, <span class="function"><span class="keyword">function</span> <span class="params">(cb)</span> </span>{
        <span class="keyword">var</span> joinedContents = Buffer.concat(contents);
        <span class="keyword">var</span> output = <span class="keyword">new</span> File();
        output.contents = joinedContents;
        output.path = <span class="string">'out.txt'</span>;
        <span class="keyword">this</span>.push(output);

        gutil.log(<span class="string">'It is concated'</span>);
        cb();
    });
}
</code></pre><p>主要区别有：</p>
<ul>
<li><code>through</code>使用<code>push</code>方法或者<code>callback</code>的第二个参数提交数据。<code>event-stream</code>除了使用以上方法还可以使用<code>emit</code>来提交数据。</li>
<li><code>through</code>天生就是异步的，所有参数都需要一个callback回调表示是否完成。而<code>event-stream</code>的某些api的使用方法也支持同步。</li>
</ul>
<p>其实本篇实现的合并功能已经有现成的插件支持，可以看看<a href="https://github.com/contra/gulp-concat" target="_blank" rel="external">gulp-concat</a>这个插件的源码学习一下。</p>
<p><strong>示例项目</strong>：</p>
<p><a href="https://coding.net/u/xzper/p/xzper/git/raw/master/.hexo_source/source/resource/2016/05/gulp-stream-test.zip" target="_blank" rel="external">下载地址</a></p>
<p><strong>参考文章</strong>：</p>
<p><a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">Gulp 中文网</a></p>
<p><a href="http://www.codesec.net/view/193349.html" target="_blank" rel="external">探究Gulp的Stream</a></p>
<p><a href="http://ju.outofmemory.cn/entry/69523" target="_blank" rel="external">Gulp.js深入讲解</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于很多刚刚接触<a href="https://github.com/gulpjs/gulp" target="_blank" rel="external">gulp</a>的人来说，常常觉得gulp中的stream操作不可理解。本篇将介绍stream在gulp中的应用，探究gulp中的流式操作。</p>
<p>一般来说gulp插件开发或者自定义任务都需要借助一些stream的包装模块。比较常用的有<a href="https://github.com/dominictarr/event-stream" target="_blank" rel="external">event-stream</a> 和 <a href="https://github.com/rvagg/through2" target="_blank" rel="external">through2</a>。</p>
]]>
    
    </summary>
    
      <category term="nodejs" scheme="http://xzper.com/tags/nodejs/"/>
    
      <category term="gulp" scheme="http://xzper.com/tags/gulp/"/>
    
      <category term="nodejs" scheme="http://xzper.com/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[调试vscode]]></title>
    <link href="http://xzper.com/2015/11/29/%E8%B0%83%E8%AF%95vscode/"/>
    <id>http://xzper.com/2015/11/29/调试vscode/</id>
    <published>2015-11-29T05:27:11.000Z</published>
    <updated>2016-06-12T02:24:30.251Z</updated>
    <content type="html"><![CDATA[<p>在调试vscode之前，有必要先了解一下vscode的运行过程。</p>
<h4 id="vscode的启动过程">vscode的启动过程</h4>
<p>electron是vscode的内核，vscode的启动类在package.json中定义</p>
<pre><code><span class="string">"main"</span>: <span class="string">"./out/vs/workbench/electron-main/bootstrap"</span>
</code></pre><p>electron启动时通过<code>atom.asar</code>这个文件，加载package.json中定义的main脚本启动程序。</p>
<p>如果搜索vscode的项目文件列表，你会发现其他位置还有一个bootstrap文件</p>
<pre><code>./<span class="keyword">out</span>/bootstrap.js
</code></pre><p>其实这个也是启动类，只不过是PluginHost的启动类。</p>
<a id="more"></a>
<h4 id="插件运行机制">插件运行机制</h4>
<p>和许多ide和流行的文本编辑器一样，vscode也具备插件系统。只不过vscode的插件加载运行机制和其他的程序不同。</p>
<p>如果在开启了vscode的情况下查看任务管理器，可以发现有很多的code进程。vscode里面的代码在不同的进程里面执行，并使用process.send 或者 socket 实现进程通信。</p>
<p>vscode的插件系统就是在一个单独的进程里面运行。然后插件进程和主进程进行通信，来实现插件功能。关于插件进程的启动，有兴趣的可以查看源代码</p>
<pre><code>// src/<span class="keyword">vs</span>/workbench/services/thread/electron-browser/threadService.<span class="keyword">ts</span>

// Run Plugin Host <span class="keyword">as</span> fork of current process
this.pluginHostProcessHandle = <span class="keyword">cp</span>.fork(uri.parse(require.toUrl(<span class="string">'bootstrap'</span>)).fsPath, [<span class="string">'--type=pluginHost'</span>], opts);
</code></pre><h4 id="调试类型">调试类型</h4>
<p>由于vscode的代码是在不同进程里面分开运行的，调试也得分开进行。</p>
<p>vscode里面主要有三种环境： Main， PluginHost， ExtensionHost</p>
<h5 id="Main">Main</h5>
<p>主进程环境是最容易调试的，直接选择菜单栏 Help - Toggle Developer Tools</p>
<p><img src="http://xzper.qiniudn.com/2015/11/7.png" alt=""></p>
<p>打开开发者工具，就可以直接使用chrome的调试功能查看和调试源代码了。</p>
<p><img src="http://xzper.qiniudn.com/2015/11/8.png" alt=""></p>
<p>不过可能由于打开这个面板的时机比较晚，会错过一些启动类代码的执行。不过通过切换工作空间，来重新执行一般加载过程，在这之前打断点就行了。</p>
<p>还有一种用vscode/chrome调试vscode主进程的办法。打开vscode，使用从git clone下来的vscode文件夹作为工作空间目录。修改.vscode文件夹中默认的<code>launch.json</code>文件，最后改为</p>
<pre><code>{
    "<span class="attribute">name</span>": <span class="value"><span class="string">"Attach to VSCode"</span></span>,
    "<span class="attribute">type</span>": <span class="value"><span class="string">"node"</span></span>,
    "<span class="attribute">request</span>": <span class="value"><span class="string">"attach"</span></span>,
    "<span class="attribute">port</span>": <span class="value"><span class="number">9222</span></span>,
    "<span class="attribute">sourceMaps</span>": <span class="value"><span class="literal">true</span></span>,
    "<span class="attribute">outDir</span>": <span class="value"><span class="string">"out"</span>
</span>}
</code></pre><p>注意第二行type字段用从chrome改为node。因为默认安装包里面没有vscode-chrome-debug插件，所以不支持启动chrome的调试，我们直接用vscode本身的代替就行了。</p>
<p>ps: vscode-chrome-debug插件的GitHub地址</p>
<pre><code>http<span class="variable">s:</span>//github.<span class="keyword">com</span>/Microsoft/vscode-chrome-<span class="keyword">debug</span>
</code></pre><p>然后使用命令行在其他目录启动一个要调试的vscode进程, 断点在第一行，设置端口为9222。</p>
<pre><code><span class="string">"D:/workSpace/vscode/vscode/.build\electron/CodeOSS.exe"</span> --debug-brk=<span class="number">9222</span> .
</code></pre><ul>
<li><p>CodeOSS.exe的路径根据实际路径替换，如果使用上一篇里面使用符号链接的方式构建的，CodeOSS.exe可以换成发行版的code.exe这个文件。</p>
</li>
<li><p>注意要加最后面的那个 <code>.</code> 参数，表示使用当前目录作为工作空间。</p>
</li>
<li><p>端口号也可以不改，使用<code>launch.json</code>里面另外的Attach to Extension Host这个配置就行了，不过不建议，因为这个配置的端口号是5870有可能会和之后调试插件进程的默认端口号冲突。</p>
</li>
</ul>
<p>最后在一开始打开的那个vscode里面切换到调试面板，选择 Attach to VSCode。</p>
<p><img src="http://xzper.qiniudn.com/2015/11/9.png" alt=""></p>
<p>按下F5或者点击调试按钮，程序就会Attach9222端口，并停在第一行了。之后在其他地方设置断点就行了。支持直接在ts文件上打断点，因为默认的编译参数是开启了sourceMap选项的。</p>
<h5 id="PluginHost">PluginHost</h5>
<p>由于插件进程是从主进程启动的，想要直接调试有点困难。我翻遍了官方的教程也没有找到相关文档。后来被我从源代码里面找到了其中的秘密。</p>
<pre><code><span class="comment">// Run Plugin Host as fork of current process</span>
<span class="keyword">this</span>.pluginHostProcessHandle = cp.fork(uri.parse(<span class="built_in">require</span>.toUrl(<span class="string">'bootstrap'</span>)).fsPath, [<span class="string">'--type=pluginHost'</span>], opts);
</code></pre><p>这时启动插件进程的语句，粗看只有一个 <code>--type=pluginHost</code> 的额外参数。实际上还有其他参数隐藏在了<code>opts.execArgv</code>里面。 继续追踪threadService.ts里面对execArgv操作，找到这样的一个方法。</p>
<pre><code>private resolveExecArgv(config: IConfiguration, clb: (execArgv: any) =&gt; void): void {
    // Check <span class="keyword">for</span> a free debugging port
    <span class="keyword">if</span> (typeof config.env.debugPluginHostPort === <span class="string">'number'</span>) {
        <span class="keyword">return</span> ports.findFreePort(config.env.debugPluginHostPort, <span class="number">10</span> /* <span class="keyword">try</span> <span class="number">10</span> ports */, (port) =&gt; {
            <span class="keyword">...</span>
            <span class="keyword">return</span> clb([<span class="string">'--nolazy'</span>, (config.env.debugBrkPluginHost ? <span class="string">'--debug-brk='</span> : <span class="string">'--debug='</span>) + port]);
        });
    }
    <span class="keyword">...</span>
}
</code></pre><p><code>config.env.debugBrkPluginHost</code>关键的关键就是这个属性了。如果为true则会添加一个<code>--debug-brk</code>的参数。</p>
<p>node里面<code>--debug-brk</code>参数表示在程序的第一行设置断点。那么想办法找到对<code>config.env.debugBrkPluginHost</code>这个属性赋值的地方，就可以在插件进程的第一行设置断点，再使用Attach功能，监听<code>config.env.debugBrkPluginHost</code>指定端口就可以调试插件进程了。</p>
<p>最后在</p>
<pre><code>src/<span class="keyword">vs</span>/workbench/electron-main/env.<span class="keyword">ts</span>
</code></pre><p>这个文件里面找到了设置代码</p>
<pre><code><span class="title">let</span> <span class="built_in">debug</span>BrkPluginHostPort = parseNumber(args, <span class="string">'--debugBrkPluginHost'</span>, <span class="number">5870</span>);
<span class="title">let</span> <span class="built_in">debug</span>PluginHostPort: number;
<span class="title">let</span> <span class="built_in">debug</span>BrkPluginHost: boolean;
<span class="title">if</span> (<span class="built_in">debug</span>BrkPluginHostPort) {
    <span class="title">debugPluginHostPort</span> = <span class="built_in">debug</span>BrkPluginHostPort;
    <span class="title">debugBrkPluginHost</span> = <span class="built_in">true</span>;
} <span class="title">else</span> {
    <span class="title">debugPluginHostPort</span> = parseNumber(args, <span class="string">'--debugPluginHost'</span>, <span class="number">5870</span>, isBuilt ? void <span class="number">0</span> : <span class="number">5870</span>);
}
</code></pre><p>答案出来了，就是在启动vscode的时候加一个<code>--debugBrkPluginHost</code>的参数。当然也可以指定一个端口号，不指定就使用默认5870。</p>
<p>剩下的步骤基本和上面使用vscode调试主进程的一样。在其他目录，使用命令行</p>
<pre><code><span class="title">code</span> . --<span class="built_in">debug</span>BrkPluginHost
</code></pre><p>打开一个要调试的vscode，这时vscode的的主进程启动，插件进程断点在了第一行，等待Attach连接到5870端口。</p>
<p>然后使用从git clone下来的vscode文件夹作为工作空间目录，打开另外一个vscode的调试面板，将配置切换成 Attach to Extension Host， 使用F5开启调试。会自动断点在插件进程入口的第一行</p>
<p><img src="http://xzper.qiniudn.com/2015/11/10.png" alt=""></p>
<ul>
<li>code命令实际上是调用的发行版安装目录下bin/code.js。之前如果调试主进程使用code命令开启要调试的vscode，断点会停在code.js的第一行，这样就没法在主进程的代码里面断点了。这里可以使用code命令是因为不需要调试主进程。</li>
</ul>
<h5 id="ExtensionHost">ExtensionHost</h5>
<p>用户开发的Extension的调试。这个本来是最简单的，因为官方的插件项目示例，里面已经自动生成了配置，在开发插件时直接按F5启动extensionHost类型的调试设置就可以调试用户的插件了。</p>
<p>但是由于是发行版的vscode，vscode本身的源代码被混淆压缩了，只能调试用户的插件代码，没法调试vscode自身的代码。就像下面这样，如果会提示Source is not available。</p>
<p><img src="http://xzper.qiniudn.com/2015/11/11.png" alt=""></p>
<p>如果想要显示vscode的源码，可以使用上一篇提到的<a href="http://xzper.com/2015/11/29/%E7%BC%96%E8%AF%91vscode/#mklink" target="_blank" rel="external">创建符号链接的办法</a>，让vscode始终使用源代码运行。不知道有没有直接通过修改<code>launch.json</code>文件来指定源代码目录的方法。</p>
<p>附：<br>这里加一些比较有用的启动参数</p>
<ul>
<li>—debugBrkPluginHost 调试插件进程并在插件进程的第一行位置断点，该参数指定一个端口号，默认值为5870。</li>
<li>-logPluginHostCommunication 在控制台输出主进程和插件进程的通讯消息</li>
<li>—extensionDevelopmentPath 指定开发版的插件路径 </li>
</ul>
<hr>
<p>参考链接：</p>
<p><a href="https://github.com/Microsoft/vscode/wiki/How-to-Contribute" target="_blank" rel="external">How-to-Contribute</a></p>
<p><a href="https://code.visualstudio.com/docs/extensions/overview" target="_blank" rel="external">Extending Visual Studio Code</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在调试vscode之前，有必要先了解一下vscode的运行过程。</p>
<h4 id="vscode的启动过程">vscode的启动过程</h4>
<p>electron是vscode的内核，vscode的启动类在package.json中定义</p>
<pre><code><span class="string">"main"</span>: <span class="string">"./out/vs/workbench/electron-main/bootstrap"</span>
</code></pre><p>electron启动时通过<code>atom.asar</code>这个文件，加载package.json中定义的main脚本启动程序。</p>
<p>如果搜索vscode的项目文件列表，你会发现其他位置还有一个bootstrap文件</p>
<pre><code>./<span class="keyword">out</span>/bootstrap.js
</code></pre><p>其实这个也是启动类，只不过是PluginHost的启动类。</p>
]]>
    
    </summary>
    
      <category term="nodejs" scheme="http://xzper.com/tags/nodejs/"/>
    
      <category term="vscode" scheme="http://xzper.com/tags/vscode/"/>
    
      <category term="nodejs" scheme="http://xzper.com/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编译vscode]]></title>
    <link href="http://xzper.com/2015/11/29/%E7%BC%96%E8%AF%91vscode/"/>
    <id>http://xzper.com/2015/11/29/编译vscode/</id>
    <published>2015-11-28T19:03:12.000Z</published>
    <updated>2016-06-12T02:24:30.235Z</updated>
    <content type="html"><![CDATA[<p>由于工作需要，最近开始研究vscode的源代码，这样就需要编译和调试vscode。</p>
<p>先从GitHub(<a href="https://github.com/Microsoft/vscode" target="_blank" rel="external">https://github.com/Microsoft/vscode</a>)上clone一下vscode的源代码，顺便去点个star吧。</p>
<a id="more"></a>
<p><img src="http://xzper.qiniudn.com/2015/11/4.png" alt=""></p>
<p>看一下目录结构</p>
<ul>
<li><p><strong>.build</strong> 是electron可执行文件的路径，clone出来的项目是不带这个文件夹的，需要build出来。后面会讲到。</p>
</li>
<li><p><strong>.vscode</strong> 官方人员应该是使用vscode作为的开发环境来调试和开发vscode的，所以提交了这个文件夹，里面包含了启动vscode单元测试，调试插件进程的一些配置。后面会讲解如何根据自身环境适当调整这些配置。</p>
</li>
<li><p><strong>build</strong> 编译vscode的一些自动化脚本。vscode是使用gulp来自动构建的</p>
</li>
<li><p><strong>.out</strong> 编译好的js脚本</p>
</li>
<li><p><strong>scripts</strong> 生成electron环境和npm install的脚本文件</p>
</li>
<li><p><strong>src</strong> ts源码路径</p>
</li>
</ul>
<h4 id="1-安装依赖库">1.安装依赖库</h4>
<p>官网上面说需要安装Python v2.7 和 Visual Studio(Windows下)，其实不用也行，看下面讲解。</p>
<p>首先切换到vscode的项目根目录执行</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> -g mocha gulp
scripts\npm <span class="keyword">install</span></span>
</code></pre><p>以上步骤分别为安装gulp构建器 和 安装vscode的依赖库。安装完成后会在项目的根目录下生成node_modules文件夹。</p>
<p>执行此过程可能会遇到以下问题：</p>
<ol>
<li>npm有可能由于网络原因被那啥了, 建议使用<a href="https://npm.taobao.org/" title="淘宝的NPM镜像服务" target="_blank" rel="external">淘宝的npm镜像服务</a>，使用方法在首页。</li>
</ol>
<ol>
<li>node-gyp安装失败</li>
</ol>
<p><img src="http://xzper.qiniudn.com/2015/11/5.png" alt=""></p>
<p>这个似乎是需要机器上有Visual Studio，这个东西的功能应该就是构建一些本机文件用的，安装失败没关系，我们可以从其他地方得到这些本机文件。</p>
<p>ps: 最近node-inspector老是安装不上也是因为这个的原因，有没有大神能告之解决办法。</p>
<h4 id="2-拷贝一些重要文件">2.拷贝一些重要文件</h4>
<p>在进行这个步骤之前你需要去官网下载一个发行版的vscode。这个以后大有用处。</p>
<p>之前安装依赖库的时候，node-gyp安装失败就是因为一个叫vscode-textmate模块依赖了node-gyp。如果在node_modules没有找到该模块，需要从发行版的vscode中拷贝到node_modules文件夹下。路径为</p>
<pre><code>C:<span class="command">\Program</span> Files (x86)<span class="command">\Microsoft</span> VS Code<span class="command">\resources</span><span class="command">\app</span><span class="command">\node</span>_modules<span class="command">\vscode</span>-textmate
</code></pre><p>请安装vscode的实际安装位置自行替换。</p>
<p>同理， 从安装的发行版vscode中找到node-debug， mono-debug两个插件，并拷贝到extensions目录下覆盖。</p>
<pre><code>C:<span class="command">\Program</span> Files (x86)<span class="command">\Microsoft</span> VS Code<span class="command">\resources</span><span class="command">\app</span><span class="command">\extensions</span><span class="command">\mono</span>-debug
C:<span class="command">\Program</span> Files (x86)<span class="command">\Microsoft</span> VS Code<span class="command">\resources</span><span class="command">\app</span><span class="command">\extensions</span><span class="command">\node</span>-debug
</code></pre><p>这个步骤特别重要。git上的extensions目录里面这两个插件被标记成了placeholder，里面没有实际内容，插件实现是在另外的项目中。所以需要把实际的插件实现复制过来，<strong>没有这个插件将无法使用vscode进行nodejs项目的调试</strong>。附上这两个插件的项目地址：</p>
<pre><code>//node-<span class="keyword">debug</span>和mono-<span class="keyword">debug</span>插件的项目地址
http<span class="variable">s:</span>//github.<span class="keyword">com</span>/Microsoft/vscode-node-<span class="keyword">debug</span>
http<span class="variable">s:</span>//github.<span class="keyword">com</span>/Microsoft/vscode-mono-<span class="keyword">debug</span>
</code></pre><h4 id="3-编译源代码">3.编译源代码</h4>
<p>这一步反倒很简单，vscode使用了gulp进行自动构建，只需要找vscode项目目录下，使用一行命令就行了。</p>
<pre><code><span class="title">gulp</span> watch
</code></pre><p>几分钟后编译完成，可能会有一个错误。</p>
<p><img src="http://xzper.qiniudn.com/2015/11/6.png" alt=""></p>
<p>要解决这个问题直接使用</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> run-<span class="keyword">in</span>-terminal</span>
</code></pre><p>安装一下这个模块就行了。</p>
<h4 id="4-生成electron环境">4.生成electron环境</h4>
<p>在项目根目录下执行</p>
<pre><code>scripts<span class="command">\code</span>.bat
</code></pre><p>就可以生成程序的入口可执行文件并启动了。以后如果要使用调试版本的vscode，双击code.bat或者执行这个命令即可。这样启动的vscode，左上角的标题会带有<br>Code [OSS Build]</p>
<p><a name="mklink"></a></p>
<p>这个过程会下载electron的安装包，有可能会失败。不过不要紧, 下面讲解如何不使用electron 和 code.bat启动调试版本的vscode的办法。</p>
<p>找到vscode发行版的安装目录下的resources文件夹</p>
<pre><code>cd C:<span class="command">\Program</span> Files (x86)<span class="command">\Microsoft</span> VS Code<span class="command">\resources</span>
</code></pre><p>将这个目录下的app文件夹重命名备份一下。然后创建一个链接到vscode项目目录的符号链接</p>
<pre><code>ren app app_backup
mklink /D app D:<span class="command">\workSpace</span><span class="command">\vscode</span><span class="command">\vscode</span>
</code></pre><p><code>D:\workSpace\vscode\vscode</code> 这个目录是git clone下来的项目根目录，请自行替换。</p>
<p>这样运行发行版的vscode, 实际上就是运行从git上clone下来的项目里面的代码了。正常打开vscode就是调试版本的了。 我就是使用的这种符号链接的形式来偷天换日的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于工作需要，最近开始研究vscode的源代码，这样就需要编译和调试vscode。</p>
<p>先从GitHub(<a href="https://github.com/Microsoft/vscode" target="_blank" rel="external">https://github.com/Microsoft/vscode</a>)上clone一下vscode的源代码，顺便去点个star吧。</p>
]]>
    
    </summary>
    
      <category term="vscode" scheme="http://xzper.com/tags/vscode/"/>
    
      <category term="nodejs" scheme="http://xzper.com/tags/nodejs/"/>
    
      <category term="nodejs" scheme="http://xzper.com/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vscode编译和调试nodejs/typescript项目]]></title>
    <link href="http://xzper.com/2015/11/29/%E6%90%AD%E5%BB%BAvscode%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"/>
    <id>http://xzper.com/2015/11/29/搭建vscode调试环境/</id>
    <published>2015-11-28T16:46:30.000Z</published>
    <updated>2016-06-14T04:10:23.364Z</updated>
    <content type="html"><![CDATA[<p>vscode是微软最新推出的使用<a href="https://github.com/atom/atom" title="atom" target="_blank" rel="external">atom</a>的<a href="https://github.com/atom/electron" title="electron" target="_blank" rel="external">electron</a>技术开发的新一代文本编辑器。</p>
<p>同时最近也在GitHub(<a href="https://github.com/Microsoft/vscode" target="_blank" rel="external">https://github.com/Microsoft/vscode</a>)上开源了。</p>
<p>本文简单的教大家如何使用vscode的构建和调试功能。</p>
<a id="more"></a>
<h3 id="构建项目">构建项目</h3>
<p>vscode使用<strong>task.json</strong>来配置项目的构建过程。</p>
<p>打开命令面板(Ctrl+Shift+P)选择Run Build Task(Ctrl+Shift+B)</p>
<p><img src="http://xzper.qiniudn.com/2015/11/1.png" alt=""></p>
<p>如果当前工作空间没有<strong>task.json</strong>配置文件此时会出现提示</p>
<p><img src="http://xzper.qiniudn.com/2015/11/2.png" alt=""></p>
<p>选择 Configure Task Runner 自动创建<strong>task.json</strong>。该配置文件在工作空间的.vscode目录下，这个目录也是存放vscode配置的文件夹。</p>
<p>vscode默认的task配置文件中给出了执行tsc 和 gulp模板配置。简单介绍一下<strong>task.json</strong>的写法</p>
<pre><code>{
    <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,

    <span class="comment">// 要使用的命令或者可执行文件的路径</span>
    <span class="string">"command"</span>: <span class="string">"tsc"</span>,

    <span class="comment">// 对应command参数，是否是一个命令，否则为执行文件路径</span>
    <span class="string">"isShellCommand"</span>: <span class="literal">true</span>,

    <span class="comment">// 是否在执行task任务时显示控制台窗口</span>
    <span class="string">"showOutput"</span>: <span class="string">"always"</span>,

    <span class="comment">// 对应command参数指定程序的参数</span>
    <span class="string">"args"</span>: [<span class="string">"-p"</span>, <span class="string">"src"</span>, <span class="string">"--allowJs"</span>, <span class="string">"-w"</span>],

    <span class="comment">// 不太明白这个，基本用不到</span>
    <span class="string">"problemMatcher"</span>: <span class="string">"$tsc"</span>,
}
</code></pre><p>另外还有更多参数和用法可以参照下面的官方文档</p>
<p><a href="https://code.visualstudio.com/docs/editor/tasks" target="_blank" rel="external">https://code.visualstudio.com/docs/editor/tasks</a></p>
<p>配置好了之后使用默认的快捷键Ctrl+Shift+B即可执行编译。</p>
<h3 id="运行和调试项目">运行和调试项目</h3>
<p>vscode默认支持nodejs，ts，js等项目的调试。使用<strong>launch.json</strong>p配置调试参数。</p>
<p>调试启动调试的默认快捷键是F5， 如果没有<strong>launch.json</strong>则会弹窗提示选择调试环境，并自动创建<strong>launch.json</strong>。</p>
<p><img src="http://xzper.qiniudn.com/2015/11/3.png" alt=""></p>
<p>以调试node项目为例，简单说明下<strong>launch.json</strong>的写法</p>
<pre><code>{
    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,
    <span class="string">"configurations"</span>: [
        {
            <span class="comment">// 启动配置的名称。每个程序可能有多个启动配置</span>
            <span class="comment">// 此名称将显示在调试面板的下拉框中</span>
            <span class="string">"name"</span>: <span class="string">"Launch"</span>,
            <span class="comment">// 配置的类型，默认有三种类型(node,momo,extensionHost)</span>
            <span class="comment">// 可以通过插件来自定义更多的类型</span>
            <span class="string">"type"</span>: <span class="string">"node"</span>,
            <span class="comment">// 请求类型, launch表示启动程序调试，attach表示监听某一端口进行调试</span>
            <span class="string">"request"</span>: <span class="string">"launch"</span>,
            <span class="comment">// node程序的入口脚本路径(相对于工作空间)</span>
            <span class="string">"program"</span>: <span class="string">"./out/bootstrap.js"</span>,
            <span class="string">"stopOnEntry"</span>: <span class="literal">false</span>,
            <span class="comment">// 接在program指定js后面的参数</span>
            <span class="string">"args"</span>: [],
            <span class="comment">// 程序的启动位置</span>
            <span class="string">"cwd"</span>: <span class="string">"."</span>,
            <span class="comment">// 启动程序的路径, 如果为null则使用默认的node</span>
            <span class="string">"runtimeExecutable"</span>: <span class="literal">null</span>,
            <span class="comment">// 传递给node的参数</span>
            <span class="string">"runtimeArgs"</span>: [
                <span class="string">"--nolazy"</span>,
                <span class="string">"--es_staging"</span>,
                <span class="string">"--harmony-proxies"</span>
            ],
            <span class="comment">// 程序启动时设置的环境变量</span>
            <span class="string">"env"</span>: {
                <span class="string">"NODE_ENV"</span>: <span class="string">"development"</span>
            },
            <span class="string">"externalConsole"</span>: <span class="literal">false</span>,
            <span class="comment">// 是否使用sourceMaps</span>
            <span class="string">"sourceMaps"</span>: <span class="literal">true</span>,
            <span class="comment">// 如果使用sourceMaps，js脚本所在的路径</span>
            <span class="string">"outDir"</span>: <span class="string">"./out"</span>
        },
        {
            <span class="string">"name"</span>: <span class="string">"Attach"</span>,
            <span class="string">"type"</span>: <span class="string">"node"</span>,
            <span class="comment">// attach表示监听某一端口进行调试</span>
            <span class="string">"request"</span>: <span class="string">"attach"</span>,
            <span class="comment">// 要监听的端口</span>
            <span class="string">"port"</span>: <span class="number">5858</span>,
            <span class="comment">// 是否使用sourceMaps</span>
            <span class="string">"sourceMaps"</span>: <span class="literal">true</span>,
            <span class="comment">// 如果使用sourceMaps，js脚本所在的路径</span>
            <span class="string">"outDir"</span>: <span class="string">"./out"</span>
        }
    ]
}
</code></pre><p>这里面对应了launch和attach两个配置任务。说下两者的区别。</p>
<p>launch实际上是启动一个node执行指定代码，同时可以在vscode里面打断点调试。以上述配置为例，实际执行的命令为</p>
<pre><code><span class="comment">node</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">debug</span><span class="literal">-</span><span class="comment">brk=30001</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">nolazy</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">es_staging</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">harmony</span><span class="literal">-</span><span class="comment">proxies</span> <span class="comment">out\bootstrap</span><span class="string">.</span><span class="comment">js</span> 
</code></pre><p>端口号是随机的，vscode能打断点调试是因为他内部监听了这个端口，并与node通讯实现调试。</p>
<p>attach就是监听的任务。例如<strong>其他程序</strong>启动了一个node应用并使用了—debug-brk参数开启了5858端口使程序暂停在了第一行。此时启动attach任务，就可以监听到这个端口，并在<strong>vscode里面</strong>调试这个node应用了。</p>
<p>附上一张vscode调试面板的截图</p>
<p><img src="http://xzper.qiniudn.com/2015/11/debugging_hero.png" alt=""></p>
<p>有关如何调试的教程</p>
<p><a href="https://code.visualstudio.com/docs/editor/debugging" target="_blank" rel="external">https://code.visualstudio.com/docs/editor/debugging</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>vscode是微软最新推出的使用<a href="https://github.com/atom/atom" title="atom" target="_blank" rel="external">atom</a>的<a href="https://github.com/atom/electron" title="electron" target="_blank" rel="external">electron</a>技术开发的新一代文本编辑器。</p>
<p>同时最近也在GitHub(<a href="https://github.com/Microsoft/vscode" target="_blank" rel="external">https://github.com/Microsoft/vscode</a>)上开源了。</p>
<p>本文简单的教大家如何使用vscode的构建和调试功能。</p>
]]>
    
    </summary>
    
      <category term="vscode" scheme="http://xzper.com/tags/vscode/"/>
    
      <category term="nodejs" scheme="http://xzper.com/tags/nodejs/"/>
    
      <category term="nodejs" scheme="http://xzper.com/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TP-MR12U路由器刷openwrt和不死boot]]></title>
    <link href="http://xzper.com/2015/07/11/TP-MR12U%E5%88%B7openwrt-%E4%B8%8D%E6%AD%BBboot/"/>
    <id>http://xzper.com/2015/07/11/TP-MR12U刷openwrt-不死boot/</id>
    <published>2015-07-11T08:09:38.000Z</published>
    <updated>2016-06-12T02:24:30.235Z</updated>
    <content type="html"><![CDATA[<p>前不久买了一个无线路由器TP-MR12U，买这个东西的初衷是想和家里另外一个主路由做桥接并自动上vpn，这样两个wifi信号一个和谐上网，一个科学上网。然而，买来后才发现这个路由器是v2版本的，并不能同时支持开启无线中继wds和vpn拨号功能，也就是然并卵。经过一番调查，发现或许可以通过刷入openwrt固件的方式实现这些功能。于是，就有了此教程。刷机有风险，入市需谨慎。</p>
<a id="more"></a>
<p>openwrt是一个嵌入式的Linux系统，在各种路由器中应用广泛。OpenWrt的特点：</p>
<ul>
<li>可扩展性好，可以在线安装您所需要的功能，目前有1000多个功能包可选；</li>
<li>是一台完整的Linux工作站，文件系统可读可写，便于开发者学习和实践；</li>
</ul>
<p>boot是路由器最核心的部分，通常路由器重置恢复出厂设置一般都是因为有boot的存在所以能够还原回去。不死boot就是指刷入这个boot之后，你的路由器就不会因为刷固件失败而变砖了，DIY党必备。</p>
<p>首先你需要一下东西：</p>
<ul>
<li>硬件：TP-MR12U(v2)路由器一个，网线一根，PC一台，戳菊花工具一根。</li>
<li>软件：</li>
</ul>
<ul>
<li>TPRouter:用于修改固件版本信息。</li>
<li>putty:以命令行方式登陆路由器。</li>
<li>WinSCP:上传文件到路由器。</li>
</ul>
<ul>
<li>固件：</li>
</ul>
<ul>
<li>(1)对应的openwrt解锁U-Boot分区固件，文件名为openwr-ar71xx-generic-tl-mr13u-v1-squashfs-factory.bin。看清楚是13U的不是12U的，因为12U(v1)和12U(v2)硬件不同，12U(v2)需要使用13U(v1)的固件。这个也是我们第一次需要刷入的固件。</li>
<li>(2)openwrt适用于MR13U的官方固件，文件名为openwrt-ar71xx-generic-tl-mr13u-v1-squashfs-factory.bin。这个是最终我们使用的固件。</li>
<li>(3)不死boot固件，文件名为breed-ar9331-mr12u.bin。</li>
</ul>
<p>以上软件和固件我已经打包好下面是下载链接：</p>
<p><a href="https://coding.net/u/xzper/p/xzper/git/raw/master/.hexo_source/source/resource/2015/07/TPRouter.zip" target="_blank" rel="external">TPRouter.zip</a></p>
<h2 id="TPRouter-zip">TPRouter.zip</h2>
<p>1.打开TPRouter，点击浏览，选择解锁了U-Boot分区的固件1，看清楚文件名千万别选错了。如下图修改：</p>
<p><img src="http://xzper.qiniudn.com/2015/07/01.png" alt=""></p>
<p>修改完成后，再次打开就会发现固件标示变为了00120201。上面压缩包中的文件已经修改好，可以跳过这一步，有不放心的可以打开看看。</p>
<p>2.第一次戳菊花，开机状态下按住路由器reset按5秒，重置路由器。</p>
<p>3.使用网线连接路由器和电脑，电脑也不要连接其他的无线网，电脑ip使用自动获取。浏览器打开192.168.1.1，进入路由器界面。选择系统工具→软件升级。点击浏览选择修改好的固件1，并升级。<br>等待过程中可以打开cmd窗口，输入</p>
<pre><code><span class="title">ping</span> <span class="number">192.168.1.1</span> -t
</code></pre><p>用来检查电脑和路由的连接状态，一旦ping通了说明路由器初始化好了。</p>
<p>4.重启好了之后，再次打开192.168.1.1即可看到高大上openwrt的初始界面了。</p>
<p><img src="http://xzper.qiniudn.com/2015/07/02.png" alt=""></p>
<p>也先别激动，这次刚刚开始。</p>
<p>5.以上步骤刷入了一个u-boot分区可以写入的系统，接下来就是将不死boot写入到u-boot分区。打开putty，使用Telnet协议以命令行的模式登陆路由器。注意是<strong>使用Telnet连接</strong>，设置如下图：</p>
<p><img src="http://xzper.qiniudn.com/2015/07/03.png" alt=""></p>
<p>6.openwrt的默认账号是root，密码没有。为了能使用WinSCP给路由器上传文件，需要设置路由器的密码，在putty中输入以下命令：</p>
<pre><code><span class="title">passwd</span> root
</code></pre><p>然后按照提示输入要设置的密码。输入密码不会显示到控制台但是已经输入了。控制台输出如下：</p>
<p><img src="http://xzper.qiniudn.com/2015/07/04.png" alt=""></p>
<p>7.使用WinSCP将不死boot固件3上传到路由器的tmp文件夹。打开WinSCP，按照如下图配置：</p>
<p><img src="http://xzper.qiniudn.com/2015/07/05.png" alt=""></p>
<p>注意协议类型选择SCP。</p>
<p>点击Login后会弹出一个Warning窗口，不要管，点击add或者yes。进入管理界面。左边选中固件所在目录，右边选中/tmp目录。将breed-ar9331-mr12u.bin拖入左边上传到路由器tmp目录下。如下图：</p>
<p><img src="http://xzper.qiniudn.com/2015/07/06.png" alt=""></p>
<p>8.上传好了之后就该刷入不死boot了。首先重启putty，使用ssh的方式连接路由器。设置如下图：</p>
<p><img src="http://xzper.qiniudn.com/2015/07/07.png" alt=""></p>
<p>跟 WinSCP 一样，如果是第一次使用 PuTTY 登录路由，那么会有一些确定窗口，点击yes。进入到命令行窗口，然后输入用户名root和密码。如下图：</p>
<p><img src="http://xzper.qiniudn.com/2015/07/08.png" alt=""></p>
<p>先使用cat命令查看一下当前的分区。输入命令</p>
<pre><code> cat /<span class="keyword">proc</span>/mtd
</code></pre><p>输出如下：</p>
<p><img src="http://xzper.qiniudn.com/2015/07/09.png" alt=""></p>
<p>这次要刷入的就是u-boot分区</p>
<p>再获取路由器的mac地址。输入命令</p>
<pre><code><span class="title">ifconfig</span> eth0
</code></pre><p>输出如下：</p>
<p><img src="http://xzper.qiniudn.com/2015/07/10.png" alt=""></p>
<p>图中红框框起来打码的部分就是mac地址。先记录并备份一下待会会用到。</p>
<p>最后输入命令刷入不死boot</p>
<pre><code><span class="keyword">cd</span> /tmp
mtd <span class="keyword">write</span> breed-ar9331-mr12u.bin <span class="keyword">u</span>-boot
</code></pre><p>成功的话，如下图：</p>
<p><img src="http://xzper.qiniudn.com/2015/07/11.png" alt=""></p>
<p>最后输入<code>reboot</code>命令重启路由器或者直接将路由器关机。</p>
<p>Tips：如果你一开始的openwrt固件是官方的，因为默认是锁了u-boot分区的。到了这一步就会报错</p>
<pre><code>Could <span class="keyword">not</span> <span class="keyword">open</span> mtd device: u-boot
Can<span class="attribute">'t</span> <span class="keyword">open</span> device <span class="keyword">for</span> writing!
</code></pre><p>提示无法写入到u-boot分区。解决办法参见最后的FAQ。</p>
<p>9.进入u-boot控制台。路由器<strong>和电脑连接</strong>，在路由器<strong>关机状态</strong>下，使用暴菊工具<strong>按住reset按钮</strong>不放，打开路由器开关，过一会会看到蓝色灯亮一下，再过一会会看到蓝色灯闪4下，这时松开reset按钮。在浏览器中输入192.168.1.1，即可进入u-boot设置界面。</p>
<p>10.修改mac地址。u-root会将mac地址重置，此时需要将mac地址还原回来，不然有些功能无法使用，比如无线功能。将之前备份好的mac地址输入到设置框中，如下图设置：</p>
<p><img src="http://xzper.qiniudn.com/2015/07/12.png" alt=""></p>
<p>11.刷入官方的openwrt固件。在u-boot控制台选择固件更新→固件，选中固件2点击上传。如下图：</p>
<p><img src="http://xzper.qiniudn.com/2015/07/13.png" alt=""></p>
<p>这时等待更新就行了。</p>
<p>有了不死boot就可以随意刷了，变砖了重复步骤9-11。</p>
<p>12.路由器重启后进入192.168.1.1即可看到官方的openwrt的luci界面了。至此不死boot和openwrt刷入成功，撒花庆祝。</p>
<p><img src="http://xzper.qiniudn.com/2015/07/14.png" alt=""></p>
<p>至于如何配置openwrt实现开篇所说的功能，等下回再说吧。特此感谢@hackpascal大牛的固件。</p>
<p>【FAQ】</p>
<p>1.问：步骤8中使用mdt命令提示无法写入怎么办？</p>
<p>答：这种情况就是因为当前openwrt锁了u-boot分区，需要刷一个未锁分区的openwrt固件，也就是教程中的固件1。刷入方法就是按照使用WinSCP将固件1上传到路由器/tmp目录。然后使用mdt写入固件到firmware分区。<br>命令如下：</p>
<pre><code><span class="keyword">cd</span> /tmp
mdt <span class="keyword">write</span> openwr-ar71xx-generic-<span class="keyword">tl</span>-mr13u-v1-squashfs-factory.bin firmware
reboot
</code></pre><p>重启好了之后就可以从步骤4开始刷入不死boot了。</p>
<p>参考链接：</p>
<p><a href="http://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=154561&amp;page=1" target="_blank" rel="external">【U-Boot】U-Boot 刷机方法大全</a></p>
<p><a href="http://www.right.com.cn/forum/thread-142763-1-1.html" target="_blank" rel="external">TP-LINK 全系列解锁 U-Boot 分区固件</a></p>
<p><a href="http://www.right.com.cn/forum/thread-161906-1-1.html" target="_blank" rel="external">AR/QCA/MT7620 Breed，功能强大的多线程 Bootloader</a></p>
<p>欢迎转载，转载请注明出处 <a href="http://xzper.com" target="_blank" rel="external">http://xzper.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前不久买了一个无线路由器TP-MR12U，买这个东西的初衷是想和家里另外一个主路由做桥接并自动上vpn，这样两个wifi信号一个和谐上网，一个科学上网。然而，买来后才发现这个路由器是v2版本的，并不能同时支持开启无线中继wds和vpn拨号功能，也就是然并卵。经过一番调查，发现或许可以通过刷入openwrt固件的方式实现这些功能。于是，就有了此教程。刷机有风险，入市需谨慎。</p>
]]>
    
    </summary>
    
      <category term="未分类" scheme="http://xzper.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次曲折的调试经历]]></title>
    <link href="http://xzper.com/2015/05/11/%E4%B8%80%E6%AC%A1%E6%9B%B2%E6%8A%98%E7%9A%84%E8%B0%83%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    <id>http://xzper.com/2015/05/11/一次曲折的调试经历/</id>
    <published>2015-05-11T13:31:26.000Z</published>
    <updated>2015-06-05T07:24:43.397Z</updated>
    <content type="html"><![CDATA[<p>前不久在FlexLite的开发者群里面遇到一个开发者的提问，说是在使用List的时候水平滚动条的大小有错误。截图大概是下面这样：</p>
<p><img src="http://xzper.qiniudn.com/2015/05/01.png" alt=""></p>
<a id="more"></a>
<p>可以看到水平滚动条的宽度是不对的。经过简单的了解，发现代码没错。本着(好)助(奇)人(害)为(死)乐(猫)的精神，决定找出问题所在。我简化代码，写了个DEMO，也复现了这个问题。代码大致如下只有两个类：<br>主类：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">FlexLiteTest</span><span class="params">()</span>
</span>{
    super();
    Injector.mapClass(Theme, VectorTheme);
    Debugger.initialize(stage);
}

override <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">createChildren</span><span class="params">()</span>:<span class="title">void</span>
</span>{
    <span class="keyword">var</span> <span class="keyword">array</span>:<span class="keyword">Array</span> = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> i:int = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) 
    {
        <span class="keyword">array</span>.push(i);
    }
    <span class="keyword">var</span> <span class="keyword">list</span>:<span class="keyword">List</span> = <span class="keyword">new</span> <span class="keyword">List</span>();
    <span class="keyword">list</span>.x = <span class="number">10</span>;
    <span class="keyword">list</span>.y = <span class="number">10</span>;
    <span class="keyword">list</span>.skinName = MyListSkin;
    <span class="keyword">list</span>.width = <span class="number">400</span>;
    <span class="keyword">var</span> hLayout:HorizontalLayout = <span class="keyword">new</span> HorizontalLayout();
    hLayout.verticalAlign = VerticalAlign.CONTENT_JUSTIFY; 
    <span class="keyword">list</span>.layout = hLayout;
    <span class="keyword">list</span>.dataProvider = <span class="keyword">new</span> ArrayCollection(<span class="keyword">array</span>);
    this.addElement(<span class="keyword">list</span>);
}
</code></pre><p>List皮肤类：</p>
<pre><code><span class="package"><span class="keyword">package</span>
{</span>
    <span class="preprocessor"><span class="keyword">import</span> org.flexlite.domUI.skins.vector.ListSkin;</span>

    <span class="comment">/**
     * @author xzper
     */</span>
    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListSkin</span> <span class="keyword">extends</span> <span class="title">ListSkin</span>
    </span>{
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">MyListSkin</span><span class="params">()</span>
        </span>{
            <span class="keyword">super</span>();
        }

        <span class="keyword">override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">createChildren</span><span class="params">()</span><span class="type">:void</span>
        </span>{
            <span class="keyword">super</span>.createChildren();
            scroller.horizontalScrollBar.skinName = MyHScrollBarSkin;
        }
    }
}
<span class="preprocessor"><span class="keyword">import</span> org.flexlite.domUI.skins.vector.HScrollBarSkin;</span>

<span class="class"><span class="keyword">class</span> <span class="title">MyHScrollBarSkin</span> <span class="keyword">extends</span> <span class="title">HScrollBarSkin</span>
</span>{
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">createChildren</span><span class="params">()</span><span class="type">:void</span>
    </span>{
        <span class="keyword">super</span>.createChildren();
    }
}
</code></pre><p>代码大意很简单，就是想换一下List的水平滚动条的皮肤，有不想写重复代码于是就是继承自ListSkin和HScrollBarSkin写了个皮肤。</p>
<p>经过简单的一番排查，发现注释掉</p>
<pre><code><span class="attribute">list.skinName </span>=<span class="string"> MyListSkin; </span>
</code></pre><p>或者</p>
<pre><code><span class="attribute">scroller.horizontalScrollBar.skinName </span>=<span class="string"> MyHScrollBarSkin; </span>
</code></pre><p>最后的结果是没问题的，如下图：</p>
<p><img src="http://xzper.qiniudn.com/2015/05/02.png" alt=""></p>
<p>那么问题肯定就出在了那个滚动条皮肤上面了。细看代码，发现其实滚动条皮肤就重写了一个createChildren的方法，啥也没干。此时思维陷入僵局…看来此路不通。</p>
<p>既然是显示结果的问题，那么换种思路，从结果入手，滚动条的宽度比预期值小了很多，通过FlexLite框架自带的一个调试工具，可以清楚地看到运行时各个组件大小位置的实际值测量值和布局结果。调试工具需要在项目开始初始化</p>
<pre><code>Debugger.initialize(stage);
</code></pre><p>然后默认按F11开启。通过调试面板定位到滚动条，如下图：</p>
<p><img src="http://xzper.qiniudn.com/2015/05/03.png" alt=""></p>
<p>发现水平滚动条的宽度是对的，布局宽为400，但是皮肤的宽是错的。<br>因为FlexLite里面有两种皮肤，一种是Skin可显示对象版的皮肤和StateSkin非显示对象皮肤。这里用到的是继承自Skin的可显示对象皮肤。布局的宽和测量宽是一样的都是86。</p>
<p><img src="http://xzper.qiniudn.com/2015/05/04.png" alt=""></p>
<p>那么问题就出在这里了。滚动条皮肤的布局宽(layoutBoundsWidth)是错误的，理应该也是400。这时可以回到代码了，在适当的地方下断点，找到原因，问题就能解决了。</p>
<p>我给重写了下MyHScrollBarSkin的setLayoutBoundsSize，并在这里下断点。这样可以找出什么地方给MyHScrollBarSkin设置了一个错误的布局尺寸。</p>
<p><img src="http://xzper.qiniudn.com/2015/05/05.png" alt=""></p>
<p>启动程序。发现这个断点根本就进不去，也就是说没有任何地方设置水平滚动条的布局尺寸，那么滚动条的布局尺寸是哪里来的呢，通过UIComponent的源码发现，没有设置布局尺寸的话，通过getter方法获取到的layoutBoundsWidth值就是explicitWidth或者measuredWidth，显然这地方是使用的measuredWidth。看到这里，问题就变成了setLayoutBoundsSize这个方法为何没有被调用。</p>
<p>通过查看调用层次结构，发现本来setLayoutBoundsSize应该在UIAssets的updateDisplayList方法里面被调用的（因为SkinnableComponent继承自UIAssets，刷新显示列表的时候会设置皮肤的布局属性）。于是我在UIAssets的updateDisplayList方法里面下断点，尝试找到皮肤没有被布局的原因。由于updateDisplayList会被反复调用，为了更精确我给断点加了条件表达式这样会少很多麻烦。</p>
<p><img src="http://xzper.qiniudn.com/2015/05/06.png" alt=""></p>
<p><img src="http://xzper.qiniudn.com/2015/05/07.png" alt=""></p>
<p>因为只有滚动条才有value属性，用这个表达式可以确保断点每次进入时都是滚动条触发的。经过几次断点，发现问题是出了在一个scaleSkin的实例变量上面。这个变量不知是何原因变成了false，导致条件判断不通过，导致皮肤没有被布局。</p>
<p><img src="http://xzper.qiniudn.com/2015/05/08.png" alt=""></p>
<p>答案似乎近在眼前了，scaleSkin被设置成了false导致皮肤没有跟着主机组件进行缩放。那么找到设置scaleSkin这个值为false的位置就行了。理所当然的，我使用调用层次结构和查找引用的功能企图找到项目中设置这个值的地方，然而得到的结果却是除了初始化给这个属性赋值了一次true以外，没有任何地方给这个属性重新赋值。甚至使用了Ctrl+H全局搜索这个scaleSkin的字符串得到结果也是一样。这个结果难免让我无法接受。scaleSkin被莫名其妙地改了值？</p>
<p>既然这样，我决定改一下UIAssets的代码，将scaleSkin的定义方式从public的声明方式改为getter/setter方法，这样可以下断点调试何时设置了scaleSkin的值。</p>
<pre><code><span class="keyword">private</span> <span class="keyword">var</span> _scaleSkin:Boolean = <span class="literal">true</span>;
<span class="comment">/**
 * 是否缩放皮肤
 */</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span> <span class="title">scaleSkin</span><span class="params">()</span><span class="type">:Boolean</span>
</span>{
    <span class="keyword">return</span> _scaleSkin;
}
<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> <span class="title">scaleSkin</span><span class="params">(value:Boolean)</span><span class="type">:void</span>
</span>{
    _scaleSkin = value;
}
</code></pre><p>编译，运行。还没来得及设置断点，结果让我又惊有喜。这次运行结果居然是对的，我有点不敢相信，再次编译运行，结果还是对的。改回去，结果就是错的了。</p>
<p>心中暗骂，这他妈是什么gui。Flash编译器的bug？？？？反正不管怎样，这样写没错就是了，于是将解决方案告之。但是我心中总感觉似乎有哪里不对劲，难到这真的是编译器的bug？那么为什么将赋值皮肤的那一行去掉结果也没问题呢？</p>
<p>就在我神情恍惚之际，我一步一步地断点调试。发现一开始scaleSkin确实是true，然后某一个步骤之后scaleSkin就变成了false。我开始逐渐缩小这个区间，最后将目标锁定到了SkinnableComponent的这个函数里面</p>
<pre><code><span class="comment">/**
 * 卸载皮肤
 */</span>        
<span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">detachSkin</span><span class="params">(skin:Object)</span><span class="type">:void</span>
</span>{       
    <span class="keyword">if</span>(hasCreatedSkinParts)
    {
        removeSkinParts();
        hasCreatedSkinParts = <span class="literal">false</span>;
    }
    <span class="keyword">if</span>(skin <span class="keyword">is</span> ISkin)
    {
        <span class="keyword">var</span> skinParts:Vector.&lt;String&gt; = SkinPartUtil.getSkinParts(<span class="keyword">this</span>);
        <span class="keyword">for</span> <span class="keyword">each</span>(<span class="keyword">var</span> partName:String <span class="keyword">in</span> skinParts)
        {
            <span class="keyword">if</span>(!(partName <span class="keyword">in</span> <span class="keyword">this</span>))
                <span class="keyword">continue</span>;
            <span class="keyword">if</span> (<span class="keyword">this</span>[partName] != <span class="literal">null</span>)
            {
                partRemoved(partName,<span class="keyword">this</span>[partName]);
            }
            <span class="keyword">this</span>[partName] = <span class="literal">null</span>;
        }
        (skin <span class="keyword">as</span> ISkin).hostComponent = <span class="literal">null</span>;
    }
}
</code></pre><p>我发现在for each某一个循环之后，scaleSkin发生了变化。同时通过断点发现skinParts居然还包含了一个scaleSkin的值</p>
<p><img src="http://xzper.qiniudn.com/2015/05/09.png" alt=""></p>
<p>果然罪魁祸首找到了，就是这里。使用[]的方式对属性进行赋值，逃过了查找引用和全局搜索。真是天网恢恢，总会漏那么一点。</p>
<p>在卸载旧皮肤的时候（因为在ListSkin里面HScroller添加到显示列表会有一个主题皮肤，然后在MyListSkin会又设置一次HScroller的皮肤，所以会触发卸载皮肤的方法）框架内部将scaleSkin当成了皮肤部件，使用了 this[“scaleSkin”] = null 的方式改变了这个属性的值。</p>
<p>那么新的问题又产生了，scaleSkin怎么会成为了皮肤部件？通过查看SkinPartUtil的getSkinParts方法</p>
<p><img src="http://xzper.qiniudn.com/2015/05/10.png" alt=""></p>
<p>不难发现第47行，没有使用toString()，导致判断永远成立，这个类里面的所有public的属性都被当做了皮肤部件。解决办法就是加上toString()。</p>
<pre><code><span class="keyword">if</span>(basicTypes.indexOf(node.@<span class="class"><span class="keyword">type</span>.<span class="title">toString</span></span>())==-<span class="number">1</span>)
</code></pre><p>另外SkinnableComponent在卸载皮肤校验时,没有判断部件是否也存在与皮肤中，可以将</p>
<pre><code><span class="keyword">if</span>(!(partName <span class="keyword">in</span> <span class="keyword">this</span>))
    <span class="keyword">continue</span>;
</code></pre><p>改为</p>
<pre><code><span class="keyword">if</span>(!(partName <span class="keyword">in</span> <span class="keyword">this</span>)||!(partName <span class="keyword">in</span> <span class="keyword">this</span>.skin))
    <span class="keyword">continue</span>;
</code></pre><p>到这里问题才算是彻底解决了。遇到问题还是需要刨根问底，不然永远只能停留在表面上。<br>最后附上错误代码的DEMO项目，<s>留个纪念</s>：</p>
<p><a href="http://xzper.qiniudn.com/2015/05/FlexLiteTest.zip" title="FlexLiteTest" target="_blank" rel="external">http://xzper.qiniudn.com/2015/05/FlexLiteTest.zip</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前不久在FlexLite的开发者群里面遇到一个开发者的提问，说是在使用List的时候水平滚动条的大小有错误。截图大概是下面这样：</p>
<p><img src="http://xzper.qiniudn.com/2015/05/01.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="FlexLite" scheme="http://xzper.com/tags/FlexLite/"/>
    
      <category term="ActionScript3" scheme="http://xzper.com/tags/ActionScript3/"/>
    
      <category term="未分类" scheme="http://xzper.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[突破AIR程序的权限限制]]></title>
    <link href="http://xzper.com/2015/01/24/%E7%AA%81%E7%A0%B4AIR%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9D%83%E9%99%90%E9%99%90%E5%88%B6/"/>
    <id>http://xzper.com/2015/01/24/突破AIR程序的权限限制/</id>
    <published>2015-01-24T05:27:45.000Z</published>
    <updated>2016-06-14T04:10:23.402Z</updated>
    <content type="html"><![CDATA[<p>AIR中有些API在没有权限的情况下是不生效的，甚至不报错也没没有任何提示。例如文件系统中对敏感目录的文件操作，File.applicationDirectory这个API的文档是这样说的</p>
<blockquote>
<p>出于安全原因，不推荐修改应用程序目录中的内容，有些平台上的操作系统会阻止此操作。<br>如果要存储特定于应用程序的数据，请考虑使用应用程序存储目录 (File.applicationStorageDirectory)。</p>
</blockquote>
<p>可以看到File.applicationDirectory这个目录是无法保证有权限写入的。这篇文章讲解如何在Windows和Mac下突破这一限制，能获取系统中任何目录的操作权限。</p>
<a id="more"></a>
<p>解决这个问题基本思路是想办法让程序获得管理员所有权，一旦程序有了权限就可以肆无忌惮了。但是，一个没有权限的程序在运行时是无法提升权限的，只能在程序启动时，赋予权限。也就是说要想让程序有权限，必须通过另一个程序。假设我们的AIR程序叫A，这个可以提升其他AIR程序权限的程序叫elevate，调用elevate，传入A的路径，启动A就行了。这里有两种方案：</p>
<p>1.使用一个壳，壳启动时调用elevate以管理员方式启动A，这样A就获得了权限。</p>
<p>2.启动A，这时A是没有权限的，然后A调用elevate，启动程序B，由B来执行一切需要权限的敏感操作。</p>
<p>elevate这个程序在为其他程序申请权限的时候是需要认证的。在Windows7及其以上，如果用户开启了用户账户控制(UAC)，那么会弹出提示框，让用户点击确认的。在Mac上是需要输入用户密码，来完成授权的。那么方案1，程序A在启动时，会提示用户确认，然后一劳永逸，A想干啥就干啥了。方案2，程序A只有在需要进行敏感操作时就会提示用户确认，如果B在执行完任务后退出了，那么下次需要权限时又得确认了。两种方案各有好处。我们最终选用了方案B，毕竟程序启动时来那么一个提示框对用户体验不太好。</p>
<p>说了这么多，下面祭出大杀器elevate。</p>
<p>Windows下使用下面提供的elevate.exe。<br>Mac下使用下面提供的elevate.scpt。</p>
<p>有了elevate在AIR下使用NativeProcess启动elevate，并传入参数。用法如下：</p>
<pre><code><span class="comment">/**
 * 以管理员方式执行程序
 * @param exePath 要执行的程序路径
 * @param args 要传入的参数
 */</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">(exePath:String , exeArgs:Vector.&lt;String&gt; = null)</span><span class="type">:void</span>
</span>{
    <span class="keyword">var</span> elevateFolder:File = File.applicationDirectory.resolvePath(<span class="string">"bin"</span>);
    <span class="keyword">var</span> nativeProcess:NativeProcess = <span class="keyword">new</span> NativeProcess();
    <span class="keyword">var</span> nativeProcessInfo:NativeProcessStartupInfo = <span class="keyword">new</span> NativeProcessStartupInfo();
    <span class="keyword">var</span> args:Vector.&lt;String&gt; = <span class="keyword">new</span> Vector.&lt;String&gt;();
    <span class="keyword">if</span>(Capabilities.os.indexOf(<span class="string">"Mac OS"</span>)&gt;=<span class="number">0</span>)
    {
        nativeProcessInfo.executable = <span class="keyword">new</span> File(<span class="string">"/usr/bin/osascript"</span>);
        args.push(elevateFolder.resolvePath(<span class="string">"elevate.scpt"</span>).nativePath);
        args.push(exePath);
    }
    <span class="keyword">else</span>
    {
        <span class="keyword">if</span>(Capabilities.os.indexOf(<span class="string">"XP"</span>)&lt;<span class="number">0</span>)
        {
            <span class="comment">//非xp系统直接调用elevate申请权限</span>
            nativeProcessInfo.executable = elevateFolder.resolvePath(<span class="string">"elevate.exe"</span>);
            args.push(exePath);
        }
        <span class="keyword">else</span>
        {
            <span class="comment">//xp系统下没有UAC，直接运行目标程序即可</span>
            nativeProcessInfo.executable = <span class="keyword">new</span> File(exePath);
        }
    }
    <span class="keyword">if</span>(exeArgs)
        args = args.concat(exeArgs);
    nativeProcessInfo.arguments = args;
    nativeProcess.start(nativeProcessInfo);
}
</code></pre><p>如果觉得这种传参调用不好用，可以改一下。在目标程序启动后，可以实现A程序与B程序的进程通讯。A向B程序相互发消息就更加灵活了。我们的方案是把B程序也做成一个AIR应用，这样就可以使用LocalConnection实现两个AIR程序的通讯了。</p>
<p>elevate的下载地址,有兴趣的可以hack下:</p>
<p>Windows：<a href="http://xzper.qiniudn.com/2015/01/elevate.zip" target="_blank" rel="external">elevate.exe</a></p>
<p>Mac：<a href="http://xzper.qiniudn.com/2015/01/elevate.scpt" target="_blank" rel="external">elevate.scpt</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>AIR中有些API在没有权限的情况下是不生效的，甚至不报错也没没有任何提示。例如文件系统中对敏感目录的文件操作，File.applicationDirectory这个API的文档是这样说的</p>
<blockquote>
<p>出于安全原因，不推荐修改应用程序目录中的内容，有些平台上的操作系统会阻止此操作。<br>如果要存储特定于应用程序的数据，请考虑使用应用程序存储目录 (File.applicationStorageDirectory)。</p>
</blockquote>
<p>可以看到File.applicationDirectory这个目录是无法保证有权限写入的。这篇文章讲解如何在Windows和Mac下突破这一限制，能获取系统中任何目录的操作权限。</p>
]]>
    
    </summary>
    
      <category term="ActionScript3" scheme="http://xzper.com/categories/ActionScript3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AIR中一些隐藏特性]]></title>
    <link href="http://xzper.com/2015/01/17/AIR%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%9A%90%E8%97%8F%E7%89%B9%E6%80%A7/"/>
    <id>http://xzper.com/2015/01/17/AIR中一些隐藏特性/</id>
    <published>2015-01-17T13:52:01.000Z</published>
    <updated>2015-01-19T03:05:24.993Z</updated>
    <content type="html"><![CDATA[<p>分享一下在使用AIR开发跨平台应用的几个坑。在此之前不得不说，stackoverflow这个网站帮了我很多。每次遇到一些棘手的技术问题寻找答案未果的情况下，stackoverflow总能找到令人满意的答案。这里分享两个我遇到的一些问题。</p>
<a id="more"></a>
<p><strong>1.打印异常堆栈信息</strong></p>
<p>当产品发布时，没人能保证程序百分之百稳定运行。难免会有一些bug，而用户遇到了bug需要反馈的时候，报错的堆栈信息如果能够得到保留能省很多事。所幸AIR有这样的API能输出堆栈信息。看下面这段代码。</p>
<pre><code>loaderInfo.uncaughtErrorEvents.addEventListener(UncaughtErrorEvent.UNCAUGHT_ERROR,errorHandle);

<span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">errorHandle</span><span class="params">(event:UncaughtErrorEvent)</span><span class="type">:void</span>
</span>{
    <span class="keyword">var</span> message:String; 
    <span class="keyword">if</span> (event.error <span class="keyword">is</span> Error) { 
        message = Error(event.error).message; 
        message+=<span class="string">"\n"</span>+Error(event.error).getStackTrace();
    } <span class="keyword">else</span> <span class="keyword">if</span> (event.error <span class="keyword">is</span> ErrorEvent) { 
        message = ErrorEvent(event.error).text;
    } <span class="keyword">else</span> { 
        message = event.error.toString(); 
    } 
}
</code></pre><p>当时这样做每次得到的结果却是这样的</p>
<pre><code><span class="preprocessor">at</span> xxx/uncaughtErrorHandler()
</code></pre><p>堆栈显示不全，但这不是我们想要的结果。解决办法就是将下面这一行</p>
<pre><code>message+=<span class="string">"\n"</span>+<span class="keyword">Error</span>(<span class="keyword">event</span>.<span class="keyword">error</span>).getStackTrace();
</code></pre><p>改为</p>
<pre><code>message+=<span class="string">"\n"</span>+<span class="keyword">event</span>.<span class="keyword">error</span>.getStackTrace();
</code></pre><p>去掉强制转换就行了。</p>
<hr>
<p><strong>2.重启AIR程序</strong></p>
<p>重启AIR程序，这个问题似乎很好解决，百度或者Google之，发现几乎所有的相关文章都介绍了使用ProductManager的相关api实现。具体的实现参考<a href="http://blog.domlib.com/articles/577.html" target="_blank" rel="external">http://blog.domlib.com/articles/577.html</a></p>
<p>可是这个方法有时并不管用。</p>
<p>比如嵌入运行时的本地AIR程序，这种程序需要在应用程序描述文件里面配置</p>
<pre><code><span class="tag">&lt;<span class="title">supportedProfiles</span>&gt;</span>extendedDesktop<span class="tag">&lt;/<span class="title">supportedProfiles</span>&gt;</span>
</code></pre><p>打包好的程序在Windows下面是一个exe程序，mac下是一个app文件夹。这种程序的重启似乎有点麻烦，不过下面的代码确实能使程序重启。</p>
<pre><code>var id:<span class="typename">String</span> = NativeApplication.nativeApplication.applicationID;
var info:NativeProcessStartupInfo = <span class="keyword">new</span> NativeProcessStartupInfo();
<span class="keyword">if</span>(Capabilities.os.indexOf(<span class="string">"Mac OS"</span>)&gt;=<span class="number">0</span>)
    info.executable = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="keyword">File</span>.applicationDirectory.nativePath).parent.resolvePath(<span class="string">"MacOS/"</span>+id);
<span class="keyword">else</span>
    info.executable = <span class="keyword">File</span>.applicationDirectory.resolvePath(id+<span class="string">".exe"</span>);
var <span class="keyword">process</span>:NativeProcess = <span class="keyword">new</span> NativeProcess();
<span class="keyword">process</span>.start(info);
NativeApplication.nativeApplication.<span class="keyword">exit</span>();
</code></pre><p>没错，先打开程序，然后立马执行退出就是重启。不过这种方式之所以生效还是有一定道理的，NativeProcess是系统级的东西，系统执行的时候有一定延迟，而exit是立马就生效的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>分享一下在使用AIR开发跨平台应用的几个坑。在此之前不得不说，stackoverflow这个网站帮了我很多。每次遇到一些棘手的技术问题寻找答案未果的情况下，stackoverflow总能找到令人满意的答案。这里分享两个我遇到的一些问题。</p>
]]>
    
    </summary>
    
      <category term="ActionScript3" scheme="http://xzper.com/categories/ActionScript3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Flex框架中样式的实现原理与AS3中的原型链继承]]></title>
    <link href="http://xzper.com/2014/10/25/Flex%E6%A1%86%E6%9E%B6%E4%B8%AD%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8EAS3%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/"/>
    <id>http://xzper.com/2014/10/25/Flex框架中样式的实现原理与AS3中的原型链继承/</id>
    <published>2014-10-25T05:53:06.000Z</published>
    <updated>2014-11-17T09:07:10.553Z</updated>
    <content type="html"><![CDATA[<p>在Flex中setStyle这个特性特别好用，当一个容器Group的样式时，那么这个容器的子项的样式也会跟着起作用。比如设置Application的<code>fontSize</code>这个样式为20，那么如果不显式设置子项的<code>fontSize</code>，子项的字体大小就都会是20，而不用每次子项再去重复设置了，这个特性对于开发者来讲是至关重要的，能减少很多重复的代码。而这个特性的实现，离不开原型链继承这个重要概念。</p>
<a id="more"></a>
<p>原型链继承这个词已经不是陌生词汇了，对于JS程序员来说更是再熟悉不过了。AS3作为一个面向对象的脚本语言，原型链继承早已淡出AS3程序员的视野。说到AS语言，其实AS1，AS2都很像JS，AS3则来了个180°转变，变成了面向对象了。早在AS1，AS2的时代，对象间的继承就是使用原型链继承的方式实现的，事实上这一特性也得到了保留，AS3也可以使用这种方式实现继承。</p>
<hr>
<p>下面我们来看一个神奇的DEMO来体会原型链继承。先上代码</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">styleTest</span><span class="params">()</span><span class="type">:void</span>
</span>{
    <span class="keyword">var</span> parentStyle:Object = 
        {
            <span class="string">"fontSize"</span>:<span class="number">12</span> , 
            <span class="string">"fontColor"</span>:<span class="number">0xffffff</span> , 
            <span class="string">"fontFamily"</span>:<span class="string">"微软雅黑"</span>
        };

    <span class="keyword">var</span> childStyle:Object = addStyleToProtoChain(parentStyle);
    childStyle[<span class="string">"fontSize"</span>] = <span class="number">20</span>;
    childStyle[<span class="string">"fontWeight"</span>] = <span class="string">"bold"</span>;

    parentStyle[<span class="string">"fontSize"</span>] = <span class="number">18</span>;
    parentStyle[<span class="string">"fontFamily"</span>] = <span class="string">"宋体"</span>;

    <span class="keyword">trace</span>(<span class="string">"-----以下为parent的样式信息-----"</span>);
    traceObject(parentStyle);

    <span class="keyword">trace</span>(<span class="string">"-----以下为child的样式信息-----"</span>);
    traceObject(childStyle);
}

<span class="comment">/**
 * 将样式信息添加到原型链
 * @param originalStyle 原始样式 
 * @return 原始样式的子样式
 */</span>
<span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">addStyleToProtoChain</span><span class="params">(originalStyle:Object)</span><span class="type">:Object</span>
</span>{
    <span class="keyword">var</span> inheritStyle:Object;
    <span class="keyword">var</span> factory:Function = <span class="function"><span class="keyword">function</span><span class="params">()</span><span class="type">:void</span></span>{};
    factory.prototype = originalStyle;
    inheritStyle = <span class="keyword">new</span> factory();
    factory.prototype = <span class="literal">null</span>;
    <span class="keyword">return</span> inheritStyle;
}

<span class="comment">/**
 * 打印排序后的对象的属性
 */</span>
<span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">traceObject</span><span class="params">(obj:Object)</span><span class="type">:void</span>
</span>{
    <span class="keyword">var</span> keys:Array = [];
    <span class="keyword">var</span> valueMap:Object = {};

    <span class="keyword">for</span>(<span class="keyword">var</span> key:String <span class="keyword">in</span> obj)
    {
        <span class="keyword">if</span>(keys.indexOf(key)&gt;=<span class="number">0</span>)
            <span class="keyword">continue</span>;
        keys.push(key);
        valueMap[key] = obj[key];
    }
    keys.sort();
    <span class="keyword">for</span> each (key <span class="keyword">in</span> keys)
    {
        <span class="keyword">trace</span>(key+<span class="string">":"</span>+valueMap[key]);
    }
}
</code></pre><p>程序定义了两个对象<code>parentStyle</code>和<code>childStyle</code>来存储一些样式属性。通过<code>addStyleToProtoChain</code>将<code>parentStyle</code>加入到<code>childStyle</code>原型链中，然后不断改变这两个对象的属性，最后输出两个对象的结果。在答案揭晓之前我们先来分析一下每个属性的设置过程。</p>
<h4 id="fontSize"><code>fontSize</code></h4>
<p><code>fontSize</code>这个属性在<code>parentStyle</code>初始化时为12，后来在<code>childStyle</code>中设置为20，最后<code>parentStyle</code>中又重新设置为18。 那么最后childStyle的<code>fontSize</code>是多少呢?是12，还是20，还是18?</p>
<h4 id="fontColor"><code>fontColor</code></h4>
<p><code>fontColor</code>只有在<code>parentStyle</code>初始化时设置了一次为<code>0xffffff</code>,并没有在<code>childStyle</code>中设置，那么最终<code>childStyle</code>中会有这个属性吗?</p>
<h4 id="fontFamily"><code>fontFamily</code></h4>
<p><code>fontFamily</code>被设置两次，初始化时为<code>微软雅黑</code>，后来设置成了<code>宋体</code>，都在<code>parentStyle</code>的属性中设置的。同样那么最终<code>childStyle</code>会有这个属性吗，有的话值是多少呢?是<code>微软雅黑</code>还是<code>宋体</code>?</p>
<h4 id="fontWeight"><code>fontWeight</code></h4>
<p><code>fontWeight</code>这个属性只在<code>childStyle</code>进行了设置，那么最终<code>parentStyle</code>会有这个属性吗?</p>
<hr>
<p>那么答案揭晓，控制台输出如下：</p>
<pre><code>-----以下为parent的样式信息-----
<span class="label">fontColor:</span><span class="number">16777215</span>
<span class="label">fontFamily:</span>宋体
<span class="label">fontSize:</span><span class="number">18</span>
-----以下为child的样式信息-----
<span class="label">fontColor:</span><span class="number">16777215</span>
<span class="label">fontFamily:</span>宋体
<span class="label">fontSize:</span><span class="number">20</span>
<span class="label">fontWeight:</span>bold
</code></pre><p>结果是否出人意料?</p>
<p>其实最终的结果可以可以归纳为child的改变不会影响parent的属性，而parent的属性改变<strong>可能</strong>会影响到child的属性。这个可能分两种情况，一种情况是child没有这个属性，parent改变了child就会跟着改变，再一种就是child有这个属性parent改变了不会影响child。</p>
<p>为什么<code>fontColor</code>，<code>fontFamily</code>这类的在<code>parentStyle</code>中定义，会在<code>childStyle</code>中出现呢，因为<code>childStyle</code>的原型链是<code>parentStyle</code>，当在自身找不到这个属性时，就会从原型链里面找，直到找到为止。</p>
<hr>
<p>我们再来看一下是如何将<code>parentStyle</code>设置成<code>childStyle</code>的原型链的。将<code>addStyleToProtoChain</code>执行的操作翻译过来就是下面这样</p>
<pre><code><span class="keyword">var</span> factory:Function = <span class="function"><span class="keyword">function</span><span class="params">()</span><span class="type">:void</span></span>{};
factory.prototype = parentStyle;
childStyle = <span class="keyword">new</span> factory();
factory.prototype = <span class="literal">null</span>;
</code></pre><hr>
<p>这种原型链的描述方式完全符合Flex样式的设计思想。Flex的每个组件都持有两套样式表，可继承的样式和不可继承的样式。不可继承的样式不做传递，可继承的样式会添加到原型链中。当一个容器的子组件被添加的时候，子组件的样式表会被重新初始化，将父级的样式表添加到自己的原型链，然后添加自己的样式。最终自己的样式改变不会影响父级，父级的样式改变，如果自己没有显式定义就会跟随父级改变。关于Flex样式的原理详细的可以看下面的参考文章。</p>
<p>本文代码下载: <a href="http://xzper.qiniudn.com/2014%2F10%2FStyleTest.zip" target="_blank" rel="external">Click Me</a></p>
<p>参考文章：</p>
<p>[1] <a href="http://blog.csdn.net/terryzero/article/details/4581459" target="_blank" rel="external">Flex样式工作原理</a></p>
<p>[2] <a href="http://blog.csdn.net/holybozo/article/details/1345606" target="_blank" rel="external">AS3 面向对象 高级话题</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Flex中setStyle这个特性特别好用，当一个容器Group的样式时，那么这个容器的子项的样式也会跟着起作用。比如设置Application的<code>fontSize</code>这个样式为20，那么如果不显式设置子项的<code>fontSize</code>，子项的字体大小就都会是20，而不用每次子项再去重复设置了，这个特性对于开发者来讲是至关重要的，能减少很多重复的代码。而这个特性的实现，离不开原型链继承这个重要概念。</p>
]]>
    
    </summary>
    
      <category term="ActionScript3" scheme="http://xzper.com/categories/ActionScript3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分享一个小巧的快捷键管理工具类]]></title>
    <link href="http://xzper.com/2014/09/04/%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://xzper.com/2014/09/04/快捷键管理/</id>
    <published>2014-09-04T13:58:03.000Z</published>
    <updated>2014-10-23T05:22:47.955Z</updated>
    <content type="html"><![CDATA[<p>最近要完成软件中的快捷键模块。基本需求就是能做到让用户自由设置。基本之前的所有按键都是写死在代码中的，就像下面这样糟糕：</p>
<pre><code><span class="keyword">this</span>.addEventListener(KeyboardEvent.KEY_DOWN,onKeyDown);

<span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onKeyDown</span><span class="params">(event:KeyboardEvent)</span><span class="type">:void</span>
</span>{
    <span class="keyword">if</span>(event.keyCode==Keyboard.S&amp;&amp;event.ctrlKey)
    {
        ...dosomething
    }
}
</code></pre><a id="more"></a>
<p>这样写是无法做到在后期维护中把快捷键分离出来让用户自由设置的。而且会造成代码冗余，比如这个面板需要Ctrl+S执行保存操作，那个面板也需要Ctrl+S执行那个面板的保存操作。这样Ctrl+S这种组合的快捷键每个面板都需要判断一下，这样相同的逻辑判断会多次出现。还有一种比较严格的情况，比如上面的那种判断严格意义上来讲是不能判断Ctrl+S的，因为用户可能同时也按下了Shift键或者Alt键，那这样这个判断要完全写对，代码量又要多不少。</p>
<p>比较好的解决方式是使用一个快捷键管理类Shortcut，统一管理这些操作。在程序初始化的时候注入快捷键的映射，然后在各个面板注册需要响应的事件类型以及对应的函数。比如一个Ctrl+S的操作可以这样表示：</p>
<p>程序初始化的时候，添加快捷键映射</p>
<pre><code>Shortcut.addBinding(<span class="string">"save"</span> , [Keyboard.S , Keyboard.CONTROL]);
</code></pre><p>具体的面板注册监听事件</p>
<pre><code>Shortcut.addRegister(<span class="keyword">this</span> , “save” , onShortcut);
</code></pre><p><code>addBinding</code>这个方法第一个参数就是事件类型，第二个类型就是事件对应的按键，用一个数组表示，可以是多个具体的解析交由Shortcut实现。</p>
<p><code>addRegister</code>这个方法第一个参数就是要监听这个事件的对象，第二个参数是监听的类型，第三个参数是对应的回调函数。当然只有满足了按键条件才会触发这个回调函数。</p>
<p>这样具体的按键事件监听，按键逻辑都交由Shortcut这个管理类去实现。要响应事件的对象不再需要去写繁琐的事件监听与逻辑判断了。这个面板只关心save这个事件，而不关心按了什么键，这样解耦了按键事件与面板的关系。用户如果需要改变快捷键，只需要改变那个binding的映射表就行了，具体的面板不需要任何改变。</p>
<p>当然基于以上两个方法我们可以继续添加扩展，比如批量初始化快捷键映射</p>
<pre><code>Shortcut.addBindindBatch(config);
</code></pre><p>这种方式可以用于初始化的时候或者用户修改了快捷键的时候，传入一个映射表配置就行了。</p>
<p>事件的类型也可以从简单的字符串变为一个静态常量，比如可以定义一个ShortcutType类存放这些事件：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortcutType</span>
</span>{
    <span class="javadoc">/**
     * 保存
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">const</span> SAVE:String = <span class="string">"save"</span>;
}
</code></pre><p>基本上API就是这样，使用很简单，也很灵活。然后是重点<code>No Code You Say A Diao</code></p>
<pre><code><span class="package"><span class="keyword">package</span>
{</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.display.InteractiveObject;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.display.Stage;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.events.Event;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.events.FocusEvent;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.events.KeyboardEvent;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.ui.Keyboard;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.utils.Dictionary;</span>

    <span class="comment">/**
     * 快捷键管理类， 执行initialize初始化一个全局管理。
     * &lt;br&gt;使用 addBinding 添加一个事件类型 与 按键的绑定
     * &lt;br&gt;使用 addRegister 注册一个监听对象
     * &lt;br&gt;下面是一个简单的使用例子
     * &lt;code&gt;
     *    &lt;br&gt;Shortcut.addBinding("example" , [Keyboard.S , Keyboard.CONTROL]);
     *    &lt;br&gt;Shortcut.addRegister(this , "example" , onSave);
     * &lt;/code&gt;
     */</span>
    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shortcut</span>
    </span>{
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Shortcut</span><span class="params">(stage:Stage)</span>
        </span>{
            stage.addEventListener(KeyboardEvent.KEY_DOWN,onStageKeyDown,<span class="literal">true</span>,<span class="number">2000</span>);
            stage.addEventListener(KeyboardEvent.KEY_UP,onStageKeyUp,<span class="literal">true</span>,<span class="number">2000</span>);
            stage.addEventListener(FocusEvent.FOCUS_OUT,onDeactive);
        }

        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> instance:Shortcut;
        <span class="comment">/**
         * 初始化
         */</span>        
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">initialize</span><span class="params">(stage:Stage)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">if</span>(instance)
                <span class="keyword">return</span>;
            instance = <span class="keyword">new</span> Shortcut(stage);
        }

        <span class="comment">/**
         * @copy  Shortcut#addRegister()
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">addRegister</span><span class="params">(target:InteractiveObject , type:String , callBack:Function)</span><span class="type">:void</span>
        </span>{
            instance.addRegister(target , type , callBack);
        }

        <span class="comment">/**
         * @copy  Shortcut#removeRegister()
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">removeRegister</span><span class="params">(target:InteractiveObject , type:String , callBack:Function)</span><span class="type">:void</span>
        </span>{
            instance.removeRegister(target , type , callBack);
        }

        <span class="comment">/**
         * 移除一个对象所有注册的快捷键
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">removeTargetRegister</span><span class="params">(target:InteractiveObject)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">if</span>(instance.targetDic[target])
            {
                <span class="keyword">var</span> shortcutMapList:Array = instance.targetDic[target];
                <span class="keyword">for</span> <span class="keyword">each</span> (<span class="keyword">var</span> shortcutMap:ShortcutMap <span class="keyword">in</span> shortcutMapList) 
                {
                    instance.removeRegister(target , shortcutMap.type , shortcutMap.callBack);
                }
            }
        }

        <span class="comment">/**
         * @copy  Shortcut#addBinding()
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">addBinding</span><span class="params">(type:String , keyCodeValue:Array)</span><span class="type">:void</span>
        </span>{
            instance.addBinding(type , keyCodeValue);
        }

        <span class="comment">/**
         * 批量添加绑定事件类型 与 按键值的映射
         * @param data 数据中的每一项格式参照addBinding方法中的参数
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">addBindindBatch</span><span class="params">(data:Object)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">for</span> (<span class="keyword">var</span> key:String <span class="keyword">in</span> data) 
            {
                instance.addBinding(key , data[key]);
            }
        }

        <span class="comment">/**
         * @copy  Shortcut#removeBinding()
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">removeBinding</span><span class="params">(type:String)</span><span class="type">:void</span>
        </span>{
            instance.removeBinding(type);
        }

        <span class="comment">/**
         * 移除所有的事件类型
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">removeAllBinding</span><span class="params">()</span><span class="type">:void</span>
        </span>{
            instance.bindingDic = <span class="keyword">new</span> Dictionary();
        }

        <span class="comment">/**
         * 判断指定键是否按下
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">isKeyDown</span><span class="params">(keyCode:uint)</span><span class="type">:Boolean</span>
        </span>{
            <span class="keyword">return</span> instance.isKeyDown(keyCode);
        }


        <span class="comment">//======================== 快捷键相关=====================start=======================</span>

        <span class="comment">/**
         * 监听快捷键的对象 与 持有的注册列表字典
         */</span>
        <span class="keyword">private</span> <span class="keyword">var</span> targetDic:Dictionary = <span class="keyword">new</span> Dictionary(<span class="literal">true</span>);

        <span class="comment">/**
         * 事件类型 与 具体按键值的关系映射表
         */</span>
        <span class="keyword">private</span> <span class="keyword">var</span> bindingDic:Dictionary = <span class="keyword">new</span> Dictionary();

        <span class="comment">/**
         * 注册一个监听对象
         * @param target 监听事件的目标对象
         * @param type 按键要触发的事件类型
         * @param callBack 回调函数示例：不含参数 callBack():void
         * 带一个参数callBack(type:String):void , 带两个参数callBack(type:String , event:KeyboardEvent):void
         */</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addRegister</span><span class="params">(target:InteractiveObject , type:String , callBack:Function)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">if</span>(getRegisterIndex(target , type , callBack) &gt;= <span class="number">0</span>)
            {
                <span class="keyword">return</span>;
            }
            <span class="keyword">if</span>(targetDic[target] === <span class="literal">undefined</span>)
            {
                targetDic[target] = [];
                target.addEventListener(KeyboardEvent.KEY_DOWN , onKeyDown , <span class="literal">false</span> ,<span class="number">0</span> , <span class="literal">true</span>);
            }
            <span class="keyword">var</span> map:ShortcutMap = <span class="keyword">new</span> ShortcutMap();
            map.type = type;
            map.callBack = callBack; 
            targetDic[target].push(map);
        }

        <span class="comment">/**
         * 移除一个监听对象
         * @param target 监听事件的目标对象
         * @param type 按键要触发的事件类型
         * @param callBack 回调函数
         */</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">removeRegister</span><span class="params">(target:InteractiveObject , type:String , callBack:Function)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">var</span> registerIndex:int = getRegisterIndex(target , type , callBack);
            <span class="keyword">if</span>(registerIndex &gt;= <span class="number">0</span>)
            {
                <span class="keyword">var</span> shortcutMapList:Array = targetDic[target];
                shortcutMapList.splice(registerIndex , <span class="number">1</span>);
                <span class="keyword">if</span>(shortcutMapList.length == <span class="number">0</span>)
                {
                    target.removeEventListener(KeyboardEvent.KEY_DOWN , onKeyDown);
                    <span class="keyword">delete</span> targetDic[target];
                }
            }
        }

        <span class="comment">/**
         * 测试是否注册了指定类型的指定方法，并返回注册的索引
         */</span>
        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">getRegisterIndex</span><span class="params">(target:InteractiveObject , type:String , callBack:Function)</span><span class="type">:int</span>
        </span>{
            <span class="keyword">if</span>(targetDic[target])
            {
                <span class="keyword">var</span> shortcutMapList:Array = targetDic[target];
                <span class="keyword">var</span> shortcutMap:ShortcutMap;
                <span class="keyword">for</span> (<span class="keyword">var</span> i:int = <span class="number">0</span>; i &lt; shortcutMapList.length; i++) 
                {
                    shortcutMap = shortcutMapList[i] <span class="keyword">as</span> ShortcutMap;
                    <span class="keyword">if</span>(shortcutMap.type == type &amp;&amp; shortcutMap.callBack == callBack)
                    {
                        <span class="keyword">return</span> i;
                    }
                }
            }
            <span class="keyword">return</span> -<span class="number">1</span>;
        }

        <span class="comment">/**
         * 绑定一个事件类型 与 按键值的映射
         * @param type  事件类型
         * @param keyCodeValue 按下的键的对象， 可以是一个数组也可以每一项是一个数组，数组中的元素对应Keyboard中的常量
         *     &lt;br/&gt;如果数组的长度等于1，则 按照对应的键值触发事件
         * &lt;br/&gt;如果数组的长度大于1，则 按照数组中的第一项对应的键值触发事件，其他的键为触发事件需要按下的键
         * &lt;br/&gt;下面是一些例子
         * &lt;code&gt;
         *    &lt;br&gt;[Keyboard.S , Keyboard.CONTROL] 表示 Ctrl+S
         *    &lt;br&gt;[[Keyboard.BACKSPACE] , [Keyboard.DELETE]] 表示退格或者删除
         * &lt;/code&gt;
         */</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addBinding</span><span class="params">(type:String , keyCodeValue:Array)</span><span class="type">:void</span>
        </span>{
            bindingDic[type] = keyCodeValue;
        }

        <span class="comment">/**
         * 移除一个事件类型
         */</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">removeBinding</span><span class="params">(type:String)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">if</span>(bindingDic[type])
            {
                <span class="keyword">delete</span> bindingDic[type];
            }
        }

        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onKeyDown</span><span class="params">(event:KeyboardEvent)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">var</span> shortcutMapList:Array = targetDic[event.currentTarget];
            <span class="keyword">if</span>(!shortcutMapList || shortcutMapList.length &lt; <span class="number">1</span>)
                <span class="keyword">return</span>;

            <span class="keyword">var</span> shortcutMap:ShortcutMap;
            <span class="keyword">for</span> (<span class="keyword">var</span> i:int = <span class="number">0</span>; i &lt; shortcutMapList.length; i++) 
            {
                shortcutMap = shortcutMapList[i] <span class="keyword">as</span> ShortcutMap;
                <span class="keyword">var</span> keyCodeValue:Array = bindingDic[shortcutMap.type];
                <span class="keyword">var</span> result:Boolean = <span class="literal">false</span>;
                <span class="keyword">if</span>(keyCodeValue[<span class="number">0</span>] <span class="keyword">is</span> Array)
                {
                    <span class="keyword">for</span> <span class="keyword">each</span> (<span class="keyword">var</span> keyCodeArray:* <span class="keyword">in</span> keyCodeValue) 
                    {
                        <span class="keyword">if</span>(keyCodeArray <span class="keyword">is</span> uint)
                            result = check(event , [keyCodeArray]);
                        <span class="keyword">else</span>
                            result = check(event , keyCodeArray);
                        <span class="keyword">if</span>(result)
                            <span class="keyword">break</span>;
                    }
                }
                <span class="keyword">else</span>
                {
                    result = check(event , keyCodeValue);
                }
                <span class="keyword">if</span>(result)
                {
                    <span class="keyword">if</span>(shortcutMap.callBack.length == <span class="number">0</span>)
                        shortcutMap.callBack();
                    <span class="keyword">else</span> <span class="keyword">if</span>(shortcutMap.callBack.length == <span class="number">1</span>)
                        shortcutMap.callBack(shortcutMap.type);
                    <span class="keyword">else</span> <span class="keyword">if</span>(shortcutMap.callBack.length == <span class="number">2</span>)
                        shortcutMap.callBack(shortcutMap.type , event);
                    <span class="keyword">else</span>
                        shortcutMap.callBack();
                }
            }
        }

        <span class="comment">/**
         * 检查事件是否符合指定按键
         */</span>
        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">check</span><span class="params">(event:KeyboardEvent , keyCodeArray:Array)</span><span class="type">:Boolean</span>
        </span>{
            <span class="keyword">if</span>(!keyCodeArray || keyCodeArray.length &lt; <span class="number">0</span>)
                <span class="keyword">return</span> <span class="literal">false</span>;
            <span class="keyword">if</span>(event.keyCode == keyCodeArray[<span class="number">0</span>])
            {
                <span class="keyword">if</span>(keyCodeArray.length == <span class="number">1</span>)
                {
                    <span class="keyword">return</span> <span class="literal">true</span>;
                }
                <span class="keyword">else</span>
                {
                    <span class="keyword">var</span> firstKey:uint = keyCodeArray[<span class="number">0</span>];
                    <span class="keyword">var</span> hopeKeys:Array = keyCodeArray.concat();
                    <span class="keyword">var</span> allDownkeyCodes:Array = compositeKeys(event);
                    <span class="keyword">if</span>(allDownkeyCodes.indexOf(firstKey)&lt;<span class="number">0</span>)
                        allDownkeyCodes.push(firstKey);

                    <span class="keyword">if</span>(hopeKeys.length != allDownkeyCodes.length)
                        <span class="keyword">return</span> <span class="literal">false</span>;

                    hopeKeys.sort();
                    allDownkeyCodes.sort();

                    <span class="keyword">for</span> (<span class="keyword">var</span> i:int = <span class="number">0</span>; i &lt; hopeKeys.length; i++) 
                    {
                        <span class="keyword">if</span>(hopeKeys[i] != allDownkeyCodes[i])
                        {
                            <span class="keyword">return</span> <span class="literal">false</span>;
                        }
                    }
                    <span class="keyword">return</span> <span class="literal">true</span>;
                }
            }
            <span class="keyword">return</span> <span class="literal">false</span>;
        }

        <span class="comment">/**
         * 获取按下的组合键
         */</span>
        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">compositeKeys</span><span class="params">(event:KeyboardEvent)</span><span class="type">:Array</span>
        </span>{
            <span class="keyword">var</span> keys:Array = [];
            <span class="keyword">if</span>(event.altKey)
                keys.push(Keyboard.ALTERNATE);
            <span class="keyword">if</span>(event.shiftKey)
                keys.push(Keyboard.SHIFT);
            <span class="keyword">if</span>(event.controlKey)
                keys.push(Keyboard.CONTROL);
            <span class="keyword">if</span>(event.commandKey)
                keys.push(Keyboard.COMMAND);
            <span class="keyword">return</span> keys;
        }

        <span class="comment">//======================== 快捷键相关=====================end=======================</span>

        <span class="comment">//======================== 全局舞台按键 =====================start=======================</span>

        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onDeactive</span><span class="params">(event:Event)</span><span class="type">:void</span>
        </span>{
            downKeyCodes = <span class="keyword">new</span> Dictionary();
        }
        <span class="comment">/**
         * 按下的键代码列表
         */</span>        
        <span class="keyword">private</span> <span class="keyword">var</span> downKeyCodes:Dictionary = <span class="keyword">new</span> Dictionary();

        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onStageKeyDown</span><span class="params">(event:KeyboardEvent)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">var</span> keyCode:uint = event.keyCode;
            downKeyCodes[keyCode] = <span class="literal">true</span>;
        }

        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onStageKeyUp</span><span class="params">(event:KeyboardEvent)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">var</span> keyCode:uint = event.keyCode;
            <span class="keyword">if</span>(downKeyCodes[keyCode])
                <span class="keyword">delete</span> downKeyCodes[keyCode];
        }

        <span class="comment">/**
         * 是否按下了指定键
         */</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isKeyDown</span><span class="params">(keyCode:uint)</span><span class="type">:Boolean</span>
        </span>{
            <span class="keyword">return</span> Boolean(downKeyCodes[keyCode]);
        }

        <span class="comment">//======================== 全局舞台按键 =====================end=======================</span>

    }
}

<span class="class"><span class="keyword">class</span> <span class="title">ShortcutMap</span>
</span>{
    <span class="comment">/**
     * 事件类型
     */</span>
    <span class="keyword">public</span> <span class="keyword">var</span> type:String;

    <span class="comment">/**
     * 回调函数
     */</span>
    <span class="keyword">public</span> <span class="keyword">var</span> callBack:Function;
}
</code></pre><p>基本上代码已经说明一切了。主要思路就是给注册的对象监听一个KeyDown事件，在事件内部判断有哪些键按下了，是否符合这个对象某一个注册了的事件对应的按键映射，如果有就执行回调。</p>
<p>有一个关键点，给对象监听的按键事件<code>useWeakReference = true</code> 以及 <code>targetDic</code>也是使用了弱引用。只有这样我们无须手动调用<code>removeRegister</code>，当对象的引用计数为0时，就会被垃圾回收器GC自动回收了，不用担心内存泄露。</p>
<p>另外，这个工具类一开始需要传入一个舞台对象<code>stage</code>进行初始化，这个主要是用于保存一个全局有那些键是被按下了，就是后面那一段代码。这一段可有可无，主要是提供一个公共方法外界可以获取哪些键按下了。</p>
<p>基本上这个Shortcut已经能够满足大多数需求了。之前看过几个快捷键管理的工具类都是直接监听舞台上的事件，这个是有问题的。因为有些情况下，快捷键是针对指定面板的，当焦点不在面板上时快捷键是不起作用的，所以<code>removeRegister</code>这个方法的第一个参数就是设置快捷键应用的对象。<br>这个也能实现同一个事件可以注册给不同的对象，也可以一个对象注册同一个事件但是有不同的回调。就是说同一个快捷键可以给不同面板，同一个面板同一个快捷键也可以响应多个回调。</p>
<p>另外还支持一个事件多种快捷键，比如一个type为delete的事件，可以这样定义</p>
<pre><code>Shortcut.binding(<span class="string">"delete"</span> , <span class="string">[[Keyboard.BACKSPACE] , [Keyboard.DELETE]]</span>)
</code></pre><p>使用一个二维数组，每一个数组表示一组快捷键。delete事件既可以是退格键也可以是删除键。</p>
<p>再一个就是快捷键冲突的问题，同一个快捷键可以派发不同的事件。这种设计也是允许冲突的，因为有可能事件的对象不同，比如面板1里面Ctrl+S是保存，面板2里面Ctrl+S是删除一行，也就不冲突了。</p>
<p>差不多就这些啦。这个类可以拿来直接用，没有和其他的类耦合，也不需要定义接口啥的。另外，这些东西真的要到项目前期规划好，不然到了后面想改都蛋疼。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近要完成软件中的快捷键模块。基本需求就是能做到让用户自由设置。基本之前的所有按键都是写死在代码中的，就像下面这样糟糕：</p>
<pre><code><span class="keyword">this</span>.addEventListener(KeyboardEvent.KEY_DOWN,onKeyDown);

<span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onKeyDown</span><span class="params">(event:KeyboardEvent)</span><span class="type">:void</span>
</span>{
    <span class="keyword">if</span>(event.keyCode==Keyboard.S&amp;&amp;event.ctrlKey)
    {
        ...dosomething
    }
}
</code></pre>]]>
    
    </summary>
    
      <category term="ActionScript3" scheme="http://xzper.com/categories/ActionScript3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析Hexo的Generate命令]]></title>
    <link href="http://xzper.com/2014/08/17/%E6%B5%85%E6%9E%90Hexo%E7%9A%84Generate%E5%91%BD%E4%BB%A4/"/>
    <id>http://xzper.com/2014/08/17/浅析Hexo的Generate命令/</id>
    <published>2014-08-16T22:54:10.000Z</published>
    <updated>2014-10-23T05:22:47.975Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/hexojs/hexo" target="_blank" rel="external">Hexo</a>是一个轻量级的静态博客站点生成框架，使用NodeJS开发。经过我两个通宵的努力总算把这个东西研究了一个大概，这里拿来分享一下。</p>
<a id="more"></a>
<h2 id="Processor">Processor</h2>
<p><a href="http://hexo.io/docs/plugins.html#Processor" target="_blank" rel="external">Processor</a>决定文件按照何种方式处理。在lib/plugins/processor文件夹下可以看到默认的处理方式。Processor在该模块的index.js中注册，默认的有下面几种</p>
<ol>
<li><strong>post</strong> 当文件是可渲染的，并且在_posts文件夹下的处理方式</li>
<li><strong>post_assets</strong> 当文件是不可渲染的，并且配置文件中的”post_asset_folder”属性存在，并且在_posts文件夹下的处理方式 </li>
<li><strong>page</strong> 文件不在_posts下，当文件是可渲染时的处理方式</li>
<li><strong>assets</strong> 文件不在_posts下，当文件是不可渲染时的处理方式</li>
</ol>
<p>另外隐藏文件是不会被处理的。Processor会读取文件文件信息调用Renderer，将处理后的文件内容以及相关信息写入数据库。以便Generator读取。</p>
<h2 id="Renderer">Renderer</h2>
<p><a href="http://hexo.io/docs/plugins.html#Renderer" target="_blank" rel="external">Renderer</a>将源文件转换成最终结果。在lib/plugins/renderer文件夹下可以看到默认的Renderer。默认的转换格式有html,htm,swig,yml等。另外hexo安装时会默认安装md,ejs和stylus的Renderer。</p>
<h2 id="Generator">Generator</h2>
<p><a href="http://hexo.io/docs/plugins.html#Generator" target="_blank" rel="external">Generator</a>根据Processor处理的结果生成静态文件。在lib/plugins/generator文件夹下可以看到默认的Generator。主要有下面几种</p>
<pre><code>generator.<span class="keyword">register</span>(<span class="string">'archive'</span>, <span class="keyword">require</span>(<span class="string">'./archive'</span>));
generator.<span class="keyword">register</span>(<span class="string">'category'</span>, <span class="keyword">require</span>(<span class="string">'./category'</span>));
generator.<span class="keyword">register</span>(<span class="string">'home'</span>, <span class="keyword">require</span>(<span class="string">'./home'</span>));
generator.<span class="keyword">register</span>(<span class="string">'page'</span>, <span class="keyword">require</span>(<span class="string">'./page'</span>));
generator.<span class="keyword">register</span>(<span class="string">'post'</span>, <span class="keyword">require</span>(<span class="string">'./post'</span>));
generator.<span class="keyword">register</span>(<span class="string">'tag'</span>, <span class="keyword">require</span>(<span class="string">'./tag'</span>));
generator.<span class="keyword">register</span>(<span class="string">'asset'</span>, <span class="keyword">require</span>(<span class="string">'./asset'</span>));
</code></pre><p>每一种Generator会根据数据库中的数据，对数据进一步加工生成最后的文件。比如post和page中的内容是html，在生成阶段会根据对应主题在html的基础上加上头尾。而asset类型的，这时数据库中只有文件信息还没有文件内容，这时asset生成器将处理方式存入hexo.route中在之后的生成阶段使用route记录的处理方式获取内容然后复制到目标位置。</p>
<h2 id="Box">Box</h2>
<p><a href="http://hexo.io/api/classes/Box.html" target="_blank" rel="external">Box</a>遍历Source文件夹下的所有文件，将具体文件分派给对应的Processor处理。</p>
<h2 id="Model">Model</h2>
<p><a href="http://hexo.io/api/classes/Model.html" target="_blank" rel="external">Model</a>是Hexo的数据库和数据模型，由Processor和Renderer写入数据，Generator读取数据。数据库是使用的warehouse, 主要的表有</p>
<pre><code>  model.<span class="keyword">register</span>(<span class="string">'Asset'</span>, schema.Asset);
  model.<span class="keyword">register</span>(<span class="string">'Cache'</span>, schema.Cache);
  model.<span class="keyword">register</span>(<span class="string">'Category'</span>, schema.Category, <span class="keyword">require</span>(<span class="string">'../model/category'</span>));
  model.<span class="keyword">register</span>(<span class="string">'Page'</span>, schema.Page);
  model.<span class="keyword">register</span>(<span class="string">'Post'</span>, schema.Post, <span class="keyword">require</span>(<span class="string">'../model/post'</span>));
  model.<span class="keyword">register</span>(<span class="string">'Tag'</span>, schema.Tag, <span class="keyword">require</span>(<span class="string">'../model/tag'</span>));
</code></pre><p>每次生成都会在根目录生成一个db.json，这个就是数据库的结构了。</p>
<h2 id="Theme">Theme</h2>
<p><a href="http://hexo.io/api/classes/Theme.html" target="_blank" rel="external">Theme</a>是连接Hexo核心库的桥梁。特别是在生成阶段当前主题进一步加工有Renderer生成的内容，生成最终的文件。</p>
<h2 id="Route">Route</h2>
<p><a href="http://hexo.io/api/classes/Router.html" target="_blank" rel="external">Route</a>有一个叫routes的属性，这是一个由文件路径作为key，和一个Function作为value的Map。这个Function的返回值就是文件的content。在生成阶段Generator会将最终数据存入这个Map里面。</p>
<h2 id="总结Hexo_Generate命令的工作流程">总结Hexo Generate命令的工作流程</h2>
<ul>
<li>用户终端输入命令 hexo generate。hexo启动，完成各模块初始化。 代码参见： <a href="https://github.com/hexojs/hexo/blob/master/lib/plugins/console/generate.js" target="_blank" rel="external">lib/plugins/console/generate.js</a>。</li>
<li>Box遍历source文件夹中的文件，将要处理的文件分类。代码参见：<a href="https://github.com/hexojs/hexo/blob/master/lib/box/index.js" target="_blank" rel="external">lib/box/index.js</a> 和 <a href="https://github.com/hexojs/hexo/blob/master/lib/plugins/processor/index.js" target="_blank" rel="external">lib/plugins/processor/index.js</a>。</li>
<li>各Processor处理对应文件，需要渲染的文件交由对应的Renderer渲染。并将渲染的数据写入数据库。代码参见：<a href="https://github.com/hexojs/hexo/tree/master/lib/plugins/processor" target="_blank" rel="external">lib/plugins/processor/</a> 和 <a href="https://github.com/hexojs/hexo/tree/master/lib/post" target="_blank" rel="external">lib/post/</a>。</li>
<li>各Generator根据数据库中的数据，根据对应主题进一步加工，将数据存入Route，最后写入目标位置。代码参见：<a href="https://github.com/hexojs/hexo/tree/master/lib/plugins/generator" target="_blank" rel="external">lib/plugins/generator/</a> 和 <a href="https://github.com/hexojs/hexo/blob/master/lib/theme/index.js" target="_blank" rel="external">lib/theme/index.js</a>。</li>
</ul>
<h2 id="一个小插件">一个小插件</h2>
<p>明白了基本原理之后，现在要实现一个小插件。需求是我现在的站点有一个文件夹project专门存放项目代码。但是每次hexo generate 都将public文件夹清空，然后写入文件。所以project文件夹要放在source下面。这样generate生成的时候就将project复制到public里面了。但是这又有一个问题，project我的项目文件夹不可避免的有代码，有些html文件他会自动加上页头和页尾，这个很不好。于是这个插件的功能就是在 _config.yml 配置一个参数允许自定义那些文件夹的内容是不需要渲染的直接复制到public文件夹。 基本思路就是 自定义一个processor，注册一个rule，只要是在这个列表中的文件就按照asset的方式处理。 附上插件地址 : <a href="https://github.com/f111fei/hexo-processor-copyassets" target="_blank" rel="external">https://github.com/f111fei/hexo-processor-copyassets</a></p>
<h2 id="题外:搭建NodeJS调试环境">题外:搭建NodeJS调试环境</h2>
<p>具体的步骤看这里:<a href="http://blog.domlib.com/articles/686.html" target="_blank" rel="external">http://blog.domlib.com/articles/686.html</a>。</p>
<p>这里我补充一下如何调试Hexo，其他的使用命令行的NodeJS调试也是同理。首先当然要下载好Hexo的源代码。然后比如源代码目录是 E:/workspace/hexo/ ，然后在该目录下执行 </p>
<pre><code>cd <span class="constant">E</span><span class="symbol">:/workspace/hexo/</span>
npm install -g 
</code></pre><p>安装一下，这一步是从npm服务器下载Hexo的依赖库，不然调试的时候会报错找不到依赖库。<br>然后创建一个Hexo站点(已经有的忽略下面这一步，直接cd到你的站点目录)</p>
<pre><code>cd <span class="constant">E</span><span class="symbol">:/workSpace/</span>
hexo init xzper.com
</code></pre><p>创建一个站点，这里假定站点目录是 E:/workSpace/xzper.com/ 。然后按照上面的教程，安装好调试工具并启动。</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> -g node-inspector
node-inspector</span>
</code></pre><p> 输入 node-inspector 启动调试工具。 最后最关键的一步，我们要调试hexo generate这个命令，那么在命令行中输入 </p>
<pre><code>cd <span class="constant">E</span><span class="symbol">:/workSpace/xzper</span>.com/
node --debug-brk=<span class="number">5858</span> <span class="constant">E</span><span class="symbol">:/workSpace/hexo/bin/hexo</span> generate
</code></pre><p>这时按照提示打开Chrome输入 <a href="http://127.0.0.1:8080/debug?port=5858" target="_blank" rel="external">http://127.0.0.1:8080/debug?port=5858</a> 断点会停在程序入口第一行，接下来你爱在哪设置断点就在哪设置。</p>
<h2 id="吐槽">吐槽</h2>
<p>我本来就得了一看JS代码就不好的病。然后这次为了搞懂Hexo，先初步学习了一下NodeJS，教程在<a href="http://www.open-open.com/lib/view/1392611872538" target="_blank" rel="external">这里</a>，不得不说本来就很讨厌的JS，再加上NodeJS最大的卖点-异步编程，那各种逼格极高的回调函数，看的我心花怒放，累觉不爱了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/hexojs/hexo" target="_blank" rel="external">Hexo</a>是一个轻量级的静态博客站点生成框架，使用NodeJS开发。经过我两个通宵的努力总算把这个东西研究了一个大概，这里拿来分享一下。</p>
]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://xzper.com/tags/Hexo/"/>
    
      <category term="解读" scheme="http://xzper.com/categories/%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[框架包结构的设计]]></title>
    <link href="http://xzper.com/2014/08/09/%E6%A1%86%E6%9E%B6%E5%8C%85%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://xzper.com/2014/08/09/框架包结构的设计/</id>
    <published>2014-08-08T16:43:25.000Z</published>
    <updated>2014-10-23T05:22:47.975Z</updated>
    <content type="html"><![CDATA[<p>这里的框架拿Flex或者FlexLite以及Egret做例子。框架的包结构划分应该是以调用关系为依据划分的，尽量把需要相互调用的类放在一个包下面。这样最终得到的结果就是各个包之间相互独立，理想情况下即使你删除一个包，其他的也不受影响。但是现实肯定不是理想的，包之间总是还有依赖。这些有依赖的东西，大部分就是框架里面核心的东西了。这时候就把这些公共依赖的部分抽出来，放到一个核心包下，比如叫core。 从另一种角度上来讲，所谓的框架”核心类”，实际上就是一些公共耦合的类。这样其他的包都和这个核心包有依赖关系，但是他们彼此之间没有依赖关系。</p>
<a id="more"></a>
<p>举一个例子：上面说到的三种框架都有一些枚举类，提供一下静态字符串，通常为其他类的某些属性提供值。再具体一点可以在Flex的spark.components包下面可以看到有一个PopUpPosition的一个枚举类，这里可能会奇怪，这个叫做components的包下面不应该都是放一些UI组件么，怎么多出了这么一个东西。别急，我们来看一下官方API描述：</p>
<p><pre class="lang:as decode:true">PopUpAnchor.popUpPosition 属性的枚举类型。该类型描述了 PopUpAnchor 锚定的 popUp 控件的位置。该位置与 PopUpAnchor 位置相关。</pre><br>这里明确指出了这个枚举类是和这个PopUpAnchor组件配套使用的，也不会作为其他类的某些属性的枚举类型。那么这个枚举类和组件放在一起也就无可厚非了。 我们再来看一下FlexLite里面的PopUpPosition这个类，同样的这也是一个枚举类，甚至全部的代码都和Flex里面的这个一样，但是这个类却不是在components包下面，而是在core包下面。同样的看一下API描述：</p>
<p><pre class="lang:as decode:true">定义弹出位置的常量值。 该常量决定目标对象相对于父级组件的弹出位置。</pre><br>看到这里结合上面所说的，那么这个类一定是和其他的某些类产生了依赖关系。在打开调用结构层次关系的时候会发现，不光是PopUpAnchor这个组件使用了这个常量，还有IToolTipManagerClient这个包含提示功能的组件接口也用到了这个，甚至DropDownList的默认皮肤以及ComboBox的默认皮肤也用到了这个弹出位置的常量，而这些在Flex里面是没有的。所有这两个类的包位置是不一致的。</p>
<p>通常，还有一些公共的依赖包比如managers以及layouts这些全局的管理类。还有一个utils的工具包，这些公共的类都有一个特点，就是除了依赖core包以外不会再依赖于其他的包了。再比如skins这个包，这个包提供组件的默认皮肤，我们完全可以直接删除这个包，整个框架也不会报错，但是他还是存在于框架中，因为他提供了一个默认的实现方式，方便了开发者以及调试。所有最后的结论就是，框架中包的划分是<strong>根据类的依赖关系来放，而不是类的特征。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里的框架拿Flex或者FlexLite以及Egret做例子。框架的包结构划分应该是以调用关系为依据划分的，尽量把需要相互调用的类放在一个包下面。这样最终得到的结果就是各个包之间相互独立，理想情况下即使你删除一个包，其他的也不受影响。但是现实肯定不是理想的，包之间总是还有依赖。这些有依赖的东西，大部分就是框架里面核心的东西了。这时候就把这些公共依赖的部分抽出来，放到一个核心包下，比如叫core。 从另一种角度上来讲，所谓的框架”核心类”，实际上就是一些公共耦合的类。这样其他的包都和这个核心包有依赖关系，但是他们彼此之间没有依赖关系。</p>
]]>
    
    </summary>
    
      <category term="架构" scheme="http://xzper.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="框架" scheme="http://xzper.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解读DXML编译器]]></title>
    <link href="http://xzper.com/2014/07/02/%E8%A7%A3%E8%AF%BBDXML%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <id>http://xzper.com/2014/07/02/解读DXML编译器/</id>
    <published>2014-07-02T08:22:49.000Z</published>
    <updated>2014-10-23T05:22:47.976Z</updated>
    <content type="html"><![CDATA[<p>DXML就是FlexLite中由FlexLiteStdio生成的皮肤文件，类似于Flex中的MXML。实际上区别没多少，可能最大的区别就是MXML支持Script脚本。DXML架构设计对编写各类UI编辑器，各类代码生成工具都有很好的参考价值。这里主要分析DXML编译器是如何将DXML文件转换为as代码。</p>
<a id="more"></a>
<p><strong>1.如何使用DXML编译器</strong></p>
<p>DXML编译器在源代码在FlexLiteExtends中的org.flexlite.domCompile包下。导入相应的类后，先导入配置文件manifest.xml(这个文件可以在FlexLiteStdio的安装目录的bin文件夹下可以找到，也可以通过ManifestUtil这个类生成)。这是一个全局静态属性，导入代码如下:</p>
<pre><code><span class="attribute">DXMLCompiler.configData </span>=<span class="string"> manifestXml;</span>
</code></pre><p>然后创建一个DXMLCompiler实例，调用compile方法得到编译后的结果:</p>
<pre><code><span class="keyword">var</span> compiler:<span class="type">DXMLCompiler</span> = new <span class="type">DXMLCompiler</span>();
<span class="keyword">var</span> <span class="literal">result</span>:<span class="type">String</span>  = compiler.compile(buttonSkinXml , <span class="string">"Button"</span>);
</code></pre><p>完整的代码如下:</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">DXMLCompilerTest</span> <span class="keyword">extends</span> <span class="title">Sprite</span></span>
{
    [Embed(source=<span class="string">"resource/xml/flexlite-manifest.xml"</span> , mimeType = <span class="string">"application/octet-stream"</span>)]
    <span class="keyword">private</span> <span class="keyword">var</span> manifest:Class;

    [Embed(source=<span class="string">"resource/xml/ButtonSkin.dxml"</span> , mimeType = <span class="string">"application/octet-stream"</span>)]
    <span class="keyword">private</span> <span class="keyword">var</span> buttonSkin:Class;

    public function DXMLCompilerTest()
    {
        <span class="keyword">super</span>();

        <span class="keyword">var</span> manifestBy:ByteArray = <span class="keyword">new</span> manifest();
        <span class="comment">//flexlite-manifest.xml对象</span>
        <span class="keyword">var</span> manifestXml:XML = XML(manifestBy.readUTFBytes(manifestBy.length));

        <span class="keyword">var</span> buttonSkinBy:ByteArray = <span class="keyword">new</span> buttonSkin();
        <span class="comment">//ButtonSkin.dxml对象</span>
        <span class="keyword">var</span> buttonSkinXml:XML = XML(buttonSkinBy.readUTFBytes(buttonSkinBy.length));

        <span class="comment">//flexlite-manifest框架清单文件</span>
        DXMLCompiler.configData = manifestXml;

        <span class="keyword">var</span> compiler:DXMLCompiler = <span class="keyword">new</span> DXMLCompiler();
        <span class="keyword">var</span> result:String  = compiler.compile(buttonSkinXml , <span class="string">"Button"</span>);
        trace(result);
    }
}
</code></pre><p><strong>2.配置文件manifest</strong></p>
<p>manifest是由编译器使用的配置文件，定义了编译器能识别的各类组件。</p>
<pre><code>&lt;componentPackage <span class="variable">crc32=</span><span class="string">"a32782dd"</span>&gt;
    &lt;component <span class="variable">id=</span><span class="string">"ArrayCollection"</span> <span class="variable">p=</span><span class="string">"org.flexlite.domUI.collections.ArrayCollection"</span> <span class="variable">s=</span><span class="string">"flash.utils.Proxy"</span> <span class="variable">d=</span><span class="string">"source"</span> <span class="variable">array=</span><span class="string">"true"</span>/&gt;
    &lt;component <span class="variable">id=</span><span class="string">"Button"</span> <span class="variable">p=</span><span class="string">"org.flexlite.domUI.components.Button"</span> <span class="variable">s=</span><span class="string">"org.flexlite.domUI.components.supportClasses.ButtonBase"</span> <span class="variable">show=</span><span class="string">"true"</span>/&gt;
    &lt;component <span class="variable">id=</span><span class="string">"ButtonBase"</span> <span class="variable">p=</span><span class="string">"org.flexlite.domUI.components.supportClasses.ButtonBase"</span> <span class="variable">s=</span><span class="string">"org.flexlite.domUI.components.SkinnableComponent"</span> <span class="variable">d=</span><span class="string">"label"</span> <span class="variable">state=</span><span class="string">"up,over,down,disabled"</span>/&gt;
    &lt;component <span class="variable">id=</span><span class="string">"Group"</span> <span class="variable">p=</span><span class="string">"org.flexlite.domUI.components.Group"</span> <span class="variable">s=</span><span class="string">"org.flexlite.domUI.components.supportClasses.GroupBase"</span> <span class="variable">d=</span><span class="string">"elementsContent"</span> <span class="variable">show=</span><span class="string">"true"</span> <span class="variable">array=</span><span class="string">"true"</span>/&gt;
&lt;/componentPackage&gt;
</code></pre><p>以上节选自flexlite-manifest.xml。manifest.xml由各类component组成，包括但不限于UI组件。主要是用来配置对dxml文件中可能出现的节点的定义供编译器解析。component节点对应编译器中的Component类，各个属性解释如下</p>
<p><strong>id</strong>，这个组件的短名ID，对应Component的id属性</p>
<p><strong>p</strong>，组件的完整类名，对应Component的className属性</p>
<p><strong>s</strong>，父级类名，对应Component的superClass属性</p>
<p><strong>d</strong>，默认属性，对应Component的defaultProp属性，这个实际就是表示这个组件的子节点对应的属性</p>
<p><strong>array</strong>，默认属性是否为数组类型，对应Component的isArray属性</p>
<p><strong>states</strong>，视图状态列表，对应Component的states属性</p>
<p>比如：</p>
<pre><code>&lt;dx:Group <span class="variable">left=</span><span class="string">"16"</span> <span class="variable">right=</span><span class="string">"16"</span> <span class="variable">top=</span><span class="string">"41"</span> <span class="variable">id=</span><span class="string">"contentGroup"</span> <span class="variable">bottom=</span><span class="string">"42"</span>/&gt;
    &lt;dx:Label <span class="variable">text=</span><span class="string">"标签"</span> <span class="variable">size=</span><span class="string">"14"</span> <span class="variable">maxWidth=</span><span class="string">"310"</span> <span class="variable">textColor=</span><span class="string">"0xFFFFFF"</span>/&gt;
&lt;/dx:Group&gt;
</code></pre><p>这里有一个Group组件，然后对应一个子节点Label。那么Group的defaultProp也就是elementsContent这个属性对应的值是个数组，其中的一项就是Label。同理，比如ArrayCollection节点有子节点，那么source属性对应的值就是这些子节点。</p>
<p><strong>2. 代码定义CodeBase</strong></p>
<p>CodeBase是代码定义的基类，其中的toCode方法就是生成代码的关键。编译器中扩展了CodeBase实现了各种代码定义，比如注释，变量定义，参数定义，函数定义，类定义和代码块。这里挑几个重点的说:</p>
<p><strong>函数定义CpFunction</strong>。一个函数主要由 修饰符(private,protected,public)，函数名 ，参数列表(CpArguments数组)和代码块(CpCodeBlock)组成。另外还有一些override，static之类的关键词标示符。</p>
<p><strong>代码块CpCodeBlock</strong>。代码块就是函数中的内容，主要提供了一些添加语句的方法，比如 添加变量声明语句addVar，添加赋值语句addAssignment，添加一行代码addCodeLine等。开发者调用这些方法从而完成代码块的内容。</p>
<p><strong>类定义CpClass</strong>。定义了一个类的代码，类的组成主要有 定义部分(例如:类注释， 类名，包名，修饰符，父类，接口)，导入包区块，构造函数，成员变量，成员函数。CpClass提供各种方法来完善这些内容，比如:导入包addImport，添加变量addVariable，添加函数addFunction。</p>
<p>有了这些，在完成类中各个区块的定义和赋值之后，调用toCode方法转换成as代码。</p>
<p><strong>3.解析配置文件DXMLConfig</strong></p>
<p>manifest.xml的解析交给DXMLConfig来完成，DXMLConfig解析完成后存储配置文件中的组件对应的基本属性已经映射关系。解析完成后，外界可以使用的主要方法有:<br>    /**</p>
<pre><code> * 根据类的短名ID和命名空间获取完整类名(以<span class="string">"."</span>分隔)
 * @param id 类的短名ID
 * @param ns 命名空间
 */                
<span class="function"><span class="keyword">function</span> <span class="title">getClassNameById</span><span class="params">(id:String,ns:Namespace)</span><span class="type">:String</span></span>;

<span class="comment">/**
 * 根据ID获取对应的默认属性
 * @param id 类的短名ID
 * @param ns 命名空间
 * @return {name:属性名(String),isArray:该属性是否为数组(Boolean)}
 */</span>        
<span class="function"><span class="keyword">function</span> <span class="title">getDefaultPropById</span><span class="params">(id:String,ns:Namespace)</span><span class="type">:Object</span></span>;

<span class="comment">/**
 * 获取指定属性的类型,返回基本数据类型："uint","int","Boolean","String","Number","Class"。
 * @param prop 属性名
 * @param className 要查询的完整类名
 * @param value 属性值
 */</span>            
<span class="function"><span class="keyword">function</span> <span class="title">getPropertyType</span><span class="params">(prop:String,className:String,value:String)</span><span class="type">:String</span></span>;
</code></pre><p><strong>4.了解DXML文件结构</strong></p>
<p>在了解编译器是如何工作之前，需要了解DXML文件的结构。这里通过一个典型例子来了解DXML的结构。</p>
<pre><code>&lt;xml <span class="variable">version=</span><span class="string">"1.0"</span> <span class="variable">encoding=</span><span class="string">"utf-8"</span>&gt;
&lt;dx:StateSkin <span class="variable">width=</span><span class="string">"100"</span> xmlns:<span class="variable">dx=</span><span class="string">"http://www.flexlite.org/dxml/2012"</span> xmlns:<span class="variable">fs=</span><span class="string">"http://www.flexlite.org/studio/2012"</span>&gt;
    &lt;fs:HostComponent <span class="variable">name=</span><span class="string">"org.flexlite.domUI.components.Button"</span>/&gt;
    &lt;fs:Declarations&gt;
        &lt;dx:DropShadowFilter <span class="variable">alpha=</span><span class="string">"1.00"</span> <span class="variable">angle=</span><span class="string">"0.00"</span> <span class="variable">blurY=</span><span class="string">"4"</span> <span class="variable">color=</span><span class="string">"0x000000"</span> <span class="variable">quality=</span><span class="string">"1"</span> <span class="variable">blurX=</span><span class="string">"4"</span> <span class="variable">hideObject=</span><span class="string">"false"</span> <span class="variable">distance=</span><span class="string">"0"</span> <span class="variable">inner=</span><span class="string">"false"</span> <span class="variable">strength=</span><span class="string">"10"</span> <span class="variable">knockout=</span><span class="string">"false"</span> <span class="variable">id=</span><span class="string">"__DropShadowFilter0"</span>/&gt;
    &lt;/fs:Declarations&gt;
    &lt;dx:states&gt;
        &lt;dx:State <span class="variable">name=</span><span class="string">"up"</span>/&gt;
        &lt;dx:State <span class="variable">name=</span><span class="string">"over"</span>/&gt;
        &lt;dx:State <span class="variable">name=</span><span class="string">"down"</span>/&gt;
        &lt;dx:State <span class="variable">name=</span><span class="string">"disabled"</span>/&gt;
    &lt;/dx:states&gt;
    &lt;dx:UIAsset <span class="variable">left=</span><span class="string">"0"</span> <span class="variable">y=</span><span class="string">"0"</span> <span class="variable">top=</span><span class="string">"0"</span> <span class="variable">right=</span><span class="string">"0"</span> <span class="variable">skinName=</span><span class="string">"DXR__1C5D2D62"</span> <span class="variable">bottom=</span><span class="string">"0"</span> <span class="variable">x=</span><span class="string">"0"</span> <span class="variable">includeIn=</span><span class="string">"disabled"</span>/&gt;
    &lt;dx:UIAsset <span class="variable">left=</span><span class="string">"0"</span> <span class="variable">top=</span><span class="string">"0"</span> <span class="variable">bottom=</span><span class="string">"0"</span> <span class="variable">skinName=</span><span class="string">"DXR__276F2CB5"</span> <span class="variable">right=</span><span class="string">"0"</span> <span class="variable">includeIn=</span><span class="string">"up"</span>/&gt;
    &lt;dx:UIAsset <span class="variable">left=</span><span class="string">"0"</span> <span class="variable">top=</span><span class="string">"0"</span> <span class="variable">bottom=</span><span class="string">"0"</span> <span class="variable">skinName=</span><span class="string">"DXR__7905FD81"</span> <span class="variable">right=</span><span class="string">"0"</span> <span class="variable">includeIn=</span><span class="string">"down"</span>/&gt;
    &lt;dx:UIAsset <span class="variable">left=</span><span class="string">"0"</span> <span class="variable">top=</span><span class="string">"0"</span> <span class="variable">bottom=</span><span class="string">"0"</span> <span class="variable">skinName=</span><span class="string">"DXR__F2888F03"</span> <span class="variable">right=</span><span class="string">"0"</span> <span class="variable">includeIn=</span><span class="string">"over"</span>/&gt;
    &lt;dx:Label <span class="variable">paddingTop=</span><span class="string">"4"</span> <span class="variable">id=</span><span class="string">"labelDisplay"</span> <span class="variable">horizontalCenter=</span><span class="string">"0"</span> <span class="variable">text=</span><span class="string">"按钮"</span> <span class="variable">size=</span><span class="string">"14"</span> <span class="variable">textAlign=</span><span class="string">"center"</span> <span class="variable">paddingBottom=</span><span class="string">"4"</span> <span class="variable">filters=</span><span class="string">"{[__DropShadowFilter0]}"</span> <span class="variable">paddingLeft=</span><span class="string">"10"</span> <span class="variable">bold=</span><span class="string">"false"</span> <span class="variable">textColor=</span><span class="string">"0xFFFFCD"</span> <span class="variable">paddingRight=</span><span class="string">"10"</span> <span class="variable">fontFamily=</span><span class="string">"FZShaoEr-M11S"</span> <span class="variable">verticalCenter=</span><span class="string">"0"</span>/&gt;
&lt;/dx:StateSkin&gt;
</code></pre><p><strong>根节点</strong>。每个DXML文件对应一个as类，根节点就是这个类定义，在这里可以定义类的属性以及对应的值。另外这里还有命名空间NameSpace的定义。默认的命名空间有dx和fs。命名空间主要用来快速区别节点，从而快速过滤对节点执行对应操作。</p>
<p><strong>声明节点</strong>。DXML中一些不可视的一些元素可以定义在声明节点中，作为fs:Declarations这个节点的子节点。上述例子中的阴影滤镜就是在这个节点中。</p>
<p><strong>States节点</strong>。States定义了组件的各个状态。</p>
<p><strong>组件节点</strong>。一般以dx开头的节点就是组件节点，当然组件节点也可以自定义(使用自定义组件所在的包作为新的命名空间，添加到根节点中)。这里可使用的组件是和manifest.xml中对应的。在组件节点中可以对组件的各个属性赋值。另外，组件节点有一些共有的特殊属性，比如: id 表示组件对应的实例名，includeIn，excludeFrom表示组件对应的状态。还有上面提到的，组件如果有子节点，那么这些子节点就是组件对应的默认值。</p>
<p><strong>5.DXML编译器</strong></p>
<p><strong>编译开始的准备工作</strong></p>
<p>在编译开始前，创建DXMLConfig实例解析manifest配置，读取dxml文件。创建一个CpClass实例currentClass。</p>
<p><strong>编译开始</strong></p>
<p>调用startCompile编译开始，通过getStateNames方法获取dxml中定义的所有状态并使用stateCode保存。然后为根节点加入currentState的属性并赋值。使用declarations保存dxml的声明节点。然后调用addIds方法遍历各个节点添加成员变量以及函数。最后是生成构造函数。</p>
<p><strong>导入包，添加import区块</strong></p>
<p>包的导入，并不是一次性导入，而是贯彻在整个编译过程中。通常在调用getPackageByNode这个方法时来添加import区块。因为每个节点一般对应一个class，这样在分析节点时就能获取到节点的className，从而导入。</p>
<p><strong>依据id添加成员变量，以及自动为组件添加id属性</strong></p>
<p>某些节点具有id属性，那么一般这个节点对应的实例就是这个类的成员变量，实例名就是这个id的值，调用createVarForNode方法将节点添加进成员变量列表。某些组件没有id属性，那么调用createIdForNode给每一个组件节点加上id属性，赋值也遵循一定规范不会重复。另外有些组件是只存在于某些特定状态下的，这时会使用stateIds记录下来，随后在构造函数里面单独实例化。以上过程的具体实现参考addIds这个方法，整个过程是递归的。</p>
<p><strong>创建构造函数</strong></p>
<p>函数的主要内容就是代码块，首先创建一个代码块实例。通过addAttributesToCodeBlock方法解析根节点的所有属性，并生成赋值语句。解析declarations的子节点，调用createFuncForNode为每一个子节点创建对应的方法。使用initlizeChildNode方法遍历组件的子组件，对组件的默认属性赋值。最后解析状态代码，完成所有状态的赋值。</p>
<p>简而言之，解析一个组件的大致思路就是，通过addAttributesToCodeBlock方法解析节点的属性并赋值，然后使用initlizeChildNode方法遍历节点的子节点为默认属性赋值。在initlizeChildNode方法中调用createFuncForNode，为每个子节点创建单独的函数。而createFuncForNode这个方法中又会调用addAttributesToCodeBlock和initlizeChildNode解析节点属性和为默认属性赋值，如此递归调用下去。</p>
<p><strong>重要方法解析</strong></p>
<p><strong>createVarForNode</strong></p>
<p>创建成员变量。一般带有id的组件节点都会被调用这个方法创建对应id的实例名变量。</p>
<p><strong>addAttributesToCodeBlock</strong></p>
<p>解析组件的属性并赋值。对应一些特殊属性比如id，includeIn，locked已经带有”.”操作符的属性是不理会的。这样获取一个keyList，读取对应的value，格式化key和value然后添加赋值语句。有些key比较特殊比如height，因为对应的值可能是一个百分比所以需要格式化key转换成percentHeight。格式化value就比较麻烦了，有些value是带”{}”的要去掉{}，有些特殊的key比如skinName对应的value可能是一个class，这些key-value的转换规则通过DXMLConfig的getPropertyType来获取。最后如果对应的值是一个id即成员变量，则需要延迟赋值，到那个成员变量的创建函数中赋值。</p>
<p><strong>initlizeChildNode</strong></p>
<p>某些组件含有子节点，这些子节点就是这个组件对应的默认属性的值。这个方法首先获取直接子节点directChild，然后调用createFuncForNode，为每个子节点创建单独的函数。最后生成默认属性的赋值语句。对于一些包含状态的子节点是会被过滤掉的，因为有专门的状态生成代码。</p>
<p><strong>createFuncForNode</strong></p>
<p>实际上创建构造函数也是实现了这个方法。先调用addAttributesToCodeBlock，然后调用initlizeChildNode。只是创建构造函数多了一个解析声明节点和解析状态的过程。这个方法有一个创建构造函数没有的过程就是，添加一个变量声明(实际上就是实例化这个节点对应的类)，为节点的id属性赋值为这个节点变量。原来还会在延迟赋值字典里面加入对应的延迟赋值语句。</p>
<p><strong>createStates</strong></p>
<p>这个是在创建构造函数时被调用的，主要用来解析视图状态代码。本身是一个递归函数。遍历所有的子节点，找到那些在特定状态下出现节点。分解成每一个CpState填充进stateCode。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>DXML就是FlexLite中由FlexLiteStdio生成的皮肤文件，类似于Flex中的MXML。实际上区别没多少，可能最大的区别就是MXML支持Script脚本。DXML架构设计对编写各类UI编辑器，各类代码生成工具都有很好的参考价值。这里主要分析DXML编译器是如何将DXML文件转换为as代码。</p>
]]>
    
    </summary>
    
      <category term="FlexLite" scheme="http://xzper.com/tags/FlexLite/"/>
    
      <category term="ActionScript3" scheme="http://xzper.com/tags/ActionScript3/"/>
    
      <category term="解读" scheme="http://xzper.com/categories/%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用egret开发2048]]></title>
    <link href="http://xzper.com/2014/06/22/%E4%BD%BF%E7%94%A8egret%E5%BC%80%E5%8F%912048/"/>
    <id>http://xzper.com/2014/06/22/使用egret开发2048/</id>
    <published>2014-06-22T12:41:00.000Z</published>
    <updated>2014-10-23T05:22:47.953Z</updated>
    <content type="html"><![CDATA[<p>2048是最近很火的一个小游戏，<a href="http://gabrielecirulli.github.io/2048/" target="_blank" rel="external">原版</a> 就是用JavaScript写的。恰巧最近Egret PublicBeta，观望和学习了一阵后，发现egret正好适合开发这类游戏。Egret使用TypeScript作为开发语言，最终编译为JavaScript，正好和原始版本PK一下。</p>
<p>游戏预览：<a href="http://xzper.com/project/2048egret/" target="_blank" rel="external">点我体验</a></p>
<a id="more"></a>
<p><strong>1.准备开始</strong></p>
<p>在开始之前，我们需要学习一下TypeScript和阅读官方的教程从Egret开发环境的部署到创建，编译，发布项目，以及Egret相关工具。在安装好开发环境后，在工作空间目录下使用命令行，创建2048egret新项目</p>
<pre><code>egret <span class="operator"><span class="keyword">create</span> <span class="number">2048</span>egret</span>
</code></pre><p><strong>2.准备素材</strong></p>
<p>每一个游戏都离不开美术资源，我们需要做的就是把美术资源打包，然后加载进来使用。这一方面egret有一套完整的工作流。</p>
<p><strong>①资源打包</strong></p>
<p>这里我们用到的资源主要有按钮，背景，文字以及数字这些图片。我们选择把这些图片都打包在一起合成一张大图就像 <a href="http://xzper.com/project/2048egret/resource/assets/source.png" target="_blank" rel="external">这样</a> 和 <a href="http://xzper.com/project/2048egret/resource/assets/number.png" target="_blank" rel="external">这样</a> 这样做可以减少URL请求数，还能减少资源的体积，把一些具有相同特征的图片放在一起便于管理。在egret里面这种类型的资源就是sheet。只有图片是不够的，还需要一个json描述文件来说明这张图每一张小图片的位置和大小。目前已经有成熟的工具来生成sheet和json。这里我用到的是 <a href="http://www.renderhjs.net/shoebox/" target="_blank" rel="external">ShoeBox</a> 配合这个 <a href="https://github.com/runinspring/egretTools" target="_blank" rel="external">插件</a> 来生成egret能识别的json。安装好插件后， 将每一张图片命名，然后将这些图片选中拖入Sprites Sheet中然后配置好生成的文件名点击save就能得到一张大图和一个json了，将图片和json放入”resource/assets/“文件夹下以备使用。此外ShoeBox还能读取swf将MovieClip导出为这种大图，按每一帧自动命名，这里的number.png就是这样导出的，下面有原始素材下载地址。</p>
<p><strong>②资源加载</strong></p>
<p>接下来我们需要生成一个资源描述文件resource.json，在游戏开始之前读取这个json来加载对应的文件。egret的资源加载机制可以参考 <a href="https://github.com/egret-labs/egret-core/wiki/Using%20Resource%20System" target="_blank" rel="external">这里</a> 现在已经有 <a href="http://bbs.egret-labs.org/thread-48-1-1.html" target="_blank" rel="external">工具</a> 能自动生成这个resource.json了。按照下图配置。<strong>注意：虽然我们的资源有图片，但是对应的json文件已经记录了图片的位置，所以在这个工具中我们不需要添加对应的图片只添加json文件就行了。</strong></p>
<center><img src="http://xzper.qiniudn.com/2014/06/ResTool.png" alt=""></center>

<p>在项目初始化时，使用RES加载资源，简单明了。</p>
<pre><code><span class="keyword">private</span> <span class="title">onAddToStage</span>(event:egret.Event){
    ........
    ........
    <span class="comment">//初始化Resource资源加载库</span>
    RES.addEventListener(RES.ResourceEvent.CONFIG_COMPLETE,<span class="keyword">this</span>.onConfigComplete,<span class="keyword">this</span>);
    RES.loadConfig(<span class="string">"resource/resource.json"</span>,<span class="string">"resource/"</span>);
}

<span class="javadoc">/**
 *配置文件加载完成,开始预加载preload资源组。
 */</span>
<span class="keyword">private</span> <span class="title">onConfigComplete</span>(event:RES.ResourceEvent):<span class="keyword">void</span>{
    RES.removeEventListener(RES.ResourceEvent.CONFIG_COMPLETE,<span class="keyword">this</span>.onConfigComplete,<span class="keyword">this</span>);
    RES.addEventListener(RES.ResourceEvent.GROUP_COMPLETE,<span class="keyword">this</span>.onResourceLoadComplete,<span class="keyword">this</span>);
    RES.addEventListener(RES.ResourceEvent.GROUP_PROGRESS,<span class="keyword">this</span>.onResourceProgress,<span class="keyword">this</span>);
    RES.loadGroup(<span class="string">"preload"</span>);
}
</code></pre><p><strong>③资源使用</strong></p>
<p>在项目中我们可以使用RES来使用资源，参照对应的API。对于没有写进配置文件的资源使用RES.getResByUrl方法来异步获取。开发人员能使用极其少量的代码来完成各类资源的加载。</p>
<p><strong>3.更改模板生成的代码</strong></p>
<p><strong>①修改细节</strong></p>
<p>默认的文档类是GameApp。我觉得还是叫Main比较亲切，修改类名称，然后修改项目目录下的egretProperties.json文件，将document_class的值改为Main</p>
<pre><code>{
    "<span class="attribute">document_class</span>" : <span class="value"><span class="string">"Main"</span></span>,
    "<span class="attribute">native</span>": <span class="value">{
        "<span class="attribute">path_ignore</span>": <span class="value">[
            <span class="string">"libs"</span>
        ]
    </span>}
</span>}
</code></pre><p>默认生成的html的背景是黑色的，这里全部改成白色。将index.html里面的背景替换成#ffffff。</p>
<p>默认尺寸是480x800的尺寸。由于我们使用的部分图片宽度大于500，以及部分PC的分辨率太小为了不出现垂直滚动条影响体验，将尺寸换成520x650。这个不影响移动设备上的尺寸，移动设备默认是自适应宽度的。</p>
<p>index.html中</p>
<pre><code>&lt;div <span class="variable">style=</span><span class="string">"display:inline-block;width:100%; height:100%;margin: 0 auto; background: #ffffff; position:relative;"</span> <span class="variable">id=</span><span class="string">"gameDiv"</span>&gt;
    &lt;canvas <span class="variable">id=</span><span class="string">"gameCanvas"</span> <span class="variable">width=</span><span class="string">"520"</span> <span class="variable">height=</span><span class="string">"650"</span> <span class="variable">style=</span><span class="string">"background-color: #ffffff"</span>&gt;&lt;/canvas&gt;
&lt;/div&gt;
</code></pre><p>egret_loader.js中</p>
<pre><code>//设置屏幕适配策略
egret.StageDelegate.getInstance().setDesignSize(<span class="number">520</span>, <span class="number">650</span>);
context.<span class="variable">stage =</span> new egret.Stage();
var <span class="variable">scaleMode =</span>  egret.MainContext.<span class="variable">deviceType =</span>= egret.MainContext.DEVICE_MOBILE ? egret.StageScaleMode.SHOW_ALL : egret.StageScaleMode.NO_SCALE;
context.stage.<span class="variable">scaleMode =</span> scaleMode;
</code></pre><p><strong>③引入第三方库pureMVC</strong></p>
<p>这次我们要使用到一个mvc开发框架-pureMVC，熟悉as3的朋友一定也对这个框架不陌生吧。不熟悉的也没关系，这个框架不是这次的主角。我们从 <a href="https://github.com/PureMVC/puremvc-typescript-standard-framework" target="_blank" rel="external">这里</a> 下载pureMVC的TypeScript版本。得到puremvc-typescript-standard-1.0.d.ts 和 puremvc-typescript-standard-1.0.js这两个文件，其实.d.ts就类似于c++里面的.h头文件，只有空方法和空属性，真正的实现是在js文件或者ts文件里面。在项目里面的src文件夹下建立一个puremvc的文件夹，将这个js文件和d.ts文件放进去。然后在项目根目录下建立一个puremvc.json的文件内容如下</p>
<pre><code>{
    "<span class="attribute">name</span>": <span class="value"><span class="string">"puremvc"</span></span>,
    "<span class="attribute">source</span>":<span class="value"><span class="string">"src/puremvc/"</span></span>,
    "<span class="attribute">file_list</span>": <span class="value">[
        <span class="string">"puremvc-typescript-standard-1.0.js"</span>,
        <span class="string">"puremvc-typescript-standard-1.0.d.ts"</span>
    ]
</span>}
</code></pre><p>这样就表示配置了一个第三方模块。之后在编译器编译时会把相应的模块对应的js文件夹编译进libs文件夹下。项目里面我们还使用了gui模块，这些模块的配置是在egretProperties.json中，部分代码如下</p>
<pre><code><span class="string">"modules"</span>: [
    {
        <span class="string">"name"</span>: <span class="string">"core"</span>
    },
    {
        <span class="string">"name"</span>: <span class="string">"gui"</span>
    },
    {
        <span class="string">"name"</span>: <span class="string">"puremvc"</span>,<span class="string">"path"</span>:<span class="string">"."</span>
    }
],
</code></pre><p><strong>④注入AssetAdapter和SkinAdapter</strong></p>
<p>我们这次的主角是egret的GUI。找到官方<a href="https://github.com/egret-labs/egret-examples" target="_blank">GUIExample</a>中的这两个ts文件复制到项目的src文件夹下面，由于这个项目没有用到默认皮肤，删除ShinAdapter里面getDefaultSkin方法的默认皮肤。最后不要忘了一点，在引擎初始化的时候注入这两个Adapter。</p>
<pre><code><span class="keyword">private</span> onAddToStage(event:egret<span class="built_in">.</span>Event){
        <span class="comment">//注入自定义的素材解析器</span>
        egret<span class="built_in">.</span>Injector<span class="built_in">.</span>mapClass(<span class="string">"egret.gui.IAssetAdapter"</span>,AssetAdapter);
        <span class="comment">//注入自定义的皮肤解析器</span>
        egret<span class="built_in">.</span>Injector<span class="built_in">.</span>mapClass(<span class="string">"egret.gui.ISkinAdapter"</span>,SkinAdapter);
        <span class="attribute">...</span><span class="attribute">...</span>
        <span class="attribute">...</span><span class="attribute">...</span>
}
</code></pre><p>这两个的Adapter的作用至关重要，AssetAdapter负责解释UIAsset的source属性 ，SkinAdapter负责解释SkinnableCompent的skinName属性。这里官方提供了两个默认已经写好了的，当然我们可以自己扩展。 没有他们，UIAsset素材包装器的source属性 和 可设置皮肤的GUI组件的skinName属性毫无作用。而这两种组件是今后使用最多的。不信可以往下看 。</p>
<p><strong>⑤修改createGameScene方法</strong></p>
<p>在生成的模板中，文档类Main在经过一系列的前期准备工作之后，终于轮到GUI组件的老大UIStage上场了。UIStage类似于Flex里面的SystemManager，内置弹出窗口层，工具提示层和鼠标样式层，所有的GUI组件都应该添加到他的下面，并且UIStage全局唯一。  这里我们实现了一个AppContainer继承自UIStage。 同时在这里pureMVC框架正式启动，开始运作。</p>
<pre><code><span class="javadoc">/**
 * 创建游戏场景
 */</span>
<span class="keyword">private</span> <span class="title">createGameScene</span>():<span class="keyword">void</span> {
    var appContainer:game.AppContainer = <span class="keyword">new</span> game.AppContainer();
    <span class="keyword">this</span>.addChild(appContainer);
    game.ApplicationFacade.getInstance().startUp(appContainer);
}
</code></pre><p><strong>4.pureMVC</strong></p>
<p><strong>①Mediator</strong></p>
<p>Mediator(中介器)是连接视图也就是egret的GUI和pureMVC的桥梁。Mediator受到消息时(handleNotification)调用GUI组件的方法和设置属性，来改变视图。或者视图发生改变时通知Mediator由其发送消息到pureMVC(sendNotification)。</p>
<p><strong>ApplicationMediator</strong> 监听键盘事件或者手势发送消息到GameCommand通知移动</p>
<p><strong>MainGameMediator</strong> 接收消息，调用MainGameUI的方法处理格子的移动，添加，删除，重置，以及接收游戏结果，显示结果面板</p>
<p><strong>MainMenuMediator</strong> 接收更新分数的消息，调用MainGameUI的方法更新分数与重置</p>
<p><strong>ResultWindowMediator</strong> 发送游戏重置的消息，以及自销毁。</p>
<p><strong>②Command</strong></p>
<p>command属于控制器。负责收发消息和处理简单的事务。在StartupCommand中使用ControllerPrepCommand，ModelPrepCommand，ViewPrepCommand三个子任务。分别注册控制器，数据和视图。</p>
<p><strong>GameCommand</strong> 处理各类事务。比如 玩家按下了方向键，收到消息调用GridProxy的移动方法改变数据，比如GridProxy移动格子分数改变了，通知GameCommand 调用GameProxy的更新分数方法改变分数，比如处理重置游戏的事务，通知各个数据模块重置数据</p>
<p><strong>③Proxy</strong></p>
<p>处理数据，提供公共方法供Command调用以改变数据。改变数据了然后sendNotification通知Mediator改变视图。</p>
<p><strong>GameProxy</strong> 处理游戏数据，比如更新分数，处理游戏结果</p>
<p><strong>GridProxy</strong> 这个游戏的核心数据，操作每一个格子的数据，通知视图格子的移动，添加，删除，重置。这里包含2048这个游戏的精髓。有兴趣的可以研究下，源码里面有详细注释，这篇文章不做重点讲解。</p>
<p><strong>5.egret的GUI</strong></p>
<p><strong>①制作菜单———-认识皮肤部件</strong></p>
<p>先来看看菜单长什么样子</p>
<p><img src="http://xzper.qiniudn.com/2014/06/菜单.jpg" alt=""></p>
<p>我们会发现这个菜单。有些是静态文本，是一直不变的，我偷懒直接用了一张图片代替了，图片可以用egret.gui.UIAsset。</p>
<p>还有当前得分和最高分已经那个向上飘的数字是动态的，可以选用egret.gui.Label这个组件。</p>
<p>一个重试按钮，既然已经说了是按钮了我们就用egret.gui.Button好了。</p>
<p>接下来我们要做到皮肤和组件分离。那几个需要参与逻辑的组件自然就成了皮肤部件了。来看看MainMenuUISkin：</p>
<pre><code><span class="javadoc">/**
 * 和主机组件匹配的皮肤部件
 */</span>
<span class="keyword">private</span> <span class="keyword">static</span> _skinParts:Array&amp;lt;string&amp;gt; = [<span class="string">"addLabel"</span>,<span class="string">"scoreLabel"</span>,<span class="string">"highScoreLabel"</span>,<span class="string">"resetButton"</span>];

<span class="keyword">public</span> get <span class="title">skinParts</span>():Array&amp;lt;string&amp;gt;{
    <span class="keyword">return</span> MainMenuUISkin._skinParts;
}

<span class="javadoc">/**
 * 加分文本
 */</span>
<span class="keyword">public</span> addLabel:egret.gui.Label;

<span class="javadoc">/**
 * 总分文本
 */</span>
<span class="keyword">public</span> scoreLabel:egret.gui.Label;

<span class="javadoc">/**
 * 最高分文本
 */</span>
<span class="keyword">public</span> highScoreLabel:egret.gui.Label;

<span class="javadoc">/**
 * 重置按钮
 */</span>
<span class="keyword">public</span> resetButton:egret.gui.Button;

<span class="keyword">public</span> <span class="title">createChildren</span>():<span class="keyword">void</span>
{
    <span class="keyword">super</span>.createChildren;
    var uiAsset:egret.gui.UIAsset = <span class="keyword">new</span> egret.gui.UIAsset();
    uiAsset.source = <span class="string">"source.menu"</span>;
    <span class="keyword">this</span>.addElement(uiAsset);

    <span class="keyword">this</span>.resetButton = <span class="keyword">new</span> egret.gui.Button();
    <span class="keyword">this</span>.resetButton.skinName = ResetButtonSkin;
    <span class="keyword">this</span>.resetButton.right = <span class="number">10</span>;
    <span class="keyword">this</span>.resetButton.top = <span class="number">80</span>;
    <span class="keyword">this</span>.resetButton.label = <span class="string">"重置游戏"</span>;
    <span class="keyword">this</span>.addElement(<span class="keyword">this</span>.resetButton);

    <span class="keyword">this</span>.highScoreLabel = <span class="keyword">new</span> egret.gui.Label();
    ...省略若干代码
    <span class="keyword">this</span>.scoreLabel = <span class="keyword">new</span> egret.gui.Label();
    ...省略若干代码
    <span class="keyword">this</span>.addLabel = <span class="keyword">new</span> egret.gui.Label();
    ...省略若干代码
}
</code></pre><p>篇幅有限，省略了createChildren方法里面的子组件布局。<strong>skin的createChildren方法是在皮肤和主机组件匹配的时候被调用的。皮肤和主机组件匹配是在主机组件被添加到显示列表的时候完成的。所以只要主机组件hostComponent还没有添加到显示舞台，获取hostComponent的皮肤部件都是无效的。</strong>这也是为什么我将Mediator的注册放在GUI组件的createComplete后。以防Mediator访问出现空对象的情况。</p>
<p>再来看看主机组件MainMenuUI是怎么写的。</p>
<pre><code>export class MainMenuUI extends egret.gui.SkinnableComponent{
    <span class="keyword">public</span> addLabel:egret.gui.Label;
    <span class="keyword">public</span> scoreLabel:egret.gui.Label;
    <span class="keyword">public</span> highScoreLabel:egret.gui.Label;
    <span class="keyword">public</span> resetButton:egret.gui.Button;

    <span class="keyword">public</span> <span class="title">constructor</span>(){
        <span class="keyword">super</span>();
        <span class="keyword">this</span>.skinName = MainMenuUISkin;
        <span class="keyword">this</span>.addEventListener(egret.gui.UIEvent.CREATION_COMPLETE , <span class="keyword">this</span>.createCompleteEvent, <span class="keyword">this</span>);
    }

    <span class="keyword">public</span> <span class="title">createCompleteEvent</span>(event:egret.gui.UIEvent):<span class="keyword">void</span>{
        <span class="keyword">this</span>.removeEventListener(egret.gui.UIEvent.CREATION_COMPLETE , <span class="keyword">this</span>.createCompleteEvent, <span class="keyword">this</span>);
        ApplicationFacade.getInstance().registerMediator( <span class="keyword">new</span> MainMenuMediator(<span class="keyword">this</span>) );
    }

    <span class="keyword">public</span> <span class="title">partAdded</span>(partName:string, instance:any):<span class="keyword">void</span>{
        <span class="keyword">super</span>.partAdded(partName , instance);
        <span class="keyword">if</span>(<span class="keyword">this</span>.addLabel == instance){
            <span class="keyword">this</span>.addLabel.visible = <span class="keyword">false</span>;
        }
    }

    <span class="keyword">private</span> <span class="title">moveEffect_effectEndHandler</span>():<span class="keyword">void</span>
    {
        <span class="keyword">this</span>.addLabel.visible = <span class="keyword">false</span>;
    }

    <span class="javadoc">/**
    * 加分效果
    */</span>
    <span class="keyword">public</span> <span class="title">playScoreEffect</span>(addScore:number):<span class="keyword">void</span>{
        <span class="keyword">this</span>.addLabel.visible = <span class="keyword">true</span>;
        <span class="keyword">this</span>.addLabel.text = <span class="string">"+"</span>.concat(addScore.toString());
        egret.Tween.removeTweens(<span class="keyword">this</span>.addLabel);
        <span class="keyword">this</span>.addLabel.y = <span class="number">25</span>;
        egret.Tween.get(<span class="keyword">this</span>.addLabel).to({y:<span class="number">0</span>},<span class="number">300</span>).call(<span class="keyword">this</span>.moveEffect_effectEndHandler , <span class="keyword">this</span>);
    }
</code></pre><p>   }</p>
<p>在构造函数里面赋值skinName传入皮肤的类引用，这个解析过程就是SkinAdapter完成的。 可以看到主机组件有一个partAdded进行皮肤组件的配对。这个时候我们就可以获取到对应的皮肤组件，来进行操作了，</p>
<p><strong>②制作游戏区域————了解九宫格和容器布局</strong></p>
<p><img src="http://xzper.qiniudn.com/2014/06/游戏演示.png" alt=""></p>
<p>再次来观察这个游戏的主界面。有一张纯色的背景图，还有4x4个空白的格子，随着游戏的进行会多出带数字的格子，游戏结束了还会出现胜利的界面。</p>
<p>先来看看第一张图。也许你认为这个背景一张4x4的图片不就搞定了么。不过我们这个2048单元格的数量可是可以任意调整的，可以是5x5，或者6x6甚至更多，这样才具备灵活性。你只需要改变CommandData的size属性就可以了(PS:游戏胜利的条件默认是达成2048，也可以通过修改CommandData的winValue属性来修改条件比如8192时胜利或者像上面那样32的时候胜利，想不输都难)。</p>
<p>我们继承SkinnableContainer建立一个MainGameUI的类作为容器来显示上面的界面，当然同时还需要一个皮肤MainGameUISkin。先来确定skinParts，如下：</p>
<pre><code><span class="javadoc">/**
 * 和主机组件匹配的皮肤部件
 */</span>
<span class="keyword">private</span> <span class="keyword">static</span> _skinParts:Array&amp;lt;string&amp;gt; = [
    <span class="string">"tileGroup"</span>,<span class="string">"contentGroup"</span>
];

<span class="keyword">public</span> get <span class="title">skinParts</span>():Array&amp;lt;string&amp;gt;{
    <span class="keyword">return</span> MainGameUISkin._skinParts;
}

<span class="javadoc">/**
 * 游戏底背景
 */</span>
<span class="keyword">private</span> backUIAsset:egret.gui.UIAsset;

<span class="javadoc">/**
 * 背景格子容器
 */</span>
<span class="keyword">private</span> backGroundGroup:egret.gui.Group;

<span class="javadoc">/**
 * 格子容器
 */</span>
<span class="keyword">public</span> tileGroup:egret.gui.Group;

<span class="javadoc">/**
 * 内容
 */</span>
<span class="keyword">public</span> contentGroup:egret.gui.Group;
</code></pre><p>游戏游戏的底背景backUIAsset和背景格子容器backGroundGroup由于逻辑组件MainGameUI不需要关心所有这里不将其设置为skinParts。tileGroup是放置单元格的容器，contentGroup是SkinnableContainer的皮肤部件，SkinnableContainer的addElement方法实际上是添加到这个里面，换言之如果皮肤缺少这个contentGroup那么调用MainGameUI的addElement是看不到你要添加的子项的。 然后override这个createChildren方法将这些组件加入到显示列表。</p>
<pre><code><span class="keyword">public</span> createChildren():<span class="keyword">void</span>
{
    <span class="keyword">super</span>.createChildren;
    <span class="keyword">this</span>.backUIAsset = <span class="keyword">new</span> egret.gui.UIAsset();
    <span class="keyword">this</span>.backUIAsset.<span class="keyword">source</span> = <span class="string">"source.background"</span>;
    <span class="comment">//使用九宫格</span>
    <span class="keyword">this</span>.backUIAsset.scale9Grid = <span class="keyword">new</span> egret.gui.Rectangle(<span class="number">20</span>, <span class="number">20</span>, <span class="number">65</span>, <span class="number">65</span>);
    <span class="keyword">this</span>.backUIAsset.width = CommonData.<span class="keyword">size</span>*(TileUI.<span class="keyword">size</span> + <span class="keyword">this</span>.gap) + <span class="keyword">this</span>.gap;
    <span class="keyword">this</span>.backUIAsset.height = <span class="keyword">this</span>.backUIAsset.width;
    <span class="keyword">this</span>.addElement(<span class="keyword">this</span>.backUIAsset);

    <span class="comment">//使用格子布局</span>
    var layout:egret.gui.TileLayout = <span class="keyword">new</span> egret.gui.TileLayout();
    layout.columnCount = layout.rowCount = CommonData.<span class="keyword">size</span>;
    layout.horizontalGap = layout.verticalGap = <span class="keyword">this</span>.gap;
    <span class="keyword">this</span>.backGroundGroup = <span class="keyword">new</span> egret.gui.<span class="keyword">Group</span>();
    <span class="keyword">this</span>.backGroundGroup.x = <span class="keyword">this</span>.backGroundGroup.y = <span class="keyword">this</span>.gap;
    <span class="keyword">this</span>.backGroundGroup.layout = layout;
    <span class="keyword">this</span>.addElement(<span class="keyword">this</span>.backGroundGroup);
    <span class="keyword">this</span>.initBackGround(CommonData.<span class="keyword">size</span>);

    <span class="keyword">this</span>.tileGroup = <span class="keyword">new</span> egret.gui.<span class="keyword">Group</span>();
    <span class="keyword">this</span>.tileGroup.x = <span class="keyword">this</span>.tileGroup.y = <span class="keyword">this</span>.gap;
    <span class="keyword">this</span>.addElement(<span class="keyword">this</span>.tileGroup);

    <span class="keyword">this</span>.contentGroup = <span class="keyword">new</span> egret.gui.<span class="keyword">Group</span>();
    <span class="keyword">this</span>.contentGroup.percentHeight = <span class="keyword">this</span>.contentGroup.percentWidth = <span class="number">100</span>;
    <span class="keyword">this</span>.contentGroup.touchEnabled = <span class="keyword">false</span>;
    <span class="keyword">this</span>.addElement(<span class="keyword">this</span>.contentGroup);
}
</code></pre><p>先看backUIAsset，由于图片素材只是一个小的纯色圆角矩形，使用scale9Grid属性来设置九宫格缩放，这样设置了宽高就不会变形了。这里backGroundGroup设置了一个layout来确定布局。设置好间距以及行列数，向容器里面添加子项时就自动设置了位置了，不需要设置子项的x，y属性。TileLayout会自动布局。</p>
<pre><code><span class="keyword">private</span> initBackGround(size:<span class="built_in">number</span>):<span class="built_in">void</span>{
        <span class="comment">//背景格子</span>
        <span class="keyword">var</span> tile:egret.gui.UIAsset;
        <span class="keyword">var</span> totalNum:<span class="built_in">number</span> = size * size;
        <span class="keyword">for</span>(<span class="keyword">var</span> i:<span class="built_in">number</span> = <span class="number">0</span>;i &amp;lt; totalNum ; i++)
        {
            tile = <span class="keyword">new</span> egret.gui.UIAsset();
            tile.width = tile.height = TileUI.size;
            tile.source = <span class="string">"source.backtile"</span>;
            <span class="keyword">this</span>.backGroundGroup.addElement(tile);
        }
}
</code></pre><p><strong>③制作单元格————自定义属性</strong></p>
<p>单元格使用TileUI来定义。单元格有一个很重要的属性就是单元格的数据，这里使用value属性来表示。</p>
<pre><code><span class="keyword">private</span> valueChanged:<span class="keyword">boolean</span>;
<span class="keyword">private</span> _value:number;
<span class="javadoc">/**
 * 格子的数字
 */</span>
<span class="keyword">public</span> get <span class="title">value</span>():number{
    <span class="keyword">return</span> <span class="keyword">this</span>._value;
}

<span class="keyword">public</span> set <span class="title">value</span>(value:number){
    <span class="keyword">if</span>(value == <span class="keyword">this</span>._value){
        <span class="keyword">return</span>;
    }
    <span class="keyword">this</span>.valueChanged = <span class="keyword">true</span>;
    <span class="keyword">this</span>._value = value;
    <span class="keyword">this</span>.invalidateProperties();
}

<span class="keyword">public</span> <span class="title">commitProperties</span>():<span class="keyword">void</span>{
    <span class="keyword">if</span>(<span class="keyword">this</span>.valueChanged){
        <span class="keyword">this</span>.valueChanged = <span class="keyword">false</span>;
        <span class="keyword">this</span>.updateValue();
    }
}

<span class="keyword">private</span> <span class="title">updateValue</span>():<span class="keyword">void</span>{
    var mi:number = Math.log(<span class="keyword">this</span>._value)/Math.log(<span class="number">2</span>);
    <span class="keyword">this</span>.source = <span class="string">"number.number_"</span>+mi;
}
</code></pre><p>这里使用了invalidateProperties和commitProperties来完成属性的失效验证。当设置value的时候调用invalidateProperties，失效属性，GUI框架在下一次渲染的时候会调用commitProperties来完成属性的提交。失效验证简单说就是一种延迟应用改变的措施，这种失效验证在egret的GUI组件内部随处可见。这种自定义属性的例子只是其中之一，当组件的commitProperties方法被调用时组件已经准备完毕，所有的皮肤部件也匹配上了。这样也不用担心应用属性的时候报空的情况。这里通过设置TileUI的source属性来改变数字。还记得一开始的resource.json加载的number.json么。</p>
<pre><code>{
"<span class="attribute">frames</span>": <span class="value">{
    "<span class="attribute">number_1</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">106</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">212</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_10</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">0</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">318</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_11</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">0</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">212</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_12</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">0</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">106</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_13</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">0</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">0</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_2</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">212</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">318</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_3</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">212</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">212</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_4</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">212</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">106</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_5</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">212</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">0</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_6</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">106</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">318</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_7</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">318</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">0</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_8</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">106</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">106</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_9</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">106</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">0</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}

</span>}</span>,
"<span class="attribute">file</span>": <span class="value"><span class="string">"number.png"</span>
</span>}
</code></pre><p>这个sheet记录的每一张图也有一个名称比如2这个数字就是number_1加上number这个sheet名称使用”.”符号连接，所以获取”2”这个数字的图片就可以这样写this.source = “number.number_1”。根据值的不同取2的对数得到相应的下标数字。</p>
<p><strong>④制作胜负界面————自定义组件状态</strong></p>
<p>游戏结束之后会出现胜负的界面。但是胜负界面应该是两套不同的素材，那么我们是不是可以制作两个皮肤来根据胜负来切换？这样当然可以。但是，还有一种更简单的办法就是使用自定义状态，只需要一个皮肤类就可以完成两种视图的切换。</p>
<p>新建一个ResultWindow类继承自SkinnableComponent，然后新建ResultWindowSkin。在ResultWindowSkin的构造函数中定义两个状态win和failed。</p>
<pre><code><span class="keyword">public</span> <span class="constructor"><span class="keyword">constructor</span>()</span>{
    <span class="keyword">super</span>();
    <span class="keyword">this</span>.states = [<span class="string">"win"</span>,<span class="string">"failed"</span>];
}
</code></pre><p>然后加入两个皮肤部件button和resultUI</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> _skinParts:Array&lt;string&gt; = [<span class="string">"button"</span>,<span class="string">"resultUI"</span>];

<span class="keyword">public</span> get <span class="title">skinParts</span>():Array&lt;string&gt;{
    <span class="keyword">return</span> ResultWindowSkin._skinParts;
}

<span class="javadoc">/**
 * 按钮
 */</span>
<span class="keyword">public</span> button:egret.gui.Button;

<span class="javadoc">/**
 * 结果文本
 */</span>
<span class="keyword">public</span> resultUI:egret.gui.UIAsset;
</code></pre><p>在createChildren里面将皮肤部件布局好位置。最后重写commitCurrentState方法来根据对应的状态来改变部件的skin。</p>
<pre><code><span class="keyword">public</span> <span class="title">commitCurrentState</span>():<span class="keyword">void</span> {
    <span class="keyword">super</span>.commitCurrentState();
    <span class="keyword">if</span>(<span class="keyword">this</span>.currentState == <span class="string">"win"</span>)
    {
        <span class="keyword">this</span>.resultUI.source = <span class="string">"source.result_sucess"</span>;
        <span class="keyword">this</span>.button.skinName = ContinueButtonSkin;
    }
    <span class="keyword">else</span>
    {
        <span class="keyword">this</span>.resultUI.source = <span class="string">"source.result_failed"</span>;
        <span class="keyword">this</span>.button.skinName = ResetButtonSkin;
    }
}
</code></pre><p>这样还没有完，我们需要在主机组件里面定义何时是何种状态，在ResultWindow中重写getCurrentSkinState来定义皮肤状态。</p>
<pre><code><span class="keyword">private</span> _win:boolean = <span class="keyword">false</span>;
<span class="keyword">public</span> <span class="keyword">get</span> <span class="title">win</span>():boolean{
    <span class="keyword">return</span> <span class="keyword">this</span>._win;
}

<span class="keyword">public</span> <span class="keyword">set</span> <span class="title">win</span>(<span class="keyword">value</span>:boolean){
    <span class="keyword">if</span>(<span class="keyword">value</span> == <span class="keyword">this</span>._win)
        <span class="keyword">return</span>;
    <span class="keyword">this</span>._win = <span class="keyword">value</span>;
    <span class="keyword">this</span>.invalidateSkinState();
}

<span class="keyword">public</span> <span class="title">getCurrentSkinState</span>():<span class="keyword">string</span> {
    <span class="keyword">return</span> <span class="keyword">this</span>.win?<span class="string">"win"</span>:<span class="string">"failed"</span>;
}
</code></pre><p>当外界设置win的值时调用invalidateSkinState来失效皮肤状态，在框架下次渲染的时候，调用SkinnableComponent的validateSkinState方法同时通过getCurrentSkinState来获取皮肤状态，通知皮肤去改变视图。这又是失效验证机制的一次完美使用。我们只需要调用失效，然后重写对应的验证方法就行了。事实上，按钮的up，down，disable之类的状态也是这样实现的。</p>
<p>egret的GUI库，集合了Flex和<a href="http://flexlite.org" target="_blank" rel="external">FlexLite</a>的核心思想。实现了自动布局，皮肤分离，组件的三层失效验证机制。快来膜拜作者<a href="http://blog.domlib.com/" target="_blank" rel="external">DOM</a>大神吧。</p>
<p><strong>6.优化游戏</strong></p>
<p><strong>①使用对象池</strong></p>
<p>在游戏里面随着游戏的进行，每一次移动都有一个格子组件TileUI的创建，当游戏久了会造成巨大的内存开销。这里使用对象池技术。当一个对象使用完毕时，放入对象池，下次需要使用时取出来，这样避免了对象的重复创建，节约了内存。具体的实现参考ObjectPool这个类。具体使用在MainGameUI里面，如下：</p>
<pre><code><span class="javadoc">/**
 * 创建一个格子
 */</span>
<span class="keyword">public</span> <span class="title">createTile</span>(tileVO:TileVO):<span class="keyword">void</span>{
    var tile:TileUI = &amp;lt;TileUI&amp;gt;(ObjectPool.getPool(<span class="string">"game.TileUI"</span>).borrowObject());  <span class="comment">//从对象池创建</span>
   ......
   ......
}
</code></pre><p>当对象池里面没有TileUI时使用会new一个出来，否则直接从对象池获取。</p>
<pre><code><span class="javadoc">/**
 * 清除一个格子
 */</span>
<span class="keyword">public</span> <span class="title">removeTile</span>(tileVO:TileVO):<span class="keyword">void</span>{
    var tileUI:TileUI = <span class="keyword">this</span>.getTileUI(tileVO.x , tileVO.y);
    <span class="keyword">if</span>(tileUI){
        <span class="keyword">this</span>.tileGroup.removeElement(tileUI);
        ObjectPool.getPool(<span class="string">"game.TileUI"</span>).returnObject(tileUI);
    }
}
</code></pre><p>当格子销毁时，回收到对象池，以备下次使用。</p>
<p>另外由于js没有提供弱引用特性，在对象池里面的对象要彻底销毁就需要手动了。</p>
<p><strong>②针对不同设备</strong></p>
<p>游戏在PC我们使用键盘上的方向键操控游戏，但是在移动设备上就需要使用手势来操控了，通过egret.MainContext.deviceType这个值来获取平台 。具体实现在ApplicationMediator中：</p>
<pre><code><span class="comment">//为PC和移动端设置不同的移动策略</span>
<span class="keyword">if</span>(egret.MainContext.deviceType != egret.MainContext.DEVICE_MOBILE)
{
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="built_in">document</span>.addEventListener(<span class="string">"keydown"</span>,<span class="function"><span class="keyword">function</span><span class="params">(event:KeyboardEvent)</span></span>{
        <span class="keyword">switch</span> (event.keyCode) {
            ....省略键盘事件......
        }
    });
}
<span class="keyword">else</span>
{
    <span class="keyword">this</span>.main.addEventListener(egret.TouchEvent.TOUCH_BEGIN , <span class="keyword">this</span>.mouseDownHandle , <span class="keyword">this</span>)
}
</code></pre><p>由于egret目前没有提供手势的API，这里我们自己实现手势。监听TOUCH_BEGIN，TOUCH_MOVE，TOUCH_END和LEAVE_STAGE这四个事件。具体实现如下：</p>
<pre><code><span class="keyword">private</span> downPoint:egret.Point;
<span class="keyword">private</span> movePoint:egret.Point;
<span class="keyword">private</span> <span class="title">mouseDownHandle</span>(<span class="keyword">event</span>:egret.TouchEvent):<span class="keyword">void</span>
{
    egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_MOVE,<span class="keyword">this</span>.stage_mouseMoveHandler,<span class="keyword">this</span>);
    egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_END,<span class="keyword">this</span>.stage_mouseUpHandler,<span class="keyword">this</span>);
    egret.UIGlobals.stage.addEventListener(egret.Event.LEAVE_STAGE,<span class="keyword">this</span>.stage_mouseUpHandler,<span class="keyword">this</span>);

    <span class="keyword">this</span>.downPoint = <span class="keyword">this</span>.main.globalToLocal(<span class="keyword">event</span>.stageX, <span class="keyword">event</span>.stageY);
}

<span class="keyword">private</span> needMove:boolean;
<span class="keyword">private</span> <span class="title">stage_mouseMoveHandler</span>(<span class="keyword">event</span>:egret.TouchEvent):<span class="keyword">void</span>{
    <span class="keyword">if</span>(!<span class="keyword">this</span>.movePoint)
        <span class="keyword">this</span>.movePoint = <span class="keyword">new</span> egret.Point();
    <span class="keyword">this</span>.movePoint.x = <span class="keyword">event</span>.stageX;
    <span class="keyword">this</span>.movePoint.y = <span class="keyword">event</span>.stageY;
    <span class="keyword">if</span> (<span class="keyword">this</span>.needMove)
        <span class="keyword">return</span>;
    <span class="keyword">this</span>.needMove = <span class="keyword">true</span>;
}

<span class="keyword">public</span> <span class="title">stage_mouseUpHandler</span>(<span class="keyword">event</span>:egret.Event):<span class="keyword">void</span>{
    egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_MOVE,
        <span class="keyword">this</span>.stage_mouseMoveHandler,
        <span class="keyword">this</span>);
    egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_END,
        <span class="keyword">this</span>.stage_mouseUpHandler,
        <span class="keyword">this</span>);
    egret.UIGlobals.stage.addEventListener(egret.Event.LEAVE_STAGE,
        <span class="keyword">this</span>.stage_mouseUpHandler,
        <span class="keyword">this</span>);
    <span class="keyword">if</span>(<span class="keyword">this</span>.needMove){
        <span class="keyword">this</span>.updateWhenMouseUp();
        <span class="keyword">this</span>.needMove = <span class="keyword">false</span>;
    }
}

<span class="comment">/**
 * 移动设备上，判断移动方向
 */</span>
<span class="keyword">private</span> <span class="title">updateWhenMouseUp</span>():<span class="keyword">void</span>
{
    <span class="keyword">var</span> p:egret.Point = <span class="keyword">this</span>.main.globalToLocal(<span class="keyword">this</span>.movePoint.x, <span class="keyword">this</span>.movePoint.y ,egret.Point.identity);
    <span class="keyword">var</span> offSetX:number = p.x - <span class="keyword">this</span>.downPoint.x;
    <span class="keyword">var</span> offSetY:number = p.y - <span class="keyword">this</span>.downPoint.y;

    <span class="keyword">if</span>(offSetY&amp;lt;<span class="number">0</span> &amp;amp;&amp;amp; Math.abs(offSetY)&amp;gt;Math.abs(offSetX))  <span class="comment">//上</span>
    {
        <span class="keyword">this</span>.doMove(<span class="number">0</span>);
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(offSetX&amp;gt;<span class="number">0</span> &amp;amp;&amp;amp; offSetX&amp;gt;Math.abs(offSetY))  <span class="comment">//右</span>
    {
        <span class="keyword">this</span>.doMove(<span class="number">1</span>);
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(offSetY&amp;gt;<span class="number">0</span> &amp;amp;&amp;amp; offSetY&amp;gt;Math.abs(offSetX))  <span class="comment">//下</span>
    {
        <span class="keyword">this</span>.doMove(<span class="number">2</span>);
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(offSetX&amp;lt;<span class="number">0</span> &amp;amp;&amp;amp; Math.abs(offSetX)&amp;gt;Math.abs(offSetY))  <span class="comment">//左</span>
    {
        <span class="keyword">this</span>.doMove(<span class="number">3</span>);
    }
}
</code></pre><p><strong>③动画效果</strong></p>
<p>游戏里面格子的创建，移动，合并，都需要一个缓动效果来支持。这里面最大的问题就是，缓动效果是持续时间的，而往往数据的改变是一瞬间。比如：一个操作合并了两个格子，其中一个需要移动，并且移动完成后要移除掉，此时新的格子也要出现。但是往往数据层把这些数据是同时发过来的，所以我们需要调节时机来让效果更好。比如格子的创建，我们延迟100毫秒显示在舞台上，因为在创建的同时其他格子会移动，所以等其他格子移动完成了后显示出来比较好。再比如格子的合并，实际上就是一个格子移动，移动完成后消失，目标位置格子改变数字并且出现缩放效果。这样要注意的就是移动之前调整将移动的格子的层级显示在最下面，避免移动的时候挡在目标位置格子的上面。</p>
<p><strong>7.性能</strong></p>
<p>egret的工作流还是很高效的，工具也不少，架构设计集各家所长。最后发布游戏在PC上运行是满帧运行，比原版甚至更快。在手机上运行也不错，体验超过了某些原生语言开发的2048。</p>
<p>最后交出源代码：<a href="https://github.com/f111fei/2048egret" target="_blank" rel="external">点我传送</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2048是最近很火的一个小游戏，<a href="http://gabrielecirulli.github.io/2048/" target="_blank" rel="external">原版</a> 就是用JavaScript写的。恰巧最近Egret PublicBeta，观望和学习了一阵后，发现egret正好适合开发这类游戏。Egret使用TypeScript作为开发语言，最终编译为JavaScript，正好和原始版本PK一下。</p>
<p>游戏预览：<a href="http://xzper.com/project/2048egret/" target="_blank" rel="external">点我体验</a></p>
]]>
    
    </summary>
    
      <category term="Egret" scheme="http://xzper.com/tags/Egret/"/>
    
      <category term="Egret" scheme="http://xzper.com/categories/Egret/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[新手引导—脚本设计]]></title>
    <link href="http://xzper.com/2014/06/15/%E6%96%B0%E6%89%8B%E5%BC%95%E5%AF%BC%E2%80%94%E8%84%9A%E6%9C%AC%E8%AE%BE%E8%AE%A1/"/>
    <id>http://xzper.com/2014/06/15/新手引导—脚本设计/</id>
    <published>2014-06-14T19:49:56.000Z</published>
    <updated>2014-10-23T05:22:47.974Z</updated>
    <content type="html"><![CDATA[<p>最近在做游戏的新手引导模块。由于是关卡式的引导，所以很适合用读取引导脚本的方式来开发。</p>
<p><strong>脚本和命令配置</strong></p>
<a id="more"></a>
<p>程序中通过GuideLib这个类来解析命令配置和脚本。脚本以行为单位运行，每一行就是一条指令。每一条指令有指令的名称和指令的参数。就像下面这样。</p>
<pre><code><span class="tag">goto</span> <span class="tag">step</span><span class="pseudo">:+1</span>
<span class="tag">showArrow</span> <span class="tag">direction</span><span class="pseudo">:down</span> <span class="tag">position</span>:<span class="attr_selector">[200,300]</span> <span class="tag">clickRect</span>:<span class="attr_selector">[100,30]</span>
<span class="tag">delayCall</span> <span class="tag">step</span><span class="pseudo">:-1</span> <span class="tag">time</span><span class="pseudo">:2</span>
</code></pre><p>第一个单词表示命令名称，然后后面的参数以空格分开，参数名称和参数值用冒号分开。由若干条命令就组成了一个完整的脚本。但是光有脚本还是不够，从脚本里面我们看不出来参数的类型。比如position应该是一个Number数组，所以我们还需要一个配置文件来说明每一条命令的详细细节。这里配置文件用xml表示。</p>
<p><pre class="lang:xhtml decode:true">&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;commands&gt;<br>    &lt;command name=”goto”&gt;<br>        &lt;param name=”step” type=”String”/&gt;<br>    &lt;/command&gt;<br>    &lt;command name=”delayCall”&gt;<br>        &lt;param name=”step” type=”String”/&gt;<br>        &lt;param name=”time” type=”Number”/&gt;<br>    &lt;/command&gt;<br>    &lt;command name=”showArrow”&gt;<br>        &lt;param name=”direction” type=”String”/&gt;<br>        &lt;param name=”position” type=”Array_Number”/&gt;<br>        &lt;param name=”clickRect” type=”Array_Number”/&gt;<br>    &lt;/command&gt;<br>&lt;/commands&gt;</pre><br>可以看到param有一个type的属性用来说明参数类型。查看GuideLib的源代码会发现有一个ITypeAdapter，这个就是用来解析参数类型的，在解析脚本的时候，调用ITypeAdapter的convert方法自动将脚本中param的值由字符串转换为命令配置文件中的type。默认的类型解释器是TypeAdapter。</p>
<pre><code><span class="javadoc">/**
 * 将命令参数的值转换成正确的类型
 */</span>
public function convert(<span class="keyword">type</span>:String , value:String):*
{
    <span class="keyword">var</span> result:String = value;
    <span class="keyword">if</span>(<span class="keyword">type</span> == <span class="string">"String"</span>)
    {
        <span class="keyword">return</span> value;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">type</span> == <span class="string">"Boolean"</span>)
    {
        <span class="keyword">return</span> value==<span class="string">"true"</span>?<span class="keyword">true</span>:<span class="keyword">false</span>;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">type</span>.indexOf(<span class="string">"Array"</span>) == <span class="number">0</span>)
    {
        <span class="keyword">if</span>(<span class="keyword">type</span>.split(<span class="string">"_"</span>,<span class="number">2</span>).length&amp;lt;<span class="number">2</span>)
        {
            <span class="keyword">return</span> convertStringToArray(<span class="string">"String"</span> , value);
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">return</span> convertStringToArray(<span class="keyword">type</span>.split(<span class="string">"_"</span>)[<span class="number">1</span>] , value);
        }
    }
    <span class="keyword">else</span>
    {
        <span class="keyword">return</span> getDefinitionByName(<span class="keyword">type</span>)(value);
    }
}
</code></pre><p><strong>执行命令</strong></p>
<p>GuideLib将通过getScript将脚本解析成一个数组。每一个元素就是一条命令，然后交给GuideSystem去处理每一条命令。在GuideSystem中又可以看到一个ICommandAdapter。这个就是用来运行命令的解释器，调用run方法执行命令。默认的命令解释器是CommandAdapter。</p>
<pre><code><span class="javadoc">/**
 * 默认的函数库
 */</span>
<span class="keyword">private</span> var guideFunction:GuideFunction = <span class="keyword">new</span> GuideFunction();
<span class="javadoc">/**
 * 运行命令
 *<span class="javadoctag"> @param</span> command 命令的名称
 *<span class="javadoctag"> @param</span> param 命令的参数
 *<span class="javadoctag"> @param</span> guideSystem 向导管理
 */</span>
<span class="keyword">public</span> function <span class="title">run</span>(command:String, param:Object, guideSystem:GuideSystem):<span class="keyword">void</span>
{
    var fun:Function;
    <span class="keyword">if</span>(guideFunction.hasOwnProperty(command))  <span class="comment">//函数库中存在这个函数</span>
        fun = guideFunction[command];
    fun(param);
    <span class="keyword">if</span>(guideSystem.auto)
        guideSystem.doNext();
}
</code></pre><p>GuideFunction就是默认的函数库，如果命令配置是调用其他的类的函数，可以自己实现这个run方法。</p>
<p><strong>函数库的自定义</strong></p>
<p>脚本中的每一条命令实际上就是调用的某一个类的某一个函数。默认情况下这个类就是GuideFunction。所以我们要实现功能，为GuideFunction添加方法就行了。方法名保存和命令名一致，参数就是命令的参数组成的Object。例如delayCall这个命令的实现</p>
<pre><code><span class="comment">/**
 * 延时 多少秒执行哪一步
 */</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delayCall</span><span class="params">(param:Object)</span><span class="type">:void</span>
</span>{
    <span class="keyword">var</span> step:String = param[<span class="string">"step"</span>];
    <span class="keyword">var</span> time:Number = param[<span class="string">"time"</span>];
    GuideSystem.getInstance().auto = <span class="literal">false</span>;
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span><span class="type">:void</span></span>{
        GuideSystem.getInstance().auto = <span class="literal">true</span>;
        GuideSystem.getInstance().goto(step);
    } , time*<span class="number">1000</span>);
}
</code></pre><p>我们可以根据业务逻辑的不同，自由的定制参数类型解析器，命令函数解析器和函数库。</p>
<p><strong>脚本编辑器</strong></p>
<p>脚本编辑器是一个可视化的工具，能方便快速的创建脚本，你只需要先写好命令配置xml。编辑器会根据xml自动生成命令列表，然后向脚本中自由的加入命令。预览图：</p>
<p><img src="http://xzper.qiniudn.com/2014/06/editor.png" alt=""></p>
<p>新手引导示例：<a href="http://xzper.qiniudn.com/2014/06/Guide.rar" target="_blank" rel="external">Guide</a></p>
<p>脚本编辑器：<a href="http://xzper.qiniudn.com/2014/06/ScriptEditor.rar" target="_blank" rel="external">ScriptEditor</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在做游戏的新手引导模块。由于是关卡式的引导，所以很适合用读取引导脚本的方式来开发。</p>
<p><strong>脚本和命令配置</strong></p>
]]>
    
    </summary>
    
      <category term="未分类" scheme="http://xzper.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从2048游戏谈PureMVC]]></title>
    <link href="http://xzper.com/2014/04/27/%E4%BB%8E2048%E6%B8%B8%E6%88%8F%E8%B0%88PureMVC/"/>
    <id>http://xzper.com/2014/04/27/从2048游戏谈PureMVC/</id>
    <published>2014-04-26T18:03:56.000Z</published>
    <updated>2014-10-23T05:22:47.951Z</updated>
    <content type="html"><![CDATA[<p>最近2048比较火，然后我又正好在学习pureMVC，之前对于pureMVC的了解只停留在理论上，正好拿这个游戏来练练手。废话不多说，游戏预览：<a href="http://xzper.qiniudn.com/2014/04/2048flexlite/Main.html" target="_blank" rel="external">2048</a></p>
<a id="more"></a>
<p><strong>1.MVC的基本运行原理</strong></p>
<p><img src="http://xzper.qiniudn.com/2014/04/mvc结构图.png" alt="mvc结构图"></p>
<p><span style="font-family: 微软雅黑;"><span>图：</span></span><span><span style="font-family: Calibri;">MVC</span><span style="font-family: 微软雅黑;">结构图（实线——&gt;表示依赖；虚线</span><span style="font-family: Calibri;">——&gt;</span><span style="font-family: 微软雅黑;">表示事件</span><span style="font-family: Calibri;">/</span></span><span style="font-family: 微软雅黑;"><span>通知等</span><span>）</span></span></p>
<ul>
<li><p><strong>模型（Model）</strong> 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。“模型”有对数据直接访问的权力，例如对数据库的访问。“模型”不依赖“视图”和“控制器”，也就是说，模型不关心它会被如何显示或是如何被操作。但是模型中数据的变化一般会通过一种刷新机制被公布。为了实现这种机制，那些用于监视此模型的视图必须事先在此模型上注册，从而，视图可以了解在数据模型上发生的改变。（比较：<a href="http://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F" title="观察者模式" target="_blank" rel="external">观察者模式</a>（<a href="http://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" title="软件设计模式" target="_blank" rel="external">软件设计模式</a>））</p>
</li>
<li><p><strong>视图(View)</strong> 能够实现数据有目的的显示（理论上，这不是必需的）。在视图中一般没有程序上的逻辑。为了实现视图上的刷新功能，视图需要访问它监视的数据模型（Model），因此应该事先在被它监视的数据那里注册。</p>
</li>
<li><p><strong>控制器(Controller)</strong> 起到不同层面间的组织作用，用于控制应用程序的流程。它处理事件并作出响应。“事件”包括用户的行为和数据模型上的改变。</p>
</li>
</ul>
<p><strong>2.pureMVC中的Proxy,Mediator,Command</strong></p>
<ul>
<li><strong>Proxy数据层(Model)</strong> 由于数据不关心视图是如何显示的，所以如果数据改变了引起了视图的改变，为了做到解耦，Proxy通过sendNotification方法向视图(Mediator)或者控制器(Command)发送通知，而不是获取视图实例调用里面的方法，通知发出去了Proxy的任务就完成了。另外Proxy通常还提供一些公共方法(public function)供控制器(Command)直接调用，从而改变数据（<strong>注意：Proxy是不接收Notification的</strong>）。</li>
<li><strong>Mediator视图层(View)</strong> 中介器(Mediator)持有对应视图的引用，他负责接收消息和发送消息，所以一般情况下Mediator只含有处理消息和发送消息的代码，不会有复杂的逻辑处理，逻辑处理放在视图组件(viewComponent)里面（<strong>注意：如果你的Mediator含有过多的公共方法不用想肯定有问题</strong> ）。当数据改变，Mediator收到消息时，调用viewComponent暴露的公共方法，处理视图的改变。另外，Mediator可以为视图组件添加事件监听器(addEventListener),发送消息(sendNotification)通知控制器(Command)视图的改变，而不是直接调用Proxy的公共方法改变数据。</li>
<li><strong>Command控制器(Controller)</strong> 这个的使用比较灵活。最常用的就是收到Mediator发来的消息，调用Proxy的公共方法改变数据。还有可能是收到某一个Proxy的消息，调用另外一个Proxy改变数据等等。他起到了一个桥梁的作用。协调Mediator和Proxy，Proxy1和Proxy2，Mediator1和Mediator2。所以Command也不应该有复杂的逻辑。</li>
</ul>
<p><strong>3.从实例学习pureMVC</strong></p>
<p>先来看下工程目录结构</p>
<p><img src="http://xzper.qiniudn.com/2014/04/2048工程结构.png" alt="2048工程结构"></p>
<p><strong>1.xxxPrepCommand</strong> 框架初始化时，注册对应必须的Command和Proxy。（另外说下由于FlexLite的组件需要在CreateComplete才能获取皮肤实例，所以Mediator的注册都是在viewComponent中完成的）</p>
<p><strong>2.GameCommand</strong> 处理各类事务。比如 玩家按下了方向键，收到消息调用GridProxy的移动方法改变数据，比如GridProxy移动格子分数改变了，通知GameCommand 调用GameProxy的更新分数方法改变分数，比如处理重置游戏的事务，通知各个数据模块重置数据</p>
<p><strong>3.GameProxy</strong> 处理游戏数据，比如更新分数，处理游戏结果</p>
<p><strong>4.GridProxy</strong> 这个游戏的核心数据，操作每一个格子的数据，通知视图格子的移动，添加，删除，重置</p>
<p><strong>5.ApplicationMediator</strong> 监听键盘事件发送消息到GameCommand通知移动</p>
<p><strong>6.MainGameMediator</strong> 接收消息，调用MainGameUI的方法处理格子的移动，添加，删除，重置，以及接收游戏结果，显示结果面板</p>
<p><strong>7.**</strong>MainMenuMediator** 接收更新分数的消息，调用MainGameUI的方法更新分数与重置</p>
<p><strong>8.ResultWindowMediator</strong> 发送游戏重置的消息，以及自销毁。这是一个短生命的Mediator</p>
<p>其实这个游戏本来一开始我是用Flex开发的，最后完成的时候发现swf太大加载太慢，于是换成了比较小巧的FlexLite。整个移植过程没有动Model和Controller的一行代码，Mediator改动的也很少。充分说明了MVC的代码重用和关注点分离。这也是我用pureMVC的初次尝试，可能理解还有很多不到位和错误的地方，在此抛砖引玉。最后附上源代码下载：</p>
<p>FlexLite版：<a href="http://xzper.qiniudn.com/2014/04/2048flexlite.rar" target="_blank" rel="external">2048flexlite</a></p>
<p>Flex版：<a href="http://xzper.qiniudn.com/2014/04/2048flex.rar" target="_blank" rel="external">2048flex</a></p>
<p>参考文章：</p>
<p>[1] <a href="http://www.cnblogs.com/skynet/archive/2012/12/29/2838303.html" target="_blank" rel="external">http://www.cnblogs.com/skynet/archive/2012/12/29/2838303.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近2048比较火，然后我又正好在学习pureMVC，之前对于pureMVC的了解只停留在理论上，正好拿这个游戏来练练手。废话不多说，游戏预览：<a href="http://xzper.qiniudn.com/2014/04/2048flexlite/Main.html" target="_blank" rel="external">2048</a></p>
]]>
    
    </summary>
    
      <category term="puremvc" scheme="http://xzper.com/tags/puremvc/"/>
    
      <category term="框架" scheme="http://xzper.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在路上]]></title>
    <link href="http://xzper.com/2014/04/21/%E5%9C%A8%E8%B7%AF%E4%B8%8A/"/>
    <id>http://xzper.com/2014/04/21/在路上/</id>
    <published>2014-04-21T15:51:00.000Z</published>
    <updated>2014-10-23T05:22:47.954Z</updated>
    <content type="html"><![CDATA[<p>博客建站以来也快有一个月了，每次想写点什么都不得而终。究其原因还是自己太懒了。所以现在趁自己不懒的时候，记录自己在前端开发路上的点滴。 希望此文能做一个好的开始，以此共勉。</p>
<p>Flash开发到了如今，也到了日落西山，穷途末路的时候吧。从官方上来看，Adobe已经对Flash力不从心了，停止了移动端的FP的更新 ，把Flex捐给了Apache 。从开发者来看，大量新技术如Html5，Cocos2d，Unity3D的出现让开发者有了更多的选择，好多Flash老程序员都转行了，这似乎成了一个趋势  。 从市场上来看，如今的页游市场，已经不复当年的辉煌了，前篇一律的感觉玩家会卖账么？而且各种坑爹的运营导致Flash游戏的名声越来越臭。总之，对于即将毕业的我选择Flash开发这条路显然不是一个明智的选择。</p>
<a id="more"></a>
<p>但是对于一个能把一件衣服从新买到一直穿到破的人来说，东西用惯了想换下来，不是那么容易的。至少目前这件衣服对于我来说还是新的就足够了，穿破了再说。我喜欢AS3，喜欢Flex，喜欢Flash这就够了。再说程序员都认为自己使用的语言是最NB的，讨论哪种语言的好坏根本没有意义。</p>
<p>从2012年5月到现在，接触Flash编程也快有2年了。然而看了看Flash的<a href="http://www.xmind.net/m/bCk4/" target="_blank" rel="external">技能树</a>当真自愧不如。最近没事的时候我喜欢反编译一些看起来不错的游戏和软件，看着别人的代码，体会别人的开发思路。收获不少，同时也在感叹自己会的东西太少了。我发现，看博客，看开源项目或者成熟的商业作品的源码对自己的提升很有用。之前1年的学习可能仅仅只是让我上路了，知道怎么写代码，如何实现。但这些显然是不够的，要真真的独当一面要会的东西还有太多。</p>
<p>对于前端开发，一些人认为就是显示下界面，放放特效之类的，其实哪有那么简单。这里按照技能书大致列举下我做前端的过程自己会与不会的知识。认为写前端很轻松的可以体会下。</p>
<p><strong>1.显示对象基础</strong>。其实大多人对前端的认识也就留在这一块了。以为也就是操作下显示对象，把数据显示出来。且不说下面的11条，就这一条，也不是一个人能半年之内搞精通的。这个是基础，至少目前我还不能在不看API的情况下说出每一个显示对象的属性和方法，以及应用。</p>
<p><strong>2.特效和动画</strong>。对于一部分特效我们搞开发的做不来，还得交给美工特效大大们去做，还有一部分特效是可以用代码写的。那我们需要知道什么，做什么呢。1.矢量动画和帧动画的区别。2.如何用代码写动画，比如各类缓动，各类滤镜动画，Bitmap操作，Matrix操作等等。目前比较流行的动画开源库和引擎有，TweenLite(感觉体积比较大，所以一般自己实现)，SpriteSheet ，DragonBones，这2个久仰大名有待学习。还有个PixelBender也是最近才知道的，搞的是高级图像处理，渣渣表示学不来。</p>
<p><strong>3.媒体处理</strong>。之前写组件的时候写过音视频播放啊之类的(最近在倒腾bilibili的弹幕播放器，不弄不知道一弄才发现很是复杂。关于视频流的分段处理，流的数据生成模式，与主流视频网站的对接看的头都大了) ，后来接触到了FMS，玩过P2P通讯的视频语音文字图片文件的共享与收发，其实这也只是冰山一角。FMS主要的在于直播，点播方面比较好用。至于那些编码处理之类的那我也只是只闻其名了。媒体处理类的坑很深估计掉下去了就爬不起来了。</p>
<p><strong>4.文本处理</strong>。文本引擎FTE和TLF，看名字就看晕了。TLF是基于FTE的，对FTE做了一次封装，感觉这和Adobe的OSMF是基于底层的媒体处理类似。这些目前没有深入了解。对于一般的文本处理，目前遇到的图文混排算上要求最高的吧，我用的是RichTextField解决的，感觉还不错。最近关于文本的敏感词过滤好像也是要学的。</p>
<p><strong>5.网络通信</strong>。资源类，各种Loader的使用，不过这些东西在项目里面最好做一下封装，目前比较喜欢用的是FlexLite里面的加载器感觉封装的比较彻底。流处理，URLStream啊NetStream这类的东西很多。后台交互，Socket，AMF(这个比较好用，用来实现HTTP通讯，实际上Flex的RemoteObject就是基于这个的)，另外还有RTMP，RTMFP协议，FMS上面用到的。</p>
<p><strong>6.文件访问</strong>。在web上面的文件访问用FileReference来进行读写，可惜是需要把整个文件加载到浏览器内存才能操作。air的文件读写不用。ShareObject的使用俗称FlashCookie，存一些简单信息比较好用。对象序列化反序列化的ByteArray操作，文件操作少不了这个的。以及反射的使用。还有恶心的Flash跨域问题。</p>
<p><strong>7.性能优化</strong>。每个ASer都在与名为性能的怪物战斗。这方面需要了解Flash的垃圾回收机制。常用的优化技巧有 ，事件的监听和移除，强引用弱引用，总之就是想办法去除不必要的引用，以便垃圾回收器能回收对象实例防止内存泄露。对于CPU的优化，主要是渲染方式的优化，像bitmap几个方法的快慢啊，矢量图与位图的区别啊。还有一些框架优化这类的。</p>
<p><strong>8.flex</strong>。由于项目需要我完整的学习了FlexLite这个框架，核心思想就是Flex来的。我很喜欢这种架构设计(第2次说了)，他的组件生命周期，3层验证失效机制，布局管理，皮肤适配，UI层管理。无论哪一个拿出来都要说好久。所以这里就不说了，有时间单独补上。</p>
<p><strong>9.air</strong>。air里面有很多新的东西我都没接触到，这个也是一个领域啊。不过我还是更喜欢web开发一下。</p>
<p><strong>10.图形基础</strong>。说是图形基础，对于我这个色盲来说，真的很难。什么色相，颜色矩阵，Bitmap操作什么的有待学习，教材已经订好，ActionScript3.0图像处理基础教程，根本一点都不基础好么。</p>
<p><strong>11.架构设计</strong>。这也是目前我着重学习的，毕竟一个人要想独当一面这个东西不可或缺。目前很好的一个学习办法就是阅读商业项目的成熟代码去体会，然后在平时的码码中实际应用上去。</p>
<p><strong>12.开源库</strong>。一个纯OOP开发语言当然离不开各类开源库以及引擎。上面说的几个是做动画用的比较多的开源库。像 UI框架之类的有,官方的<code>Flex</code>(Flex的架构设计简直赞，第3次了喂，可惜体积太大了), <code>Aswing</code>(没用过不说了) , <code>FlexLite</code> (DOM大大开发的UI框架，包含了Flex4的精髓) ，<code>Features</code>(和<code>Starling</code>配合)。物理引擎有 <code>Box2D</code> ， <code>Nape</code>，这部分我暂时没接触。3D引擎有官方的3d底层Stage3D , 以及<code>Away3D</code> ，<code>PV3D</code> , <code>Flar3D</code> ，这些我都鲜有接触。MVC框架有 官方的<code>Cairngorm</code>(据说太大，所以应用的不是很广) ， <code>pureMVC</code>(最近看的比较多的，蛮不错)，<code>Robotlegs</code>(貌似比前者好，最近准备学)。游戏引擎类的有 <code>Starling</code>(移动平台应用比较多，没时间学) ， <code>D5Power</code>(国人开发的rpg引擎，比较感兴趣，很有可能是我以后学rpg开发的敲门砖)。还有各种开源的小组件，开源的工具库这些的，都是每个Aser或多或少需要了解的东西，如果能深入理解源码那就更好了。</p>
<p>还有很多知识都是没有涉及到的比如各类游戏算法啊，工具啊之类的。<strong>希望此文能为我自己立一面旗帜(俗称立Flag)，在今后的学习路上，像这面旗帜看齐，总之，那句话怎么说来着，我不在乎路的尽头有什么，我只在乎路边的风景，路还很长，且行且珍惜</strong>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>博客建站以来也快有一个月了，每次想写点什么都不得而终。究其原因还是自己太懒了。所以现在趁自己不懒的时候，记录自己在前端开发路上的点滴。 希望此文能做一个好的开始，以此共勉。</p>
<p>Flash开发到了如今，也到了日落西山，穷途末路的时候吧。从官方上来看，Adobe已经对Flash力不从心了，停止了移动端的FP的更新 ，把Flex捐给了Apache 。从开发者来看，大量新技术如Html5，Cocos2d，Unity3D的出现让开发者有了更多的选择，好多Flash老程序员都转行了，这似乎成了一个趋势  。 从市场上来看，如今的页游市场，已经不复当年的辉煌了，前篇一律的感觉玩家会卖账么？而且各种坑爹的运营导致Flash游戏的名声越来越臭。总之，对于即将毕业的我选择Flash开发这条路显然不是一个明智的选择。</p>
]]>
    
    </summary>
    
      <category term="感悟" scheme="http://xzper.com/categories/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
</feed>
