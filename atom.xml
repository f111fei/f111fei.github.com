<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[xzper]]></title>
  <subtitle><![CDATA[前行在被夕阳染红的街道]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xzper.com/"/>
  <updated>2014-09-05T16:04:55.616Z</updated>
  <id>http://xzper.com/</id>
  
  <author>
    <name><![CDATA[xzper]]></name>
    <email><![CDATA[f111fei1@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[分享一个小巧的快捷键管理工具类]]></title>
    <link href="http://xzper.com/2014/09/04/%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://xzper.com/2014/09/04/快捷键管理/</id>
    <published>2014-09-04T13:58:03.000Z</published>
    <updated>2014-09-05T16:01:58.000Z</updated>
    <content type="html"><![CDATA[<p>最近要完成软件中的快捷键模块。基本需求就是能做到让用户自由设置。基本之前的所有按键都是写死在代码中的，就像下面这样糟糕：</p>
<pre><code><span class="keyword">this</span>.addEventListener(KeyboardEvent.KEY_DOWN,onKeyDown);

<span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onKeyDown</span><span class="params">(event:KeyboardEvent)</span><span class="type">:void</span>
</span>{
    <span class="keyword">if</span>(event.keyCode==Keyboard.S&amp;&amp;event.ctrlKey)
    {
        ...dosomething
    }
}
</code></pre><a id="more"></a>

<p>这样写是无法做到在后期维护中把快捷键分离出来让用户自由设置的。而且会造成代码冗余，比如这个面板需要Ctrl+S执行保存操作，那个面板也需要Ctrl+S执行那个面板的保存操作。这样Ctrl+S这种组合的快捷键每个面板都需要判断一下，这样相同的逻辑判断会多次出现。还有一种比较严格的情况，比如上面的那种判断严格意义上来讲是不能判断Ctrl+S的，因为用户可能同时也按下了Shift键或者Alt键，那这样这个判断要完全写对，代码量又要多不少。</p>
<p>比较好的解决方式是使用一个快捷键管理类Shortcut，统一管理这些操作。在程序初始化的时候注入快捷键的映射，然后在各个面板注册需要响应的事件类型以及对应的函数。比如一个Ctrl+S的操作可以这样表示：</p>
<p>程序初始化的时候，添加快捷键映射</p>
<pre><code>Shortcut.addBinding(<span class="string">"save"</span> , [Keyboard.S , Keyboard.CONTROL]);
</code></pre><p>具体的面板注册监听事件</p>
<pre><code>Shortcut.addRegister(<span class="keyword">this</span> , “save” , onShortcut);
</code></pre><p><code>addBinding</code>这个方法第一个参数就是事件类型，第二个类型就是事件对应的按键，用一个数组表示，可以是多个具体的解析交由Shortcut实现。</p>
<p><code>addRegister</code>这个方法第一个参数就是要监听这个事件的对象，第二个参数是监听的类型，第三个参数是对应的回调函数。当然只有满足了按键条件才会触发这个回调函数。</p>
<p>这样具体的按键事件监听，按键逻辑都交由Shortcut这个管理类去实现。要响应事件的对象不再需要去写繁琐的事件监听与逻辑判断了。这个面板只关心save这个事件，而不关心按了什么键，这样解耦了按键事件与面板的关系。用户如果需要改变快捷键，只需要改变那个binding的映射表就行了，具体的面板不需要任何改变。</p>
<p>当然基于以上两个方法我们可以继续添加扩展，比如批量初始化快捷键映射</p>
<pre><code>Shortcut.addBindindBatch(config);
</code></pre><p>这种方式可以用于初始化的时候或者用户修改了快捷键的时候，传入一个映射表配置就行了。</p>
<p>事件的类型也可以从简单的字符串变为一个静态常量，比如可以定义一个ShortcutType类存放这些事件：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortcutType</span>
</span>{
    <span class="javadoc">/**
     * 保存
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">const</span> SAVE:String = <span class="string">"save"</span>;
}
</code></pre><p>基本上API就是这样，使用很简单，也很灵活。然后是重点<code>No Code You Say A Diao</code></p>
<pre><code><span class="package"><span class="keyword">package</span> <span class="title">code</span>.<span class="title">common</span>.<span class="title">keyboard</span>
{</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.display.InteractiveObject;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.display.Stage;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.events.Event;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.events.FocusEvent;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.events.KeyboardEvent;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.ui.Keyboard;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.utils.Dictionary;</span>

    <span class="comment">/**
     * 快捷键管理类， 执行initialize初始化一个全局管理。
     * &lt;br&gt;使用 addBinding 添加一个事件类型 与 按键的绑定
     * &lt;br&gt;使用 addRegister 注册一个监听对象
     * &lt;br&gt;下面是一个简单的使用例子
     * &lt;code&gt;
     *    &lt;br&gt;Shortcut.addBinding("example" , [Keyboard.S , Keyboard.CONTROL]);
     *    &lt;br&gt;Shortcut.addRegister(this , "example" , onSave);
     * &lt;/code&gt;
     */</span>
    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shortcut</span>
    </span>{
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Shortcut</span><span class="params">(stage:Stage)</span>
        </span>{
            stage.addEventListener(KeyboardEvent.KEY_DOWN,onStageKeyDown,<span class="literal">true</span>,<span class="number">2000</span>);
            stage.addEventListener(KeyboardEvent.KEY_UP,onStageKeyUp,<span class="literal">true</span>,<span class="number">2000</span>);
            stage.addEventListener(FocusEvent.FOCUS_OUT,onDeactive);
        }

        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> instance:Shortcut;
        <span class="comment">/**
         * 初始化
         */</span>        
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">initialize</span><span class="params">(stage:Stage)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">if</span>(instance)
                <span class="keyword">return</span>;
            instance = <span class="keyword">new</span> Shortcut(stage);
        }

        <span class="comment">/**
         * @copy  Shortcut#addRegister()
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">addRegister</span><span class="params">(target:InteractiveObject , type:String , callBack:Function)</span><span class="type">:void</span>
        </span>{
            instance.addRegister(target , type , callBack);
        }

        <span class="comment">/**
         * @copy  Shortcut#removeRegister()
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">removeRegister</span><span class="params">(target:InteractiveObject , type:String , callBack:Function)</span><span class="type">:void</span>
        </span>{
            instance.removeRegister(target , type , callBack);
        }

        <span class="comment">/**
         * 移除一个对象所有注册的快捷键
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">removeTargetRegister</span><span class="params">(target:InteractiveObject)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">if</span>(instance.targetDic[target])
            {
                <span class="keyword">var</span> shortcutMapList:Array = instance.targetDic[target];
                <span class="keyword">for</span> <span class="keyword">each</span> (<span class="keyword">var</span> shortcutMap:ShortcutMap <span class="keyword">in</span> shortcutMapList) 
                {
                    instance.removeRegister(target , shortcutMap.type , shortcutMap.callBack);
                }
            }
        }

        <span class="comment">/**
         * @copy  Shortcut#addBinding()
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">addBinding</span><span class="params">(type:String , keyCodeValue:Array)</span><span class="type">:void</span>
        </span>{
            instance.addBinding(type , keyCodeValue);
        }

        <span class="comment">/**
         * 批量添加绑定事件类型 与 按键值的映射
         * @param data 数据中的每一项格式参照addBinding方法中的参数
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">addBindindBatch</span><span class="params">(data:Object)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">for</span> (<span class="keyword">var</span> key:String <span class="keyword">in</span> data) 
            {
                instance.addBinding(key , data[key]);
            }
        }

        <span class="comment">/**
         * @copy  Shortcut#removeBinding()
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">removeBinding</span><span class="params">(type:String)</span><span class="type">:void</span>
        </span>{
            instance.removeBinding(type);
        }

        <span class="comment">/**
         * 移除所有的事件类型
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">removeAllBinding</span><span class="params">()</span><span class="type">:void</span>
        </span>{
            instance.bindingDic = <span class="keyword">new</span> Dictionary();
        }

        <span class="comment">/**
         * 判断指定键是否按下
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">isKeyDown</span><span class="params">(keyCode:uint)</span><span class="type">:Boolean</span>
        </span>{
            <span class="keyword">return</span> instance.isKeyDown(keyCode);
        }


        <span class="comment">//======================== 快捷键相关=====================start=======================</span>

        <span class="comment">/**
         * 监听快捷键的对象 与 持有的注册列表字典
         */</span>
        <span class="keyword">private</span> <span class="keyword">var</span> targetDic:Dictionary = <span class="keyword">new</span> Dictionary(<span class="literal">true</span>);

        <span class="comment">/**
         * 事件类型 与 具体按键值的关系映射表
         */</span>
        <span class="keyword">private</span> <span class="keyword">var</span> bindingDic:Dictionary = <span class="keyword">new</span> Dictionary();

        <span class="comment">/**
         * 注册一个监听对象
         * @param target 监听事件的目标对象
         * @param type 按键要触发的事件类型
         * @param callBack 回调函数示例：不含参数 callBack():void
         * 带一个参数callBack(type:String):void , 带两个参数callBack(type:String , event:KeyboardEvent):void
         */</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addRegister</span><span class="params">(target:InteractiveObject , type:String , callBack:Function)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">if</span>(getRegisterIndex(target , type , callBack) &gt;= <span class="number">0</span>)
            {
                <span class="keyword">return</span>;
            }
            <span class="keyword">if</span>(targetDic[target] === <span class="literal">undefined</span>)
            {
                targetDic[target] = [];
                target.addEventListener(KeyboardEvent.KEY_DOWN , onKeyDown , <span class="literal">false</span> ,<span class="number">0</span> , <span class="literal">true</span>);
            }
            <span class="keyword">var</span> map:ShortcutMap = <span class="keyword">new</span> ShortcutMap();
            map.type = type;
            map.callBack = callBack; 
            targetDic[target].push(map);
        }

        <span class="comment">/**
         * 移除一个监听对象
         * @param target 监听事件的目标对象
         * @param type 按键要触发的事件类型
         * @param callBack 回调函数
         */</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">removeRegister</span><span class="params">(target:InteractiveObject , type:String , callBack:Function)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">var</span> registerIndex:int = getRegisterIndex(target , type , callBack);
            <span class="keyword">if</span>(registerIndex &gt;= <span class="number">0</span>)
            {
                <span class="keyword">var</span> shortcutMapList:Array = targetDic[target];
                shortcutMapList.splice(registerIndex , <span class="number">1</span>);
                <span class="keyword">if</span>(shortcutMapList.length == <span class="number">0</span>)
                {
                    target.removeEventListener(KeyboardEvent.KEY_DOWN , onKeyDown);
                    <span class="keyword">delete</span> targetDic[target];
                }
            }
        }

        <span class="comment">/**
         * 测试是否注册了指定类型的指定方法，并返回注册的索引
         */</span>
        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">getRegisterIndex</span><span class="params">(target:InteractiveObject , type:String , callBack:Function)</span><span class="type">:int</span>
        </span>{
            <span class="keyword">if</span>(targetDic[target])
            {
                <span class="keyword">var</span> shortcutMapList:Array = targetDic[target];
                <span class="keyword">var</span> shortcutMap:ShortcutMap;
                <span class="keyword">for</span> (<span class="keyword">var</span> i:int = <span class="number">0</span>; i &lt; shortcutMapList.length; i++) 
                {
                    shortcutMap = shortcutMapList[i] <span class="keyword">as</span> ShortcutMap;
                    <span class="keyword">if</span>(shortcutMap.type == type &amp;&amp; shortcutMap.callBack == callBack)
                    {
                        <span class="keyword">return</span> i;
                    }
                }
            }
            <span class="keyword">return</span> -<span class="number">1</span>;
        }

        <span class="comment">/**
         * 绑定一个事件类型 与 按键值的映射
         * @param type  事件类型
         * @param keyCodeValue 按下的键的对象， 可以是一个数组也可以每一项是一个数组，数组中的元素对应Keyboard中的常量
         *     &lt;br/&gt;如果数组的长度等于1，则 按照对应的键值触发事件
         * &lt;br/&gt;如果数组的长度大于1，则 按照数组中的第一项对应的键值触发事件，其他的键为触发事件需要按下的键
         * &lt;br/&gt;下面是一些例子
         * &lt;code&gt;
         *    &lt;br&gt;[Keyboard.S , Keyboard.CONTROL] 表示 Ctrl+S
         *    &lt;br&gt;[[Keyboard.BACKSPACE] , [Keyboard.DELETE]] 表示退格或者删除
         * &lt;/code&gt;
         */</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addBinding</span><span class="params">(type:String , keyCodeValue:Array)</span><span class="type">:void</span>
        </span>{
            bindingDic[type] = keyCodeValue;
        }

        <span class="comment">/**
         * 移除一个事件类型
         */</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">removeBinding</span><span class="params">(type:String)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">if</span>(bindingDic[type])
            {
                <span class="keyword">delete</span> bindingDic[type];
            }
        }

        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onKeyDown</span><span class="params">(event:KeyboardEvent)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">var</span> shortcutMapList:Array = targetDic[event.currentTarget];
            <span class="keyword">if</span>(!shortcutMapList || shortcutMapList.length &lt; <span class="number">1</span>)
                <span class="keyword">return</span>;

            <span class="keyword">var</span> shortcutMap:ShortcutMap;
            <span class="keyword">for</span> (<span class="keyword">var</span> i:int = <span class="number">0</span>; i &lt; shortcutMapList.length; i++) 
            {
                shortcutMap = shortcutMapList[i] <span class="keyword">as</span> ShortcutMap;
                <span class="keyword">var</span> keyCodeValue:Array = bindingDic[shortcutMap.type];
                <span class="keyword">var</span> result:Boolean = <span class="literal">false</span>;
                <span class="keyword">if</span>(keyCodeValue[<span class="number">0</span>] <span class="keyword">is</span> Array)
                {
                    <span class="keyword">for</span> <span class="keyword">each</span> (<span class="keyword">var</span> keyCodeArray:* <span class="keyword">in</span> keyCodeValue) 
                    {
                        <span class="keyword">if</span>(keyCodeArray <span class="keyword">is</span> uint)
                            result = check(event , [keyCodeArray]);
                        <span class="keyword">else</span>
                            result = check(event , keyCodeArray);
                        <span class="keyword">if</span>(result)
                            <span class="keyword">break</span>;
                    }
                }
                <span class="keyword">else</span>
                {
                    result = check(event , keyCodeValue);
                }
                <span class="keyword">if</span>(result)
                {
                    <span class="keyword">if</span>(shortcutMap.callBack.length == <span class="number">0</span>)
                        shortcutMap.callBack();
                    <span class="keyword">else</span> <span class="keyword">if</span>(shortcutMap.callBack.length == <span class="number">1</span>)
                        shortcutMap.callBack(shortcutMap.type);
                    <span class="keyword">else</span> <span class="keyword">if</span>(shortcutMap.callBack.length == <span class="number">2</span>)
                        shortcutMap.callBack(shortcutMap.type , event);
                    <span class="keyword">else</span>
                        shortcutMap.callBack();
                }
            }
        }

        <span class="comment">/**
         * 检查事件是否符合指定按键
         */</span>
        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">check</span><span class="params">(event:KeyboardEvent , keyCodeArray:Array)</span><span class="type">:Boolean</span>
        </span>{
            <span class="keyword">if</span>(!keyCodeArray || keyCodeArray.length &lt; <span class="number">0</span>)
                <span class="keyword">return</span> <span class="literal">false</span>;
            <span class="keyword">if</span>(event.keyCode == keyCodeArray[<span class="number">0</span>])
            {
                <span class="keyword">if</span>(keyCodeArray.length == <span class="number">1</span>)
                {
                    <span class="keyword">return</span> <span class="literal">true</span>;
                }
                <span class="keyword">else</span>
                {
                    <span class="keyword">var</span> firstKey:uint = keyCodeArray[<span class="number">0</span>];
                    <span class="keyword">var</span> hopeKeys:Array = keyCodeArray.concat();
                    <span class="keyword">var</span> allDownkeyCodes:Array = compositeKeys(event);
                    <span class="keyword">if</span>(allDownkeyCodes.indexOf(firstKey)&lt;<span class="number">0</span>)
                        allDownkeyCodes.push(firstKey);

                    <span class="keyword">if</span>(hopeKeys.length != allDownkeyCodes.length)
                        <span class="keyword">return</span> <span class="literal">false</span>;

                    hopeKeys.sort();
                    allDownkeyCodes.sort();

                    <span class="keyword">for</span> (<span class="keyword">var</span> i:int = <span class="number">0</span>; i &lt; hopeKeys.length; i++) 
                    {
                        <span class="keyword">if</span>(hopeKeys[i] != allDownkeyCodes[i])
                        {
                            <span class="keyword">return</span> <span class="literal">false</span>;
                        }
                    }
                    <span class="keyword">return</span> <span class="literal">true</span>;
                }
            }
            <span class="keyword">return</span> <span class="literal">false</span>;
        }

        <span class="comment">/**
         * 获取按下的组合键
         */</span>
        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">compositeKeys</span><span class="params">(event:KeyboardEvent)</span><span class="type">:Array</span>
        </span>{
            <span class="keyword">var</span> keys:Array = [];
            <span class="keyword">if</span>(event.altKey)
                keys.push(Keyboard.ALTERNATE);
            <span class="keyword">if</span>(event.shiftKey)
                keys.push(Keyboard.SHIFT);
            <span class="keyword">if</span>(event.controlKey)
                keys.push(Keyboard.CONTROL);
            <span class="keyword">if</span>(event.commandKey)
                keys.push(Keyboard.COMMAND);
            <span class="keyword">return</span> keys;
        }

        <span class="comment">//======================== 快捷键相关=====================end=======================</span>

        <span class="comment">//======================== 全局舞台按键 =====================start=======================</span>

        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onDeactive</span><span class="params">(event:Event)</span><span class="type">:void</span>
        </span>{
            downKeyCodes = <span class="keyword">new</span> Dictionary();
        }
        <span class="comment">/**
         * 按下的键代码列表
         */</span>        
        <span class="keyword">private</span> <span class="keyword">var</span> downKeyCodes:Dictionary = <span class="keyword">new</span> Dictionary();

        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onStageKeyDown</span><span class="params">(event:KeyboardEvent)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">var</span> keyCode:uint = event.keyCode;
            downKeyCodes[keyCode] = <span class="literal">true</span>;
        }

        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onStageKeyUp</span><span class="params">(event:KeyboardEvent)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">var</span> keyCode:uint = event.keyCode;
            <span class="keyword">if</span>(downKeyCodes[keyCode])
                <span class="keyword">delete</span> downKeyCodes[keyCode];
        }

        <span class="comment">/**
         * 是否按下了指定键
         */</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isKeyDown</span><span class="params">(keyCode:uint)</span><span class="type">:Boolean</span>
        </span>{
            <span class="keyword">return</span> Boolean(downKeyCodes[keyCode]);
        }

        <span class="comment">//======================== 全局舞台按键 =====================end=======================</span>

    }
}

<span class="class"><span class="keyword">class</span> <span class="title">ShortcutMap</span>
</span>{
    <span class="comment">/**
     * 事件类型
     */</span>
    <span class="keyword">public</span> <span class="keyword">var</span> type:String;

    <span class="comment">/**
     * 回调函数
     */</span>
    <span class="keyword">public</span> <span class="keyword">var</span> callBack:Function;
}
</code></pre><p>基本上代码已经说明一切了。主要思路就是给注册的对象监听一个KeyDown事件，在事件内部判断有哪些键按下了，是否符合这个对象某一个注册了的事件对应的按键映射，如果有就执行回调。</p>
<p>有一个关键点，给对象监听的按键事件<code>useWeakReference = true</code> 以及 <code>targetDic</code>也是使用了弱引用。只有这样我们无须手动调用<code>removeRegister</code>，当对象的引用计数为0时，就会被垃圾回收器GC自动回收了，不用担心内存泄露。</p>
<p>另外，这个工具类一开始需要传入一个舞台对象<code>stage</code>进行初始化，这个主要是用于保存一个全局有那些键是被按下了，就是后面那一段代码。这一段可有可无，主要是提供一个公共方法外界可以获取哪些键按下了。</p>
<p>基本上这个Shortcut已经能够满足大多数需求了。之前看过几个快捷键管理的工具类都是直接监听舞台上的事件，这个是有问题的。因为有些情况下，快捷键是针对指定面板的，当焦点不在面板上时快捷键是不起作用的，所以<code>removeRegister</code>这个方法的第一个参数就是设置快捷键应用的对象。<br>这个也能实现同一个事件可以注册给不同的对象，也可以一个对象注册同一个事件但是有不同的回调。就是说同一个快捷键可以给不同面板，同一个面板同一个快捷键也可以响应多个回调。</p>
<p>另外还支持一个事件多种快捷键，比如一个type为delete的事件，可以这样定义</p>
<pre><code>Shortcut.binding(<span class="string">"delete"</span> , <span class="string">[[Keyboard.BACKSPACE] , [Keyboard.DELETE]]</span>)
</code></pre><p>使用一个二维数组，每一个数组表示一组快捷键。delete事件既可以是退格键也可以是删除键。</p>
<p>再一个就是快捷键冲突的问题，同一个快捷键可以派发不同的事件。这种设计也是允许冲突的，因为有可能事件的对象不同，比如面板1里面Ctrl+S是保存，面板2里面Ctrl+S是删除一行，也就不冲突了。</p>
<p>差不多就这些啦。这个类可以拿来直接用，没有和其他的类耦合，也不需要定义接口啥的。另外，这些东西真的要到项目前期规划好，不然到了后面想改都蛋疼。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近要完成软件中的快捷键模块。基本需求就是能做到让用户自由设置。基本之前的所有按键都是写死在代码中的，就像下面这样糟糕：</p>
<pre><code><span class="keyword">this</span>.addEventListener(KeyboardEvent.KEY_DOWN,onKeyDown);

<span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onKeyDown</span><span class="params">(event:KeyboardEvent)</span><span class="type">:void</span>
</span>{
    <span class="keyword">if</span>(event.keyCode==Keyboard.S&amp;&amp;event.ctrlKey)
    {
        ...dosomething
    }
}
</code></pre>]]></summary>
    
      <category term="ActionScript3" scheme="http://xzper.com/categories/ActionScript3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析Hexo的Generate命令]]></title>
    <link href="http://xzper.com/2014/08/17/%E6%B5%85%E6%9E%90Hexo%E7%9A%84Generate%E5%91%BD%E4%BB%A4/"/>
    <id>http://xzper.com/2014/08/17/浅析Hexo的Generate命令/</id>
    <published>2014-08-16T22:54:10.000Z</published>
    <updated>2014-08-24T08:37:44.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/hexojs/hexo" target="_blank" rel="external">Hexo</a>是一个轻量级的静态博客站点生成框架，使用NodeJS开发。经过我两个通宵的努力总算把这个东西研究了一个大概，这里拿来分享一下。</p>
<a id="more"></a>

<h2 id="Processor">Processor</h2>
<p><a href="http://hexo.io/docs/plugins.html#Processor" target="_blank" rel="external">Processor</a>决定文件按照何种方式处理。在lib/plugins/processor文件夹下可以看到默认的处理方式。Processor在该模块的index.js中注册，默认的有下面几种</p>
<ol>
<li><strong>post</strong> 当文件是可渲染的，并且在_posts文件夹下的处理方式</li>
<li><strong>post_assets</strong> 当文件是不可渲染的，并且配置文件中的”post_asset_folder”属性存在，并且在_posts文件夹下的处理方式 </li>
<li><strong>page</strong> 文件不在_posts下，当文件是可渲染时的处理方式</li>
<li><strong>assets</strong> 文件不在_posts下，当文件是不可渲染时的处理方式</li>
</ol>
<p>另外隐藏文件是不会被处理的。Processor会读取文件文件信息调用Renderer，将处理后的文件内容以及相关信息写入数据库。以便Generator读取。</p>
<h2 id="Renderer">Renderer</h2>
<p><a href="http://hexo.io/docs/plugins.html#Renderer" target="_blank" rel="external">Renderer</a>将源文件转换成最终结果。在lib/plugins/renderer文件夹下可以看到默认的Renderer。默认的转换格式有html,htm,swig,yml等。另外hexo安装时会默认安装md,ejs和stylus的Renderer。</p>
<h2 id="Generator">Generator</h2>
<p><a href="http://hexo.io/docs/plugins.html#Generator" target="_blank" rel="external">Generator</a>根据Processor处理的结果生成静态文件。在lib/plugins/generator文件夹下可以看到默认的Generator。主要有下面几种</p>
<pre><code>generator.<span class="keyword">register</span>(<span class="string">'archive'</span>, <span class="keyword">require</span>(<span class="string">'./archive'</span>));
generator.<span class="keyword">register</span>(<span class="string">'category'</span>, <span class="keyword">require</span>(<span class="string">'./category'</span>));
generator.<span class="keyword">register</span>(<span class="string">'home'</span>, <span class="keyword">require</span>(<span class="string">'./home'</span>));
generator.<span class="keyword">register</span>(<span class="string">'page'</span>, <span class="keyword">require</span>(<span class="string">'./page'</span>));
generator.<span class="keyword">register</span>(<span class="string">'post'</span>, <span class="keyword">require</span>(<span class="string">'./post'</span>));
generator.<span class="keyword">register</span>(<span class="string">'tag'</span>, <span class="keyword">require</span>(<span class="string">'./tag'</span>));
generator.<span class="keyword">register</span>(<span class="string">'asset'</span>, <span class="keyword">require</span>(<span class="string">'./asset'</span>));
</code></pre><p>每一种Generator会根据数据库中的数据，对数据进一步加工生成最后的文件。比如post和page中的内容是html，在生成阶段会根据对应主题在html的基础上加上头尾。而asset类型的，这时数据库中只有文件信息还没有文件内容，这时asset生成器将处理方式存入hexo.route中在之后的生成阶段使用route记录的处理方式获取内容然后复制到目标位置。</p>
<h2 id="Box">Box</h2>
<p><a href="http://hexo.io/api/classes/Box.html" target="_blank" rel="external">Box</a>遍历Source文件夹下的所有文件，将具体文件分派给对应的Processor处理。</p>
<h2 id="Model">Model</h2>
<p><a href="http://hexo.io/api/classes/Model.html" target="_blank" rel="external">Model</a>是Hexo的数据库和数据模型，由Processor和Renderer写入数据，Generator读取数据。数据库是使用的warehouse, 主要的表有</p>
<pre><code>  model.<span class="keyword">register</span>(<span class="string">'Asset'</span>, schema.Asset);
  model.<span class="keyword">register</span>(<span class="string">'Cache'</span>, schema.Cache);
  model.<span class="keyword">register</span>(<span class="string">'Category'</span>, schema.Category, <span class="keyword">require</span>(<span class="string">'../model/category'</span>));
  model.<span class="keyword">register</span>(<span class="string">'Page'</span>, schema.Page);
  model.<span class="keyword">register</span>(<span class="string">'Post'</span>, schema.Post, <span class="keyword">require</span>(<span class="string">'../model/post'</span>));
  model.<span class="keyword">register</span>(<span class="string">'Tag'</span>, schema.Tag, <span class="keyword">require</span>(<span class="string">'../model/tag'</span>));
</code></pre><p>每次生成都会在根目录生成一个db.json，这个就是数据库的结构了。</p>
<h2 id="Theme">Theme</h2>
<p><a href="http://hexo.io/api/classes/Theme.html" target="_blank" rel="external">Theme</a>是连接Hexo核心库的桥梁。特别是在生成阶段当前主题进一步加工有Renderer生成的内容，生成最终的文件。</p>
<h2 id="Route">Route</h2>
<p><a href="http://hexo.io/api/classes/Router.html" target="_blank" rel="external">Route</a>有一个叫routes的属性，这是一个由文件路径作为key，和一个Function作为value的Map。这个Function的返回值就是文件的content。在生成阶段Generator会将最终数据存入这个Map里面。</p>
<h2 id="总结Hexo_Generate命令的工作流程">总结Hexo Generate命令的工作流程</h2>
<ul>
<li>用户终端输入命令 hexo generate。hexo启动，完成各模块初始化。 代码参见： <a href="https://github.com/hexojs/hexo/blob/master/lib/plugins/console/generate.js" target="_blank" rel="external">lib/plugins/console/generate.js</a>。</li>
<li>Box遍历source文件夹中的文件，将要处理的文件分类。代码参见：<a href="https://github.com/hexojs/hexo/blob/master/lib/box/index.js" target="_blank" rel="external">lib/box/index.js</a> 和 <a href="https://github.com/hexojs/hexo/blob/master/lib/plugins/processor/index.js" target="_blank" rel="external">lib/plugins/processor/index.js</a>。</li>
<li>各Processor处理对应文件，需要渲染的文件交由对应的Renderer渲染。并将渲染的数据写入数据库。代码参见：<a href="https://github.com/hexojs/hexo/tree/master/lib/plugins/processor" target="_blank" rel="external">lib/plugins/processor/</a> 和 <a href="https://github.com/hexojs/hexo/tree/master/lib/post" target="_blank" rel="external">lib/post/</a>。</li>
<li>各Generator根据数据库中的数据，根据对应主题进一步加工，将数据存入Route，最后写入目标位置。代码参见：<a href="https://github.com/hexojs/hexo/tree/master/lib/plugins/generator" target="_blank" rel="external">lib/plugins/generator/</a> 和 <a href="https://github.com/hexojs/hexo/blob/master/lib/theme/index.js" target="_blank" rel="external">lib/theme/index.js</a>。</li>
</ul>
<h2 id="一个小插件">一个小插件</h2>
<p>明白了基本原理之后，现在要实现一个小插件。需求是我现在的站点有一个文件夹project专门存放项目代码。但是每次hexo generate 都将public文件夹清空，然后写入文件。所以project文件夹要放在source下面。这样generate生成的时候就将project复制到public里面了。但是这又有一个问题，project我的项目文件夹不可避免的有代码，有些html文件他会自动加上页头和页尾，这个很不好。于是这个插件的功能就是在 _config.yml 配置一个参数允许自定义那些文件夹的内容是不需要渲染的直接复制到public文件夹。 基本思路就是 自定义一个processor，注册一个rule，只要是在这个列表中的文件就按照asset的方式处理。 附上插件地址 : <a href="https://github.com/f111fei/hexo-processor-copyassets" target="_blank" rel="external">https://github.com/f111fei/hexo-processor-copyassets</a></p>
<h2 id="题外:搭建NodeJS调试环境">题外:搭建NodeJS调试环境</h2>
<p>具体的步骤看这里:<a href="http://blog.domlib.com/articles/686.html" target="_blank" rel="external">http://blog.domlib.com/articles/686.html</a>。</p>
<p>这里我补充一下如何调试Hexo，其他的使用命令行的NodeJS调试也是同理。首先当然要下载好Hexo的源代码。然后比如源代码目录是 E:/workspace/hexo/ ，然后在该目录下执行 </p>
<pre><code>cd <span class="constant">E</span><span class="symbol">:/workspace/hexo/</span>
npm install -g 
</code></pre><p>安装一下，这一步是从npm服务器下载Hexo的依赖库，不然调试的时候会报错找不到依赖库。<br>然后创建一个Hexo站点(已经有的忽略下面这一步，直接cd到你的站点目录)</p>
<pre><code>cd <span class="constant">E</span><span class="symbol">:/workSpace/</span>
hexo init xzper.com
</code></pre><p>创建一个站点，这里假定站点目录是 E:/workSpace/xzper.com/ 。然后按照上面的教程，安装好调试工具并启动。</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> -g node-inspector
node-inspector</span>
</code></pre><p> 输入 node-inspector 启动调试工具。 最后最关键的一步，我们要调试hexo generate这个命令，那么在命令行中输入 </p>
<pre><code>cd <span class="constant">E</span><span class="symbol">:/workSpace/xzper</span>.com/
node --debug-brk=<span class="number">5858</span> <span class="constant">E</span><span class="symbol">:/workSpace/hexo/bin/hexo</span> generate
</code></pre><p>这时按照提示打开Chrome输入 <a href="http://127.0.0.1:8080/debug?port=5858" target="_blank" rel="external">http://127.0.0.1:8080/debug?port=5858</a> 断点会停在程序入口第一行，接下来你爱在哪设置断点就在哪设置。</p>
<h2 id="吐槽">吐槽</h2>
<p>我本来就得了一看JS代码就不好的病。然后这次为了搞懂Hexo，先初步学习了一下NodeJS，教程在<a href="http://www.open-open.com/lib/view/1392611872538" target="_blank" rel="external">这里</a>，不得不说本来就很讨厌的JS，再加上NodeJS最大的卖点-异步编程，那各种逼格极高的回调函数，看的我心花怒放，累觉不爱了。</p>
]]></content>
    <summary type="html"><![CDATA[<p><a href="https://github.com/hexojs/hexo" target="_blank" rel="external">Hexo</a>是一个轻量级的静态博客站点生成框架，使用NodeJS开发。经过我两个通宵的努力总算把这个东西研究了一个大概，这里拿来分享一下。</p>
]]></summary>
    
      <category term="Hexo" scheme="http://xzper.com/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://xzper.com/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[框架包结构的设计]]></title>
    <link href="http://xzper.com/2014/08/09/%E6%A1%86%E6%9E%B6%E5%8C%85%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://xzper.com/2014/08/09/框架包结构的设计/</id>
    <published>2014-08-08T16:43:25.000Z</published>
    <updated>2014-08-24T08:37:44.000Z</updated>
    <content type="html"><![CDATA[<p>这里的框架拿Flex或者FlexLite以及Egret做例子。框架的包结构划分应该是以调用关系为依据划分的，尽量把需要相互调用的类放在一个包下面。这样最终得到的结果就是各个包之间相互独立，理想情况下即使你删除一个包，其他的也不受影响。但是现实肯定不是理想的，包之间总是还有依赖。这些有依赖的东西，大部分就是框架里面核心的东西了。这时候就把这些公共依赖的部分抽出来，放到一个核心包下，比如叫core。 从另一种角度上来讲，所谓的框架”核心类”，实际上就是一些公共耦合的类。这样其他的包都和这个核心包有依赖关系，但是他们彼此之间没有依赖关系。</p>
<a id="more"></a>

<p>举一个例子：上面说到的三种框架都有一些枚举类，提供一下静态字符串，通常为其他类的某些属性提供值。再具体一点可以在Flex的spark.components包下面可以看到有一个PopUpPosition的一个枚举类，这里可能会奇怪，这个叫做components的包下面不应该都是放一些UI组件么，怎么多出了这么一个东西。别急，我们来看一下官方API描述：</p>
<p><pre class="lang:as decode:true">PopUpAnchor.popUpPosition 属性的枚举类型。该类型描述了 PopUpAnchor 锚定的 popUp 控件的位置。该位置与 PopUpAnchor 位置相关。</pre><br>这里明确指出了这个枚举类是和这个PopUpAnchor组件配套使用的，也不会作为其他类的某些属性的枚举类型。那么这个枚举类和组件放在一起也就无可厚非了。 我们再来看一下FlexLite里面的PopUpPosition这个类，同样的这也是一个枚举类，甚至全部的代码都和Flex里面的这个一样，但是这个类却不是在components包下面，而是在core包下面。同样的看一下API描述：</p>
<p><pre class="lang:as decode:true">定义弹出位置的常量值。 该常量决定目标对象相对于父级组件的弹出位置。</pre><br>看到这里结合上面所说的，那么这个类一定是和其他的某些类产生了依赖关系。在打开调用结构层次关系的时候会发现，不光是PopUpAnchor这个组件使用了这个常量，还有IToolTipManagerClient这个包含提示功能的组件接口也用到了这个，甚至DropDownList的默认皮肤以及ComboBox的默认皮肤也用到了这个弹出位置的常量，而这些在Flex里面是没有的。所有这两个类的包位置是不一致的。</p>
<p>通常，还有一些公共的依赖包比如managers以及layouts这些全局的管理类。还有一个utils的工具包，这些公共的类都有一个特点，就是除了依赖core包以外不会再依赖于其他的包了。再比如skins这个包，这个包提供组件的默认皮肤，我们完全可以直接删除这个包，整个框架也不会报错，但是他还是存在于框架中，因为他提供了一个默认的实现方式，方便了开发者以及调试。所有最后的结论就是，框架中包的划分是<strong>根据类的依赖关系来放，而不是类的特征。</strong></p>
]]></content>
    <summary type="html"><![CDATA[<p>这里的框架拿Flex或者FlexLite以及Egret做例子。框架的包结构划分应该是以调用关系为依据划分的，尽量把需要相互调用的类放在一个包下面。这样最终得到的结果就是各个包之间相互独立，理想情况下即使你删除一个包，其他的也不受影响。但是现实肯定不是理想的，包之间总是还有依赖。这些有依赖的东西，大部分就是框架里面核心的东西了。这时候就把这些公共依赖的部分抽出来，放到一个核心包下，比如叫core。 从另一种角度上来讲，所谓的框架”核心类”，实际上就是一些公共耦合的类。这样其他的包都和这个核心包有依赖关系，但是他们彼此之间没有依赖关系。</p>
]]></summary>
    
      <category term="架构" scheme="http://xzper.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="框架" scheme="http://xzper.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解读DXML编译器]]></title>
    <link href="http://xzper.com/2014/07/02/%E8%A7%A3%E8%AF%BBDXML%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <id>http://xzper.com/2014/07/02/解读DXML编译器/</id>
    <published>2014-07-02T08:22:49.000Z</published>
    <updated>2014-09-04T16:03:57.000Z</updated>
    <content type="html"><![CDATA[<p>DXML就是FlexLite中由FlexLiteStdio生成的皮肤文件，类似于Flex中的MXML。实际上区别没多少，可能最大的区别就是MXML支持Script脚本。DXML架构设计对编写各类UI编辑器，各类代码生成工具都有很好的参考价值。这里主要分析DXML编译器是如何将DXML文件转换为as代码。</p>
<a id="more"></a>

<p><strong>1.如何使用DXML编译器</strong></p>
<p>DXML编译器在源代码在FlexLiteExtends中的org.flexlite.domCompile包下。导入相应的类后，先导入配置文件manifest.xml(这个文件可以在FlexLiteStdio的安装目录的bin文件夹下可以找到，也可以通过ManifestUtil这个类生成)。这是一个全局静态属性，导入代码如下:</p>
<p><pre class="lang:as decode:true">DXMLCompiler.configData = manifestXml;</pre><br>然后创建一个DXMLCompiler实例，调用compile方法得到编译后的结果:</p>
<p><pre class="lang:as decode:true">var compiler:DXMLCompiler = new DXMLCompiler();<br>var result:String  = compiler.compile(buttonSkinXml , “Button”);</pre><br>完整的代码如下:</p>
<p><pre class="lang:as decode:true">    public class DXMLCompilerTest extends Sprite<br>    {<br>        [Embed(source=”resource/xml/flexlite-manifest.xml” , mimeType = “application/octet-stream”)]<br>        private var manifest:Class;</pre></p>
<pre><code>    [Embed(source=<span class="string">"resource/xml/ButtonSkin.dxml"</span> , mimeType = <span class="string">"application/octet-stream"</span>)]
    <span class="keyword">private</span> <span class="keyword">var</span> buttonSkin:Class;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">DXMLCompilerTest</span><span class="params">()</span>
    </span>{
        <span class="keyword">super</span>();

        <span class="keyword">var</span> manifestBy:ByteArray = <span class="keyword">new</span> manifest();
        <span class="comment">//flexlite-manifest.xml对象</span>
        <span class="keyword">var</span> manifestXml:XML = XML(manifestBy.readUTFBytes(manifestBy.length));

        <span class="keyword">var</span> buttonSkinBy:ByteArray = <span class="keyword">new</span> buttonSkin();
        <span class="comment">//ButtonSkin.dxml对象</span>
        <span class="keyword">var</span> buttonSkinXml:XML = XML(buttonSkinBy.readUTFBytes(buttonSkinBy.length));

        <span class="comment">//flexlite-manifest框架清单文件</span>
        DXMLCompiler.configData = manifestXml;

        <span class="keyword">var</span> compiler:DXMLCompiler = <span class="keyword">new</span> DXMLCompiler();
        <span class="keyword">var</span> result:String  = compiler.compile(buttonSkinXml , <span class="string">"Button"</span>);
        <span class="keyword">trace</span>(result);
    }
}&lt;/pre&gt;
</code></pre><p><strong>2.配置文件manifest</strong></p>
<p>manifest是由编译器使用的配置文件，定义了编译器能识别的各类组件。</p>
<p><pre class="lang:as decode:true">&lt;componentPackage crc32=”a32782dd”&gt;<br>  &lt;component id=”ArrayCollection” p=”org.flexlite.domUI.collections.ArrayCollection” s=”flash.utils.Proxy” d=”source” array=”true”/&gt;<br>   &lt;component id=”Button” p=”org.flexlite.domUI.components.Button” s=”org.flexlite.domUI.components.supportClasses.ButtonBase” show=”true”/&gt;<br>  &lt;component id=”ButtonBase” p=”org.flexlite.domUI.components.supportClasses.ButtonBase” s=”org.flexlite.domUI.components.SkinnableComponent” d=”label” state=”up,over,down,disabled”/&gt;<br>  &lt;component id=”Group” p=”org.flexlite.domUI.components.Group” s=”org.flexlite.domUI.components.supportClasses.GroupBase” d=”elementsContent” show=”true” array=”true”/&gt;<br>&lt;/componentPackage&gt;</pre><br>以上节选自flexlite-manifest.xml。manifest.xml由各类component组成，包括但不限于UI组件。主要是用来配置对dxml文件中可能出现的节点的定义供编译器解析。component节点对应编译器中的Component类，各个属性解释如下</p>
<p><strong>id</strong>，这个组件的短名ID，对应Component的id属性</p>
<p><strong>p</strong>，组件的完整类名，对应Component的className属性</p>
<p><strong>s</strong>，父级类名，对应Component的superClass属性</p>
<p><strong>d</strong>，默认属性，对应Component的defaultProp属性，这个实际就是表示这个组件的子节点对应的属性</p>
<p><strong>array</strong>，默认属性是否为数组类型，对应Component的isArray属性</p>
<p><strong>states</strong>，视图状态列表，对应Component的states属性</p>
<p>比如：</p>
<p><pre class="lang:as decode:true">    &lt;dx:Group left=”16” right=”16” top=”41” id=”contentGroup” bottom=”42”&gt;<br>        &lt;dx:Label text=”标签” size=”14” maxWidth=”310” textColor=”0xFFFFFF”/&gt;<br>    &lt;/dx:Group&gt;</pre><br>这里有一个Group组件，然后对应一个子节点Label。那么Group的defaultProp也就是elementsContent这个属性对应的值是个数组，其中的一项就是Label。同理，比如ArrayCollection节点有子节点，那么source属性对应的值就是这些子节点。</p>
<p><strong>2. 代码定义CodeBase</strong></p>
<p>CodeBase是代码定义的基类，其中的toCode方法就是生成代码的关键。编译器中扩展了CodeBase实现了各种代码定义，比如注释，变量定义，参数定义，函数定义，类定义和代码块。这里挑几个重点的说:</p>
<p><strong>函数定义CpFunction</strong>。一个函数主要由 修饰符(private,protected,public)，函数名 ，参数列表(CpArguments数组)和代码块(CpCodeBlock)组成。另外还有一些override，static之类的关键词标示符。</p>
<p><strong>代码块CpCodeBlock</strong>。代码块就是函数中的内容，主要提供了一些添加语句的方法，比如 添加变量声明语句addVar，添加赋值语句addAssignment，添加一行代码addCodeLine等。开发者调用这些方法从而完成代码块的内容。</p>
<p><strong>类定义CpClass</strong>。定义了一个类的代码，类的组成主要有 定义部分(例如:类注释， 类名，包名，修饰符，父类，接口)，导入包区块，构造函数，成员变量，成员函数。CpClass提供各种方法来完善这些内容，比如:导入包addImport，添加变量addVariable，添加函数addFunction。</p>
<p>有了这些，在完成类中各个区块的定义和赋值之后，调用toCode方法转换成as代码。</p>
<p><strong>3.解析配置文件DXMLConfig</strong></p>
<p>manifest.xml的解析交给DXMLConfig来完成，DXMLConfig解析完成后存储配置文件中的组件对应的基本属性已经映射关系。解析完成后，外界可以使用的主要方法有:</p>
<p><pre class="lang:as decode:true">        /**</pre></p>
<pre><code>     * 根据类的短名ID和命名空间获取完整类名(以<span class="string">"."</span>分隔)
     * @param id 类的短名ID
     * @param ns 命名空间
     */                
    <span class="function"><span class="keyword">function</span> <span class="title">getClassNameById</span><span class="params">(id:String,ns:Namespace)</span><span class="type">:String</span></span>;

    <span class="comment">/**
     * 根据ID获取对应的默认属性
     * @param id 类的短名ID
     * @param ns 命名空间
     * @return {name:属性名(String),isArray:该属性是否为数组(Boolean)}
     */</span>        
    <span class="function"><span class="keyword">function</span> <span class="title">getDefaultPropById</span><span class="params">(id:String,ns:Namespace)</span><span class="type">:Object</span></span>;

    <span class="comment">/**
     * 获取指定属性的类型,返回基本数据类型："uint","int","Boolean","String","Number","Class"。
     * @param prop 属性名
     * @param className 要查询的完整类名
     * @param value 属性值
     */</span>            
    <span class="function"><span class="keyword">function</span> <span class="title">getPropertyType</span><span class="params">(prop:String,className:String,value:String)</span><span class="type">:String</span></span>;&lt;/pre&gt;
</code></pre><p><strong>4.了解DXML文件结构</strong></p>
<p>在了解编译器是如何工作之前，需要了解DXML文件的结构。这里通过一个典型例子来了解DXML的结构。</p>
<p><pre class="lang:as decode:true">&lt;?xml version=”1.0” encoding=”utf-8”?&gt;<br>&lt;dx:StateSkin width=”100” xmlns:dx=”<a href="http://www.flexlite.org/dxml/2012" target="_blank" rel="external">http://www.flexlite.org/dxml/2012</a>“ xmlns:fs=”<a href="http://www.flexlite.org/studio/2012&quot;&amp;gt" target="_blank" rel="external">http://www.flexlite.org/studio/2012&quot;&amp;gt</a>;<br>    &lt;fs:HostComponent name=”org.flexlite.domUI.components.Button”/&gt;<br>    &lt;fs:Declarations&gt;<br>        &lt;dx:DropShadowFilter alpha=”1.00” angle=”0.00” blurY=”4” color=”0x000000” quality=”1” blurX=”4” hideObject=”false” distance=”0” inner=”false” strength=”10” knockout=”false” id=”<strong>DropShadowFilter0”/&gt;<br>    &lt;/fs:Declarations&gt;<br>    &lt;dx:states&gt;<br>        &lt;dx:State name=”up”/&gt;<br>        &lt;dx:State name=”over”/&gt;<br>        &lt;dx:State name=”down”/&gt;<br>        &lt;dx:State name=”disabled”/&gt;<br>    &lt;/dx:states&gt;<br>    &lt;dx:UIAsset left=”0” y=”0” top=”0” right=”0” skinName=”DXR</strong>1C5D2D62” bottom=”0” x=”0” includeIn=”disabled”/&gt;<br>    &lt;dx:UIAsset left=”0” top=”0” bottom=”0” skinName=”DXR<strong>276F2CB5” right=”0” includeIn=”up”/&gt;<br>    &lt;dx:UIAsset left=”0” top=”0” bottom=”0” skinName=”DXR</strong>7905FD81” right=”0” includeIn=”down”/&gt;<br>    &lt;dx:UIAsset left=”0” top=”0” bottom=”0” skinName=”DXR<strong>F2888F03” right=”0” includeIn=”over”/&gt;<br>    &lt;dx:Label paddingTop=”4” id=”labelDisplay” horizontalCenter=”0” text=”按钮” size=”14” textAlign=”center” paddingBottom=”4” filters=”{[</strong>DropShadowFilter0]}” paddingLeft=”10” bold=”false” textColor=”0xFFFFCD” paddingRight=”10” fontFamily=”FZShaoEr-M11S” verticalCenter=”0”/&gt;<br>&lt;/dx:StateSkin&gt;</pre><br><strong>根节点</strong>。每个DXML文件对应一个as类，根节点就是这个类定义，在这里可以定义类的属性以及对应的值。另外这里还有命名空间NameSpace的定义。默认的命名空间有dx和fs。命名空间主要用来快速区别节点，从而快速过滤对节点执行对应操作。</p>
<p><strong>声明节点</strong>。DXML中一些不可视的一些元素可以定义在声明节点中，作为fs:Declarations这个节点的子节点。上述例子中的阴影滤镜就是在这个节点中。</p>
<p><strong>States节点</strong>。States定义了组件的各个状态。</p>
<p><strong>组件节点</strong>。一般以dx开头的节点就是组件节点，当然组件节点也可以自定义(使用自定义组件所在的包作为新的命名空间，添加到根节点中)。这里可使用的组件是和manifest.xml中对应的。在组件节点中可以对组件的各个属性赋值。另外，组件节点有一些共有的特殊属性，比如: id 表示组件对应的实例名，includeIn，excludeFrom表示组件对应的状态。还有上面提到的，组件如果有子节点，那么这些子节点就是组件对应的默认值。</p>
<p><strong>5.DXML**</strong>编译器**</p>
<p><strong>编译开始的准备工作</strong></p>
<p>在编译开始前，创建DXMLConfig实例解析manifest配置，读取dxml文件。创建一个CpClass实例currentClass。</p>
<p><strong>编译开始</strong></p>
<p>调用startCompile编译开始，通过getStateNames方法获取dxml中定义的所有状态并使用stateCode保存。然后为根节点加入currentState的属性并赋值。使用declarations保存dxml的声明节点。然后调用addIds方法遍历各个节点添加成员变量以及函数。最后是生成构造函数。</p>
<p><strong>导入包，添加**</strong>import<strong>**区块</strong></p>
<p>包的导入，并不是一次性导入，而是贯彻在整个编译过程中。通常在调用getPackageByNode这个方法时来添加import区块。因为每个节点一般对应一个class，这样在分析节点时就能获取到节点的className，从而导入。</p>
<p><strong>依据**</strong>id<strong><strong>添加成员变量，以及自动为组件添加</strong></strong>id<strong>**属性</strong></p>
<p>某些节点具有id属性，那么一般这个节点对应的实例就是这个类的成员变量，实例名就是这个id的值，调用createVarForNode方法将节点添加进成员变量列表。某些组件没有id属性，那么调用createIdForNode给每一个组件节点加上id属性，赋值也遵循一定规范不会重复。另外有些组件是只存在于某些特定状态下的，这时会使用stateIds记录下来，随后在构造函数里面单独实例化。以上过程的具体实现参考addIds这个方法，整个过程是递归的。</p>
<p><strong>创建构造函数</strong></p>
<p>函数的主要内容就是代码块，首先创建一个代码块实例。通过addAttributesToCodeBlock方法解析根节点的所有属性，并生成赋值语句。解析declarations的子节点，调用createFuncForNode为每一个子节点创建对应的方法。使用initlizeChildNode方法遍历组件的子组件，对组件的默认属性赋值。最后解析状态代码，完成所有状态的赋值。</p>
<p>简而言之，解析一个组件的大致思路就是，通过addAttributesToCodeBlock方法解析节点的属性并赋值，然后使用initlizeChildNode方法遍历节点的子节点为默认属性赋值。在initlizeChildNode方法中调用createFuncForNode，为每个子节点创建单独的函数。而createFuncForNode这个方法中又会调用addAttributesToCodeBlock和initlizeChildNode解析节点属性和为默认属性赋值，如此递归调用下去。</p>
<p><strong>重要方法解析</strong></p>
<p><strong>createVarForNode </strong></p>
<p>创建成员变量。一般带有id的组件节点都会被调用这个方法创建对应id的实例名变量。</p>
<p><strong>addAttributesToCodeBlock</strong></p>
<p>解析组件的属性并赋值。对应一些特殊属性比如id，includeIn，locked已经带有”.”操作符的属性是不理会的。这样获取一个keyList，读取对应的value，格式化key和value然后添加赋值语句。有些key比较特殊比如height，因为对应的值可能是一个百分比所以需要格式化key转换成percentHeight。格式化value就比较麻烦了，有些value是带”{}”的要去掉{}，有些特殊的key比如skinName对应的value可能是一个class，这些key-value的转换规则通过DXMLConfig的getPropertyType来获取。最后如果对应的值是一个id即成员变量，则需要延迟赋值，到那个成员变量的创建函数中赋值。</p>
<p><strong>initlizeChildNode</strong></p>
<p>某些组件含有子节点，这些子节点就是这个组件对应的默认属性的值。这个方法首先获取直接子节点directChild，然后调用createFuncForNode，为每个子节点创建单独的函数。最后生成默认属性的赋值语句。对于一些包含状态的子节点是会被过滤掉的，因为有专门的状态生成代码。</p>
<p><strong>createFuncForNode</strong></p>
<p>实际上创建构造函数也是实现了这个方法。先调用addAttributesToCodeBlock，然后调用initlizeChildNode。只是创建构造函数多了一个解析声明节点和解析状态的过程。这个方法有一个创建构造函数没有的过程就是，添加一个变量声明(实际上就是实例化这个节点对应的类)，为节点的id属性赋值为这个节点变量。原来还会在延迟赋值字典里面加入对应的延迟赋值语句。</p>
<p><strong>createStates</strong></p>
<p>这个是在创建构造函数时被调用的，主要用来解析视图状态代码。本身是一个递归函数。遍历所有的子节点，找到那些在特定状态下出现节点。分解成每一个CpState填充进stateCode。</p>
]]></content>
    <summary type="html"><![CDATA[<p>DXML就是FlexLite中由FlexLiteStdio生成的皮肤文件，类似于Flex中的MXML。实际上区别没多少，可能最大的区别就是MXML支持Script脚本。DXML架构设计对编写各类UI编辑器，各类代码生成工具都有很好的参考价值。这里主要分析DXML编译器是如何将DXML文件转换为as代码。</p>
]]></summary>
    
      <category term="actionscript3" scheme="http://xzper.com/tags/actionscript3/"/>
    
      <category term="FlexLite" scheme="http://xzper.com/categories/FlexLite/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用egret开发2048]]></title>
    <link href="http://xzper.com/2014/06/22/%E4%BD%BF%E7%94%A8egret%E5%BC%80%E5%8F%912048/"/>
    <id>http://xzper.com/2014/06/22/使用egret开发2048/</id>
    <published>2014-06-22T12:41:00.000Z</published>
    <updated>2014-09-04T16:04:44.000Z</updated>
    <content type="html"><![CDATA[<p>2048是最近很火的一个小游戏，<a href="http://gabrielecirulli.github.io/2048/" target="_blank" rel="external">原版</a>就是用JavaScript写的。恰巧最近egret PublicBeta，观望和学习了一阵后，发现egret正好适合开发这类游戏。egret使用TypeScript作为开发语言，最终编译为JavaScript，正好和原始版本PK一下。</p>
<p>游戏预览：<a href="http://xzperproject.qiniudn.com/2048egret/launcher/release.html" target="_blank" rel="external">点我体验</a></p>
<a id="more"></a>

<p><strong>1.准备开始</strong><br> 在开始之前，我们需要学习一下TypeScript和阅读官方的教程从egret开发环境的部署到创建，编译，发布项目，以及egret相关工具。在安装好开发环境后，在工作空间目录下使用命令行，创建2048egret新项目</p>
<pre class="lang:as decode:true">egret create 2048egret</pre>

<p><strong>2.准备素材</strong></p>
<p>每一个游戏都离不开美术资源，我们需要做的就是把美术资源打包，然后加载进来使用。这一方面egret有一套完整的工作流。</p>
<p><strong>①资源打包</strong>。</p>
<p>这里我们用到的资源主要有按钮，背景，文字以及数字这些图片。我们选择把这些图片都打包在一起合成一张大图就像<a href="http://xzperproject.qiniudn.com/2048egret/resources/assets/source.png" target="_blank" rel="external">这样</a>和<a href="http://xzperproject.qiniudn.com/2048egret/resources/assets/number.png" target="_blank" rel="external">这样</a>。这样做可以减少URL请求数，还能减少资源的体积，把一些具有相同特征的图片放在一起便于管理。在egret里面这种类型的资源就是sheet。只有图片是不够的，还需要一个json描述文件来说明这张图每一张小图片的位置和大小。目前已经有成熟的工具来生成sheet和json。这里我用到的是<a href="http://www.renderhjs.net/shoebox/" target="_blank" rel="external">ShoeBox</a>配合这个<a href="https://github.com/runinspring/egretTools" target="_blank" rel="external">插件</a>来生成egret能识别的json。安装好插件后， 将每一张图片命名，然后将这些图片选中拖入Sprites Sheet中然后配置好生成的文件名点击save就能得到一张大图和一个json了，将图片和json放入”resources/assets/“文件夹下以备使用。此外ShoeBox还能读取swf将MovieClip导出为这种大图，按每一帧自动命名，这里的number.png就是这样导出的，下面有原始素材下载地址。</p>
<p><strong> ②资源加载</strong></p>
<p>接下来我们需要生成一个资源描述文件resource.json，在游戏开始之前读取这个json来加载对应的文件。egret的资源加载机制可以参考<a href="https://github.com/egret-labs/egret-core/wiki/Using%20Resource%20System" target="_blank" rel="external">这里</a>。现在已经有<a href="http://bbs.egret-labs.org/thread-48-1-1.html" target="_blank" rel="external">工具</a>能自动生成这个resource.json了。按照下图配置。<strong>注意：**</strong>虽然我们的资源有图片，但是对应的json文件已经记录了图片的位置，所以在这个工具中我们不需要添加对应的图片只添加json文件就行了。<br> **</p>
<p><img src="http://xzper.qiniudn.com/wp-content/uploads/2014/06/ResTool.png" alt="ResTool"></p>
<p><span style="color: #0000ee;"> </span>在项目初始化时，使用RES加载资源，简单明了。</p>
<pre class="lang:as decode:true">    private onAddToStage(event:egret.Event){
        ........
        ........
        //初始化Resource资源加载库
        RES.addEventListener(RES.ResourceEvent.CONFIG_COMPLETE,this.onConfigComplete,this);
        RES.loadConfig("resources/resource.json","resources/");
    }

    /**
     * 配置文件加载完成,开始预加载preload资源组。
     */
    private onConfigComplete(event:RES.ResourceEvent):void{
        RES.removeEventListener(RES.ResourceEvent.CONFIG_COMPLETE,this.onConfigComplete,this);
        RES.addEventListener(RES.ResourceEvent.GROUP_COMPLETE,this.onResourceLoadComplete,this);
        RES.addEventListener(RES.ResourceEvent.GROUP_PROGRESS,this.onResourceProgress,this);
        RES.loadGroup("preload");
    }</pre>

<p><strong>③资源使用</strong></p>
<p>在项目中我们可以使用RES来使用资源，参照对应的API。对于没有写进配置文件的资源使用RES.getResByUrl方法来异步获取。开发人员能使用极其少量的代码来完成各类资源的加载。</p>
<p><strong>3.更改模板生成的代码</strong></p>
<p><strong>①修改细节</strong></p>
<p>默认的文档类是GameApp。我觉得还是叫Main比较亲切，修改类名称，然后修改egret_loader.js</p>
<pre class="lang:as decode:true">    //在此定义文档类的完整类名，若包含命名空间，需要填写命名空间前缀。
    var document_class = "Main";</pre>

<p>默认生成的html的背景是黑色的，这里全部改成白色。将index.html里面的背景替换成#ffffff。</p>
<p>默认尺寸是480x800的尺寸。由于我们使用的部分图片宽度大于500，以及部分PC的分辨率太小为了不出现垂直滚动条影响体验，将尺寸换成520x650。这个不影响移动设备上的尺寸，移动设备默认是自适应宽度的。</p>
<p>index.html中</p>
<pre class="lang:as decode:true">&lt;div style="display:inline-block;width:100%; height:100%;margin: 0 auto; background: #ffffff; position:relative;"
     id="gameDiv"&gt;
    &lt;canvas id="gameCanvas" width="520" height="650" style="background-color: #ffffff"&gt;&lt;/canvas&gt;
&lt;/div&gt;</pre>

<p>egret_loader.js中</p>
<pre class="lang:as decode:true">    //设置屏幕适配策略
    var container = new egret.EqualToFrame();
    var content = egret.Browser.getInstance().isMobile ? new egret.FixedWidth() : new egret.FixedSize(520, 650);
    var policy = new egret.ResolutionPolicy(container, content);
    egret.StageDelegate.getInstance().setDesignSize(520, 650, policy);</pre>

<p><strong>③引入第三方库pureMVC</strong></p>
<p>这次我们要使用到一个mvc开发框架-pureMVC，熟悉as3的朋友一定也对这个框架不陌生吧。不熟悉的也没关系，这个框架不是这次的主角。我们从<a href="https://github.com/PureMVC/puremvc-typescript-standard-framework" target="_blank" rel="external">这里</a>下载pureMVC的TypeScript版本。得到puremvc-typescript-standard-1.0.d.ts 和 puremvc-typescript-standard-1.0.js这两个文件，其实.d.ts就类似于c++里面的.h头文件，只有空方法和空属性，真正的实现是在js文件或者ts文件里面。 将.d.ts文件放入到”src/lib/“目录下,js文件放入launcher目录下。然后修改index.html引入这个js文件 以便在加载游戏代码之前先加载到库文件。release.html也一样引入这个js文件。</p>
<pre class="lang:as decode:true">&lt;script src="bin-debug/lib/egret_file_list.js"&gt;&lt;/script&gt;
&lt;script src="launcher/egret_loader.js"&gt;&lt;/script&gt;
&lt;script src="launcher/puremvc-typescript-standard-1.0.js"&gt;&lt;/script&gt;
&lt;script src="bin-debug/src/game_file_list.js"&gt;&lt;/script&gt;</pre>

<p>由于现在官方对第三方库的编译支持还没设计好方案。目前我临时采用这种方式来实现。大家有更好的办法欢迎回帖讨论。</p>
<p><strong>④注入AssetAdapter和SkinAdapter</strong></p>
<p>我们这次的主角是egret的GUI。找到官方<a href="https://github.com/egret-labs/egret-examples" target="_blank" rel="external">GUIExample</a>中的这两个ts文件复制到项目的src文件夹下面，由于这个项目没有用到默认皮肤，删除ShinAdapter里面getDefaultSkin方法的默认皮肤。最后不要忘了一点，在引擎初始化的时候注入这两个Adapter。</p>
<pre class="lang:as decode:true">private onAddToStage(event:egret.Event){
        //注入自定义的素材解析器
        egret.Injector.mapClass("egret.IAssetAdapter",AssetAdapter);
        //注入自定义的皮肤解析器
        egret.Injector.mapClass("egret.ISkinAdapter",SkinAdapter);
        ......
        ......
}</pre>

<p>这两个的Adapter的作用至关重要，AssetAdapter负责解释UIAsset的source属性 ，SkinAdapter负责解释SkinnableCompent的skinName属性。这里官方提供了两个默认已经写好了的，当然我们可以自己扩展。 没有他们，UIAsset素材包装器的source属性 和 可设置皮肤的GUI组件的skinName属性毫无作用。而这两种组件是今后使用最多的。不信可以往下看 。</p>
<p><strong>⑤修改createGameScene方法</strong></p>
<p>在生成的模板中，文档类Main在经过一系列的前期准备工作之后，终于轮到GUI组件的老大UIStage上场了。UIStage类似于Flex里面的SystemManager，内置弹出窗口层，工具提示层和鼠标样式层，所有的GUI组件都应该添加到他的下面，并且UIStage全局唯一。  这里我们实现了一个AppContainer继承自UIStage。 同时在这里pureMVC框架正式启动，开始运作。</p>
<pre class="lang:as decode:true">    /**
     * 创建游戏场景
     */
    private createGameScene():void {
        var appContainer:game.AppContainer = new game.AppContainer();
        this.addChild(appContainer);
        game.ApplicationFacade.getInstance().startUp(appContainer);
    }</pre>

<p><strong>4.pureMVC</strong></p>
<p><strong>①Mediator</strong></p>
<p>Mediator(中介器)是连接视图也就是egret的GUI和pureMVC的桥梁。Mediator受到消息时(handleNotification)调用GUI组件的方法和设置属性，来改变视图。或者视图发生改变时通知Mediator由其发送消息到pureMVC(sendNotification)。</p>
<p><strong>ApplicationMediator  </strong>监听键盘事件或者手势发送消息到GameCommand通知移动</p>
<p><strong>MainGameMediator  </strong>接收消息，调用MainGameUI的方法处理格子的移动，添加，删除，重置，以及接收游戏结果，显示结果面板</p>
<p><strong>MainMenuMediator</strong> 接收更新分数的消息，调用MainGameUI的方法更新分数与重置<strong>
 </strong></p>
<p><strong>ResultWindowMediator </strong>发送游戏重置的消息，以及自销毁。</p>
<p><strong>②Command</strong></p>
<p>command属于控制器。负责收发消息和处理简单的事务。在StartupCommand中使用ControllerPrepCommand，ModelPrepCommand，ViewPrepCommand三个子任务。分别注册控制器，数据和视图。</p>
<p><strong>GameCommand </strong>处理各类事务。比如 玩家按下了方向键，收到消息调用GridProxy的移动方法改变数据，比如GridProxy移动格子分数改变了，通知GameCommand 调用GameProxy的更新分数方法改变分数，比如处理重置游戏的事务，通知各个数据模块重置数据</p>
<p><strong>③Proxy</strong></p>
<p>处理数据，提供公共方法供Command调用以改变数据。改变数据了然后sendNotification通知Mediator改变视图。</p>
<p><strong>GameProxy </strong>处理游戏数据，比如更新分数，处理游戏结果</p>
<p><strong>GridProxy </strong>这个游戏的核心数据，操作每一个格子的数据，通知视图格子的移动，添加，删除，重置。这里包含2048这个游戏的精髓。有兴趣的可以研究下，源码里面有详细注释，这篇文章不做重点讲解。</p>
<p><strong>5.egret的GUI</strong></p>
<p><strong>①制作菜单———-认识皮肤部件 </strong></p>
<p>先来看看菜单长什么样子</p>
<p><img src="http://xzper.qiniudn.com/wp-content/uploads/2014/06/菜单.jpg" alt="菜单"></p>
<p>我们会发现这个菜单。有些是静态文本，是一直不变的，我偷懒直接用了一张图片代替了，图片可以用egret.UIAsset。</p>
<p>还有当前得分和最高分已经那个向上飘的数字是动态的，可以选用egret.Label这个组件。</p>
<p>一个重试按钮，既然已经说了是按钮了我们就用egret.Button好了。</p>
<p>接下来我们要做到皮肤和组件分离。那几个需要参与逻辑的组件自然就成了皮肤部件了。来看看MainMenuUISkin：</p>
<pre class="lang:as decode:true">        /**
         * 和主机组件匹配的皮肤部件
         */
        private static _skinParts:Array&lt;string&gt; = ["addLabel","scoreLabel","highScoreLabel","resetButton"];

        public get skinParts():Array&lt;string&gt;{
            return MainMenuUISkin._skinParts;
        }

        /**
         * 加分文本
         */
        public addLabel:egret.Label;

        /**
         * 总分文本
         */
        public scoreLabel:egret.Label;

        /**
         * 最高分文本
         */
        public highScoreLabel:egret.Label;

        /**
         * 重置按钮
         */
        public resetButton:egret.Button;

        public createChildren():void
        {
            super.createChildren;
            var uiAsset:egret.UIAsset = new egret.UIAsset();
            uiAsset.source = "source.menu";
            this.addElement(uiAsset);

            this.resetButton = new egret.Button();
            this.resetButton.skinName = ResetButtonSkin;
            this.resetButton.right = 10;
            this.resetButton.top = 80;
            this.resetButton.label = "重置游戏";
            this.addElement(this.resetButton);

            this.highScoreLabel = new egret.Label();
            ...省略若干代码
            this.scoreLabel = new egret.Label();
            ...省略若干代码
            this.addLabel = new egret.Label();
            ...省略若干代码
        }</pre>

<p>篇幅有限，省略了createChildren方法里面的子组件布局。<strong>skin的createChildren方法是在皮肤和主机组件匹配的时候被调用的。皮肤和主机组件匹配是在主机组件被添加到显示列表的时候完成的。所以只要主机组件hostComponent还没有添加到显示舞台，获取hostComponent的皮肤部件都是无效的。</strong>这也是为什么我将Mediator的注册放在GUI组件的createComplete后。以防Mediator访问出现空对象的情况。</p>
<p>再来看看主机组件MainMenuUI是怎么写的。</p>
<pre class="lang:as decode:true">    export class MainMenuUI extends egret.SkinnableComponent{
        public addLabel:egret.Label;
        public scoreLabel:egret.Label;
        public highScoreLabel:egret.Label;
        public resetButton:egret.Button;

        public constructor(){
            super();
            this.skinName = MainMenuUISkin;
            this.addEventListener(egret.UIEvent.CREATION_COMPLETE , this.createCompleteEvent, this);
        }

        public createCompleteEvent(event:egret.UIEvent):void{
            this.removeEventListener(egret.UIEvent.CREATION_COMPLETE , this.createCompleteEvent, this);
            ApplicationFacade.getInstance().registerMediator( new MainMenuMediator(this) );
        }

        public partAdded(partName:string, instance:any):void{
            super.partAdded(partName , instance);
            if(this.addLabel == instance){
                this.addLabel.visible = false;
            }
        }

        private moveEffect_effectEndHandler():void
        {
            this.addLabel.visible = false;
        }

    /**
    * 加分效果
    */
        public playScoreEffect(addScore:number):void{
            this.addLabel.visible = true;
            this.addLabel.text = "+".concat(addScore.toString());
            egret.Tween.removeTweens(this.addLabel);
            this.addLabel.y = 25;
            egret.Tween.get(this.addLabel).to({y:0},300).call(this.moveEffect_effectEndHandler , this);
    }
   }</pre>

<p>在构造函数里面赋值skinName传入皮肤的类引用，这个解析过程就是SkinAdapter完成的。 可以看到主机组件有一个partAdded进行皮肤组件的配对。这个时候我们就可以获取到对应的皮肤组件，来进行操作了，</p>
<p><strong>②制作游戏区域————了解九宫格和容器布局</strong></p>
<p><img src="http://xzper.qiniudn.com/wp-content/uploads/2014/06/游戏演示.png" alt="游戏演示"></p>
<p>再次来观察这个游戏的主界面。有一张纯色的背景图，还有4x4个空白的格子，随着游戏的进行会多出带数字的格子，游戏结束了还会出现胜利的界面。</p>
<p>先来看看第一张图。也许你认为这个背景一张4x4的图片不就搞定了么。不过我们这个2048单元格的数量可是可以任意调整的，可以是5x5，或者6x6甚至更多，这样才具备灵活性。你只需要改变CommandData的size属性就可以了(PS:游戏胜利的条件默认是达成2048，也可以通过修改CommandData的winValue属性来修改条件比如8192时胜利或者像上面那样32的时候胜利，想不输都难)。</p>
<p>我们继承SkinnableContainer建立一个MainGameUI的类作为容器来显示上面的界面，当然同时还需要一个皮肤MainGameUISkin。先来确定skinParts，如下：</p>
<pre class="lang:as decode:true">        /**
         * 和主机组件匹配的皮肤部件
         */
        private static _skinParts:Array&lt;string&gt; = [
            "tileGroup","contentGroup"
        ];

        public get skinParts():Array&lt;string&gt;{
            return MainGameUISkin._skinParts;
        }

        /**
         * 游戏底背景
         */
        private backUIAsset:egret.UIAsset;

        /**
         * 背景格子容器
         */
        private backGroundGroup:egret.Group;

        /**
         * 格子容器
         */
        public tileGroup:egret.Group;

        /**
         * 内容
         */
        public contentGroup:egret.Group;</pre>

<p>游戏游戏的底背景backUIAsset和背景格子容器backGroundGroup由于逻辑组件MainGameUI不需要关心所有这里不将其设置为skinParts。tileGroup是放置单元格的容器，contentGroup是SkinnableContainer的皮肤部件，SkinnableContainer的addElement方法实际上是添加到这个里面，换言之如果皮肤缺少这个contentGroup那么调用MainGameUI的addElement是看不到你要添加的子项的。 然后override这个createChildren方法将这些组件加入到显示列表。</p>
<pre class="lang:as decode:true">        public createChildren():void
        {
            super.createChildren;
            this.backUIAsset = new egret.UIAsset();
            this.backUIAsset.source = "source.background";
            //使用九宫格
            this.backUIAsset.scale9Grid = new egret.Rectangle(20, 20, 65, 65);
            this.backUIAsset.width = CommonData.size*(TileUI.size + this.gap) + this.gap;
            this.backUIAsset.height = this.backUIAsset.width;
            this.addElement(this.backUIAsset);

            //使用格子布局
            var layout:egret.TileLayout = new egret.TileLayout();
            layout.columnCount = layout.rowCount = CommonData.size;
            layout.horizontalGap = layout.verticalGap = this.gap;
            this.backGroundGroup = new egret.Group();
            this.backGroundGroup.x = this.backGroundGroup.y = this.gap;
            this.backGroundGroup.layout = layout;
            this.addElement(this.backGroundGroup);
            this.initBackGround(CommonData.size);

            this.tileGroup = new egret.Group();
            this.tileGroup.x = this.tileGroup.y = this.gap;
            this.addElement(this.tileGroup);

            this.contentGroup = new egret.Group();
            this.contentGroup.percentHeight = this.contentGroup.percentWidth = 100;
            this.contentGroup.touchEnabled = false;
            this.addElement(this.contentGroup);
        }</pre>

<p>先看backUIAsset，由于图片素材只是一个小的纯色圆角矩形，使用scale9Grid属性来设置九宫格缩放，这样设置了宽高就不会变形了。这里backGroundGroup设置了一个layout来确定布局。设置好间距以及行列数，向容器里面添加子项时就自动设置了位置了，不需要设置子项的x，y属性。TileLayout会自动布局。</p>
<pre class="lang:as decode:true">        private initBackGround(size:number):void{
            //背景格子
            var tile:egret.UIAsset;
            var totalNum:number = size * size;
            for(var i:number = 0;i &lt; totalNum ; i++)
            {
                tile = new egret.UIAsset();
                tile.width = tile.height = TileUI.size;
                tile.source = "source.backtile";
                this.backGroundGroup.addElement(tile);
            }
        }</pre>

<p><strong>③制作单元格————自定义属性</strong></p>
<p>单元格使用TileUI来定义。单元格有一个很重要的属性就是单元格的数据，这里使用value属性来表示。</p>
<pre class="lang:as decode:true">        private valueChanged:boolean;
        private _value:number;
        /**
         * 格子的数字
         */
        public get value():number{
            return this._value;
        }

        public set value(value:number){
            if(value == this._value){
                return;
            }
            this.valueChanged = true;
            this._value = value;
            this.invalidateProperties();
        }

        public commitProperties():void{
            if(this.valueChanged){
                this.valueChanged = false;
                this.updateValue();
            }
        }

        private updateValue():void{
            var mi:number = Math.log(this._value)/Math.log(2);
            this.source = "number.number_"+mi;
        }</pre>

<p>这里使用了invalidateProperties和commitProperties来完成属性的失效验证。当设置value的时候调用invalidateProperties，失效属性，GUI框架在下一次渲染的时候会调用commitProperties来完成属性的提交。失效验证简单说就是一种延迟应用改变的措施，这种失效验证在egret的GUI组件内部随处可见。这种自定义属性的例子只是其中之一，当组件的commitProperties方法被调用时组件已经准备完毕，所有的皮肤部件也匹配上了。这样也不用担心应用属性的时候报空的情况。这里通过设置TileUI的source属性来改变数字。还记得一开始的resource.json加载的number.json么。</p>
<pre class="lang:as decode:true">{
"frames": {
    "number_1": {"x":107, "y":214, "w":106, "h":106, "offX":262,"offY":159},
    "number_10": {"x":0, "y":321, "w":106, "h":106, "offX":262,"offY":159},
    "number_11": {"x":0, "y":214, "w":106, "h":106, "offX":262,"offY":159},
    "number_12": {"x":0, "y":107, "w":106, "h":106, "offX":262,"offY":159},
    "number_13": {"x":0, "y":0, "w":106, "h":106, "offX":262,"offY":159},
    "number_2": {"x":214, "y":321, "w":106, "h":106, "offX":262,"offY":159},
    "number_3": {"x":214, "y":214, "w":106, "h":106, "offX":262,"offY":159},
    "number_4": {"x":214, "y":107, "w":106, "h":106, "offX":262,"offY":159},
    "number_5": {"x":214, "y":0, "w":106, "h":106, "offX":262,"offY":159},
    "number_6": {"x":107, "y":321, "w":106, "h":106, "offX":262,"offY":159},
    "number_7": {"x":321, "y":0, "w":106, "h":106, "offX":262,"offY":159},
    "number_8": {"x":107, "y":107, "w":106, "h":106, "offX":262,"offY":159},
    "number_9": {"x":107, "y":0, "w":106, "h":106, "offX":262,"offY":159}

},
"file": "number.png"
}</pre>

<p>这个sheet记录的每一张图也有一个名称比如2这个数字就是number_1，加上number这个sheet名称使用”.”符号连接，所以获取”2”这个数字的图片就可以这样写this.source = “number.number_1”。根据值的不同取2的对数得到相应的下标数字。</p>
<p><strong>④制作胜负界面————自定义组件状态</strong></p>
<p>游戏结束之后会出现胜负的界面。但是胜负界面应该是两套不同的素材，那么我们是不是可以制作两个皮肤来根据胜负来切换？这样当然可以。但是，还有一种更简单的办法就是使用自定义状态，只需要一个皮肤类就可以完成两种视图的切换。</p>
<p>新建一个ResultWindow类继承自SkinnableComponent，然后新建ResultWindowSkin。在ResultWindowSkin的构造函数中定义两个状态win和failed。</p>
<pre class="lang:as decode:true">        public constructor(){
            super();
            this.states = ["win","failed"];
        }</pre>

<p>然后加入两个皮肤部件button和resultUI</p>
<pre class="lang:as decode:true">        private static _skinParts:Array&lt;string&gt; = ["button","resultUI"];

        public get skinParts():Array&lt;string&gt;{
            return ResultWindowSkin._skinParts;
        }

        /**
         * 按钮
         */
        public button:egret.Button;

        /**
         * 结果文本
         */
        public resultUI:egret.UIAsset;</pre>

<p>在createChildren里面将皮肤部件布局好位置。最后重写commitCurrentState方法来根据对应的状态来改变部件的skin。</p>
<pre class="lang:as decode:true">        public commitCurrentState():void {
            super.commitCurrentState();
            if(this.currentState == "win")
            {
                this.resultUI.source = "source.result_sucess";
                this.button.skinName = ContinueButtonSkin;
            }
            else
            {
                this.resultUI.source = "source.result_failed";
                this.button.skinName = ResetButtonSkin;
            }
        }</pre>

<p>这样还没有完，我们需要在主机组件里面定义何时是何种状态，在ResultWindow中重写getCurrentSkinState来定义皮肤状态。</p>
<pre class="lang:as decode:true">        private _win:boolean = false;
        public get win():boolean{
            return this._win;
        }

        public set win(value:boolean){
            if(value == this._win)
                return;
            this._win = value;
            this.invalidateSkinState();
        }

        public getCurrentSkinState():string {
            return this.win?"win":"failed";
        }</pre>

<p>当外界设置win的值时调用invalidateSkinState来失效皮肤状态，在框架下次渲染的时候，调用SkinnableComponent的validateSkinState方法同时通过getCurrentSkinState来获取皮肤状态，通知皮肤去改变视图。这又是失效验证机制的一次完美使用。我们只需要调用失效，然后重写对应的验证方法就行了。</p>
<p>egret的GUI库，集合了Flex和<a href="http://flexlite.org" target="_blank" rel="external">FlexLite</a>的核心思想。实现了自动布局，皮肤分离，组件的三层失效验证机制。快来膜拜作者<a href="http://blog.domlib.com/" target="_blank" rel="external">DOM</a>大神吧。</p>
<p><strong>6.优化游戏</strong></p>
<p><strong>①使用对象池</strong></p>
<p>在游戏里面随着游戏的进行，每一次移动都有一个格子组件TileUI的创建，当游戏久了会造成巨大的内存开销。这里使用对象池技术。当一个对象使用完毕时，放入对象池，下次需要使用时取出来，这样避免了对象的重复创建，节约了内存。具体的实现参考ObjectPool这个类。具体使用在MainGameUI里面，如下：</p>
<pre class="lang:as decode:true">        /**
         * 创建一个格子
         */
        public createTile(tileVO:TileVO):void{
            var tile:TileUI = &lt;TileUI&gt;(ObjectPool.getPool("game.TileUI").borrowObject());  //从对象池创建
           ......
           ......
        }</pre>

<p>当对象池里面没有TileUI时使用会new一个出来，否则直接从对象池获取。</p>
<pre class="lang:as decode:true">        /**
         * 清除一个格子
         */
        public removeTile(tileVO:TileVO):void{
            var tileUI:TileUI = this.getTileUI(tileVO.x , tileVO.y);
            if(tileUI){
                this.tileGroup.removeElement(tileUI);
                ObjectPool.getPool("game.TileUI").returnObject(tileUI);
            }
        }</pre>

<p>当格子销毁时，回收到对象池，以备下次使用。</p>
<p>另外由于js没有提供弱引用特性，在对象池里面的对象要彻底销毁就需要手动了。</p>
<p><strong>②针对不同设备</strong></p>
<p>游戏在PC我们使用键盘上的方向键操控游戏，但是在移动设备上就需要使用手势来操控了，通过egret.Browser.getInstance().isMobile这个值来获取平台 。具体实现在ApplicationMediator中：</p>
<pre class="lang:as decode:true">            //为PC和移动端设置不同的移动策略
            if(!egret.Browser.getInstance().isMobile)
            {
                var self = this;
                document.addEventListener("keydown",function(event:KeyboardEvent){
                    switch (event.keyCode) {
                        ....省略键盘事件......
                    }
                });
            }
            else
            {
                this.main.addEventListener(egret.TouchEvent.TOUCH_BEGIN , this.mouseDownHandle , this)
            }</pre>

<p>由于egret目前没有提供手势的API，这里我们自己实现手势。监听TOUCH_BEGIN，TOUCH_MOVE，TOUCH_END和LEAVE_STAGE这四个事件。具体实现如下：</p>
<pre class="lang:as decode:true">        private downPoint:egret.Point;
        private movePoint:egret.Point;
        private mouseDownHandle(event:egret.TouchEvent):void
        {
            egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_MOVE,this.stage_mouseMoveHandler,this);
            egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_END,this.stage_mouseUpHandler,this);
            egret.UIGlobals.stage.addEventListener(egret.Event.LEAVE_STAGE,this.stage_mouseUpHandler,this);

            this.downPoint = this.main.globalToLocal(event.stageX, event.stageY);
        }

        private needMove:boolean;
        private stage_mouseMoveHandler(event:egret.TouchEvent):void{
            if(!this.movePoint)
                this.movePoint = new egret.Point();
            this.movePoint.x = event.stageX;
            this.movePoint.y = event.stageY;
            if (this.needMove)
                return;
            this.needMove = true;
        }

        public stage_mouseUpHandler(event:egret.Event):void{
            egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_MOVE,
                this.stage_mouseMoveHandler,
                this);
            egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_END,
                this.stage_mouseUpHandler,
                this);
            egret.UIGlobals.stage.addEventListener(egret.Event.LEAVE_STAGE,
                this.stage_mouseUpHandler,
                this);
            if(this.needMove){
                this.updateWhenMouseUp();
                this.needMove = false;
            }
        }

        /**
         * 移动设备上，判断移动方向
         */
        private updateWhenMouseUp():void
        {
            var p:egret.Point = this.main.globalToLocal(this.movePoint.x, this.movePoint.y ,egret.Point.identity);
            var offSetX:number = p.x - this.downPoint.x;
            var offSetY:number = p.y - this.downPoint.y;

            if(offSetY&lt;0 &amp;&amp; Math.abs(offSetY)&gt;Math.abs(offSetX))  //上
            {
                this.doMove(0);
            }
            else if(offSetX&gt;0 &amp;&amp; offSetX&gt;Math.abs(offSetY))  //右
            {
                this.doMove(1);
            }
            else if(offSetY&gt;0 &amp;&amp; offSetY&gt;Math.abs(offSetX))  //下
            {
                this.doMove(2);
            }
            else if(offSetX&lt;0 &amp;&amp; Math.abs(offSetX)&gt;Math.abs(offSetY))  //左
            {
                this.doMove(3);
            }
        }</pre>

<p><strong>③动画效果</strong></p>
<p>游戏里面格子的创建，移动，合并，都需要一个缓动效果来支持。这里面最大的问题就是，缓动效果是持续时间的，而往往数据的改变是一瞬间。比如：一个操作合并了两个格子，其中一个需要移动，并且移动完成后要移除掉，此时新的格子也要出现。但是往往数据层把这些数据是同时发过来的，所以我们需要调节时机来让效果更好。比如格子的创建，我们延迟100毫秒显示在舞台上，因为在创建的同时其他格子会移动，所以等其他格子移动完成了后显示出来比较好。再比如格子的合并，实际上就是一个格子移动，移动完成后消失，目标位置格子改变数字并且出现缩放效果。这样要注意的就是移动之前调整将移动的格子的层级显示在最下面，避免移动的时候挡在目标位置格子的上面。</p>
<p><strong>7.性能</strong></p>
<p>egret的工作流还是很高效的，工具也不少，架构设计集各家所长。最后发布游戏在PC上运行是满帧运行，比原版甚至更快。在手机上运行也不错，体验超过了某些原生语言开发的2048。</p>
<p>最后交出源代码：<a href="https://github.com/f111fei/2048egret" target="_blank" rel="external">点我传送</a></p>
<p>原始素材点我下载：<a href="http://xzper.qiniudn.com/wp-content/uploads/2014/06/2048素材.rar" target="_blank" rel="external">2048素材</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>2048是最近很火的一个小游戏，<a href="http://gabrielecirulli.github.io/2048/" target="_blank" rel="external">原版</a>就是用JavaScript写的。恰巧最近egret PublicBeta，观望和学习了一阵后，发现egret正好适合开发这类游戏。egret使用TypeScript作为开发语言，最终编译为JavaScript，正好和原始版本PK一下。</p>
<p>游戏预览：<a href="http://xzperproject.qiniudn.com/2048egret/launcher/release.html" target="_blank" rel="external">点我体验</a></p>
]]></summary>
    
      <category term="Egret" scheme="http://xzper.com/tags/Egret/"/>
    
      <category term="Egret" scheme="http://xzper.com/categories/Egret/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[新手引导—脚本设计]]></title>
    <link href="http://xzper.com/2014/06/15/%E6%96%B0%E6%89%8B%E5%BC%95%E5%AF%BC%E2%80%94%E8%84%9A%E6%9C%AC%E8%AE%BE%E8%AE%A1/"/>
    <id>http://xzper.com/2014/06/15/新手引导—脚本设计/</id>
    <published>2014-06-14T19:49:56.000Z</published>
    <updated>2014-08-24T08:37:44.000Z</updated>
    <content type="html"><![CDATA[<p>最近在做游戏的新手引导模块。由于是关卡式的引导，所以很适合用读取引导脚本的方式来开发。</p>
<p><strong>脚本和命令配置</strong></p>
<a id="more"></a>

<p>程序中通过GuideLib这个类来解析命令配置和脚本。脚本以行为单位运行，每一行就是一条指令。每一条指令有指令的名称和指令的参数。就像下面这样。</p>
<p><pre class="lang:xhtml decode:true">goto step:+1<br>showArrow direction:down position:[200,300] clickRect:[100,30]<br>delayCall step:-1 time:2</pre><br>第一个单词表示命令名称，然后后面的参数以空格分开，参数名称和参数值用冒号分开。由若干条命令就组成了一个完整的脚本。但是光有脚本还是不够，从脚本里面我们看不出来参数的类型。比如position应该是一个Number数组，所以我们还需要一个配置文件来说明每一条命令的详细细节。这里配置文件用xml表示。</p>
<p><pre class="lang:xhtml decode:true">&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;commands&gt;<br>    &lt;command name=”goto”&gt;<br>        &lt;param name=”step” type=”String”/&gt;<br>    &lt;/command&gt;<br>    &lt;command name=”delayCall”&gt;<br>        &lt;param name=”step” type=”String”/&gt;<br>        &lt;param name=”time” type=”Number”/&gt;<br>    &lt;/command&gt;<br>    &lt;command name=”showArrow”&gt;<br>        &lt;param name=”direction” type=”String”/&gt;<br>        &lt;param name=”position” type=”Array_Number”/&gt;<br>        &lt;param name=”clickRect” type=”Array_Number”/&gt;<br>    &lt;/command&gt;<br>&lt;/commands&gt;</pre><br>可以看到param有一个type的属性用来说明参数类型。查看GuideLib的源代码会发现有一个ITypeAdapter，这个就是用来解析参数类型的，在解析脚本的时候，调用ITypeAdapter的convert方法自动将脚本中param的值由字符串转换为命令配置文件中的type。默认的类型解释器是TypeAdapter。</p>
<p><pre class="lang:as decode:true">        /**</pre></p>
<pre><code>     * 将命令参数的值转换成正确的类型
     */
    <span class="keyword">public</span> <span class="keyword">function</span> convert(<span class="class"><span class="keyword">type</span>:<span class="title">String</span> , <span class="title">value</span>:<span class="title">String</span>):*</span>
    {
        var result:String = value;
        <span class="keyword">if</span>(<span class="class"><span class="keyword">type</span> </span>== <span class="string">"String"</span>)
        {
            <span class="keyword">return</span> value;
        }
        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="class"><span class="keyword">type</span> </span>== <span class="string">"Boolean"</span>)
        {
            <span class="keyword">return</span> value==<span class="string">"true"</span>?<span class="keyword">true</span>:<span class="keyword">false</span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="class"><span class="keyword">type</span>.<span class="title">indexOf</span></span>(<span class="string">"Array"</span>) == <span class="number">0</span>)
        {
            <span class="keyword">if</span>(<span class="class"><span class="keyword">type</span>.<span class="title">split</span></span>(<span class="string">"_"</span>,<span class="number">2</span>).length&amp;lt;<span class="number">2</span>)
            {
                <span class="keyword">return</span> convertStringToArray(<span class="string">"String"</span> , value);
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">return</span> convertStringToArray(<span class="class"><span class="keyword">type</span>.<span class="title">split</span></span>(<span class="string">"_"</span>)[<span class="number">1</span>] , value);
            }
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">return</span> getDefinitionByName(<span class="class"><span class="keyword">type</span>)</span>(value);
        }
    }&lt;/pre&gt;
</code></pre><p><strong> 执行命令</strong></p>
<p>GuideLib将通过getScript将脚本解析成一个数组。每一个元素就是一条命令，然后交给GuideSystem去处理每一条命令。在GuideSystem中又可以看到一个ICommandAdapter。这个就是用来运行命令的解释器，调用run方法执行命令。默认的命令解释器是CommandAdapter。</p>
<p><pre class="lang:as decode:true">        /**</pre></p>
<pre><code>     * 默认的函数库
     */
    <span class="keyword">private</span> <span class="keyword">var</span> guideFunction:GuideFunction = <span class="keyword">new</span> GuideFunction();
    <span class="comment">/**
     * 运行命令
     * @param command 命令的名称
     * @param param 命令的参数
     * @param guideSystem 向导管理
     */</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">(command:String, param:Object, guideSystem:GuideSystem)</span><span class="type">:void</span>
    </span>{
        <span class="keyword">var</span> fun:Function;
        <span class="keyword">if</span>(guideFunction.hasOwnProperty(command))  <span class="comment">//函数库中存在这个函数</span>
            fun = guideFunction[command];
        fun(param);
        <span class="keyword">if</span>(guideSystem.auto)
            guideSystem.doNext();
    }&lt;/pre&gt;
</code></pre><p>GuideFunction就是默认的函数库，如果命令配置是调用其他的类的函数，可以自己实现这个run方法。</p>
<p><strong>函数库的自定义</strong></p>
<p>脚本中的每一条命令实际上就是调用的某一个类的某一个函数。默认情况下这个类就是GuideFunction。所以我们要实现功能，为GuideFunction添加方法就行了。方法名保存和命令名一致，参数就是命令的参数组成的Object。例如delayCall这个命令的实现</p>
<p><pre class="lang:as decode:true">/**</pre></p>
<ul>
<li>延时 多少秒执行哪一步<br>*/<br>public function delayCall(param:Object):void<br>{<br> var step:String = param[“step”];<br> var time:Number = param[“time”];<br> GuideSystem.getInstance().auto = false;<br> setTimeout(function():void{<pre><code> GuideSystem.getInstance().<span class="keyword">auto</span> = <span class="literal">true</span>;
 GuideSystem.getInstance().<span class="keyword">goto</span>(<span class="keyword">step</span>);
</code></pre> } , time*1000);<br>}<br>我们可以根据业务逻辑的不同，自由的定制参数类型解析器，命令函数解析器和函数库。</li>
</ul>
<p><strong>脚本编辑器</strong></p>
<p>脚本编辑器是一个可视化的工具，能方便快速的创建脚本，你只需要先写好命令配置xml。编辑器会根据xml自动生成命令列表，然后向脚本中自由的加入命令。预览图：</p>
<p><img src="http://xzper.qiniudn.com/wp-content/uploads/2014/06/QQ截图201406162029511.png" alt=""></p>
<p>新手引导示例：<a href="http://xzper.qiniudn.com/wp-content/uploads/2014/06/Guide.rar" target="_blank" rel="external">Guide</a></p>
<p>脚本编辑器：<a href="http://xzper.qiniudn.com/wp-content/uploads/2014/06/ScriptEditor.rar" target="_blank" rel="external">ScriptEditor</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>最近在做游戏的新手引导模块。由于是关卡式的引导，所以很适合用读取引导脚本的方式来开发。</p>
<p><strong>脚本和命令配置</strong></p>
]]></summary>
    
      <category term="未分类" scheme="http://xzper.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从2048游戏谈PureMVC]]></title>
    <link href="http://xzper.com/2014/04/27/%E4%BB%8E2048%E6%B8%B8%E6%88%8F%E8%B0%88PureMVC/"/>
    <id>http://xzper.com/2014/04/27/从2048游戏谈PureMVC/</id>
    <published>2014-04-26T18:03:56.000Z</published>
    <updated>2014-08-24T08:37:44.000Z</updated>
    <content type="html"><![CDATA[<p>最近2048比较火，然后我又正好在学习pureMVC，之前对于pureMVC的了解只停留在理论上，正好拿这个游戏来练练手。废话不多说，游戏预览：<a href="http://xzper.tk/wp-content/uploads/2014/04/2048flexlite/Main.html" target="_blank" rel="external">2048</a><a href="http://xzper.qiniudn.com/wp-content/uploads/2014/04/mvc结构图.png" target="_blank" rel="external">
</a></p>
<a id="more"></a>

<p><strong>1.MVC的基本运行原理</strong></p>
<p><img src="http://xzper.qiniudn.com/wp-content/uploads/2014/04/mvc结构图.png" alt="mvc结构图"></p>
<p><span style="font-family: 微软雅黑;"><span>图：</span></span><span><span style="font-family: Calibri;">MVC</span><span style="font-family: 微软雅黑;">结构图（实线——&gt;表示依赖；虚线</span><span style="font-family: Calibri;">——&gt;</span><span style="font-family: 微软雅黑;">表示事件</span><span style="font-family: Calibri;">/</span></span><span style="font-family: 微软雅黑;"><span>通知等</span><span>）</span></span></p>
<ul>
<li><p><strong>模型（Model）</strong> 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。“模型”有对数据直接访问的权力，例如对数据库的访问。“模型”不依赖“视图”和“控制器”，也就是说，模型不关心它会被如何显示或是如何被操作。但是模型中数据的变化一般会通过一种刷新机制被公布。为了实现这种机制，那些用于监视此模型的视图必须事先在此模型上注册，从而，视图可以了解在数据模型上发生的改变。（比较：<a href="http://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F" title="观察者模式" target="_blank" rel="external">观察者模式</a>（<a href="http://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" title="软件设计模式" target="_blank" rel="external">软件设计模式</a>））</p>
</li>
<li><p><strong>视图（View）</strong>能够实现数据有目的的显示（理论上，这不是必需的）。在视图中一般没有程序上的逻辑。为了实现视图上的刷新功能，视图需要访问它监视的数据模型（Model），因此应该事先在被它监视的数据那里注册。</p>
</li>
<li><p><strong>控制器（Controller）</strong>起到不同层面间的组织作用，用于控制应用程序的流程。它处理事件并作出响应。“事件”包括用户的行为和数据模型上的改变。</p>
</li>
</ul>
<p><strong>2.pureMVC中的Proxy ， Mediator，Command</strong></p>
<ul>
<li><strong>Proxy</strong> <strong>数据层(Model)   </strong>由于数据不关心视图是如何显示的，所以如果数据改变了引起了视图的改变，为了做到解耦，Proxy通过sendNotification方法向视图(Mediator)或者控制器(Command)发送通知，而不是获取视图实例调用里面的方法，通知发出去了Proxy的任务就完成了。另外Proxy通常还提供一些公共方法(public function)供控制器(Command)直接调用，从而改变数据（<strong><span style="text-decoration: underline;">注意：Proxy是不接收Notification的</span></strong>）。</li>
<li><strong>Mediator视图层(View)  </strong>中介器(Mediator)持有对应视图的引用，他负责接收消息和发送消息，所以一般情况下Mediator只含有处理消息和发送消息的代码，不会有复杂的逻辑处理，逻辑处理放在视图组件(viewComponent)里面(<strong><span style="text-decoration: underline;">注意：如果你的Mediator含有过多的公共方法不用想肯定有问题</span></strong>)。当数据改变，Mediator收到消息时，调用viewComponent暴露的公共方法，处理视图的改变。另外，Mediator可以为视图组件添加事件监听器(addEventListener),发送消息(sendNotification)通知控制器(Command)视图的改变，而不是直接调用Proxy的公共方法改变数据。<strong>
</strong></li>
<li><strong>Command控制器(Controller) </strong>这个的使用比较灵活。最常用的就是收到Mediator发来的消息，调用Proxy的公共方法改变数据。还有可能是收到某一个Proxy的消息，调用另外一个Proxy改变数据等等。他起到了一个桥梁的作用。协调Mediator和Proxy，Proxy1和Proxy2，Mediator1和Mediator2。所以Command也不应该有复杂的逻辑。<br><strong>3.从实例学习pureMVC</strong></li>
</ul>
<p>先来看下工程目录结构</p>
<p><img src="http://xzper.qiniudn.com/wp-content/uploads/2014/04/2048工程结构.png" alt="2048工程结构"><strong>1.xxxPrepCommand </strong>框架初始化时，注册对应必须的Command和Proxy。（另外说下由于FlexLite的组件需要在CreateComplete才能获取皮肤实例，所以Mediator的注册都是在viewComponent中完成的）</p>
<p><strong>2.GameCommand </strong>处理各类事务。比如 玩家按下了方向键，收到消息调用GridProxy的移动方法改变数据，比如GridProxy移动格子分数改变了，通知GameCommand 调用GameProxy的更新分数方法改变分数，比如处理重置游戏的事务，通知各个数据模块重置数据</p>
<p><strong>3.GameProxy </strong>处理游戏数据，比如更新分数，处理游戏结果</p>
<p><strong>4.GridProxy </strong>这个游戏的核心数据，操作每一个格子的数据，通知视图格子的移动，添加，删除，重置</p>
<p><strong>5.ApplicationMediator  </strong>监听键盘事件发送消息到GameCommand通知移动</p>
<p><strong>6.MainGameMediator  </strong>接收消息，调用MainGameUI的方法处理格子的移动，添加，删除，重置，以及接收游戏结果，显示结果面板</p>
<p><strong>7.**</strong>MainMenuMediator<strong> 接收更新分数的消息，调用MainGameUI的方法更新分数与重置</strong><br>**</p>
<p><strong>8.ResultWindowMediator </strong>发送游戏重置的消息，以及自销毁。这是一个短生命的Mediator</p>
<p>其实这个游戏本来一开始我是用Flex开发的，最后完成的时候发现swf太大加载太慢，于是换成了比较小巧的FlexLite。整个移植过程没有动Model和Controller的一行代码，Mediator改动的也很少。充分说明了MVC的代码重用和关注点分离。这也是我用pureMVC的初次尝试，可能理解还有很多不到位和错误的地方，在此抛砖引玉。最后附上源代码下载：</p>
<p>FlexLite版：<a href="http://xzper.qiniudn.com/wp-content/uploads/2014/04/2048flexlite.rar" target="_blank" rel="external">2048flexlite</a></p>
<p>Flex版：<a href="http://xzper.qiniudn.com/wp-content/uploads/2014/04/2048flex.rar" target="_blank" rel="external">2048flex</a></p>
<p>参考文章：</p>
<p>[1] <a href="http://www.cnblogs.com/skynet/archive/2012/12/29/2838303.html" target="_blank" rel="external">http://www.cnblogs.com/skynet/archive/2012/12/29/2838303.html</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>最近2048比较火，然后我又正好在学习pureMVC，之前对于pureMVC的了解只停留在理论上，正好拿这个游戏来练练手。废话不多说，游戏预览：<a href="http://xzper.tk/wp-content/uploads/2014/04/2048flexlite/Main.html" target="_blank" rel="external">2048</a><a href="http://xzper.qiniudn.com/wp-content/uploads/2014/04/mvc结构图.png" target="_blank" rel="external">
</a></p>
]]></summary>
    
      <category term="框架" scheme="http://xzper.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在路上]]></title>
    <link href="http://xzper.com/2014/04/21/%E5%9C%A8%E8%B7%AF%E4%B8%8A/"/>
    <id>http://xzper.com/2014/04/21/在路上/</id>
    <published>2014-04-21T15:51:00.000Z</published>
    <updated>2014-08-24T08:37:44.000Z</updated>
    <content type="html"><![CDATA[<p>博客建站以来也快有一个月了，每次想写点什么都不得而终。究其原因还是自己太懒了。所以现在趁自己不懒的时候，记录自己在前端开发路上的点滴。 希望此文能做一个好的开始，以此共勉。</p>
<p>flash开发到了如今，也到了日落西山，穷途末路的时候吧。从官方上来看，Adobe已经对Flash力不从心了，停止了移动端的FP的更新 ，把Flex捐给了Apache 。从开发者来看，大量新技术如html5，cocos2d，unity3D的出现让开发者有了更多的选择，好多flash老程序员都转行了，这似乎成了一个趋势  。 从市场上来看，如今的页游市场，已经不复当年的辉煌了，前篇一律的感觉玩家会卖账么？而且各种坑爹的运营导致flash游戏的名声越来越臭。总之，对于即将毕业的我选择flash开发这条路显然不是一个明智的选择。</p>
<a id="more"></a>

<p>但是对于一个能把一件衣服从新买到一直穿到破的人来说，东西用惯了想换下来，不是那么容易的。至少目前这件衣服对于我来说还是新的就足够了，穿破了再说。我喜欢as3，喜欢flex，喜欢flash这就够了。我欣赏as3的语法，纯OOP语言很美，我欣赏flex架构，他的组件渲染机制让我折服。我欣赏flash游戏的外在的千变万化，内在的结构统一。尽管as3一直被人们说性能低下，但作为一个as3程序员，时刻都在为如何提升性能，而不断优化自己的代码这难道不是一种美么？</p>
<p>从2012年5月到现在，接触flash编程也快有2年了。然而看了看flash的<a href="http://www.xmind.net/m/bCk4/" target="_blank" rel="external">技能树</a>当真自愧不如。最近没事的时候我喜欢反编译一些看起来不错的游戏和软件，看着别人的代码，体会别人的开发思路。收获不少，同时也在感叹自己会的东西太少了。我发现，看博客，看开源项目或者成熟的商业作品的源码对自己的提升很有用。之前1年的学习可能仅仅只是让我上路了，知道怎么写代码，如何实现。但这些显然是不够的，要真真的独当一面要会的东西还有太多。</p>
<p>对于前端开发，一些人认为就是显示下界面，放放特效之类的，其实哪有那么简单。这里按照技能书大致列举下我做前端的过程自己会与不会的知识。认为写前端很轻松的可以体会下。</p>
<p><strong>1.显示对象基础</strong>。其实大多人对前端的认识也就留在这一块了。以为也就是操作下显示对象，把数据显示出来。且不说下面的11条，就这一条，也不是一个人能半年之内搞精通的。这个是基础，至少目前我还不能在不看API的情况下说出每一个显示对象的属性和方法，以及应用。</p>
<p><strong>2.特效和动画</strong>。对于一部分特效我们搞开发的做不来，还得交给美工特效大大们去做，还有一部分特效是可以用代码写的。那我们需要知道什么，做什么呢。1.矢量动画和帧动画的区别。2.如何用代码写动画，比如各类缓动，各类滤镜动画，bitmap操作，matrix操作等等。目前比较流行的动画开源库和引擎有，TweenLite(感觉体积比较大，所以一般自己实现)，SpriteSheet ，DragonBones，这2个久仰大名有待学习。还有个PixelBender也是最近才知道的，搞的是高级图像处理，渣渣表示学不来。</p>
<p><strong>3.媒体处理</strong>。之前写组件的时候写过音视频播放啊之类的(最近在倒腾bilibili的弹幕播放器，不弄不知道一弄才发现很是复杂。关于视频流的分段处理，流的数据生成模式，与主流视频网站的对接看的头都大了) ，后来接触到了FMS，玩过P2P通讯的视频语音文字图片文件的共享与收发，其实这也只是冰山一角。FMS主要的在于直播，点播方面比较好用。至于那些编码处理之类的那我也只是只闻其名了。媒体处理类的坑很深估计掉下去了就爬不起来了。</p>
<p><strong>4.文本处理</strong>。文本引擎FTE和TLF，看名字就看晕了。TLF是基于FTE的，对FTE做了一次封装，感觉这和Adobe的OSMF是基于底层的媒体处理类似。这些目前没有深入了解。对于一般的文本处理，目前遇到的图文混排算上要求最高的吧，我用的是RichTextField解决的，感觉还不错。最近关于文本的敏感词过滤好像也是要学的。</p>
<p><strong>5.网络通信</strong>。资源类，各种Loader的使用，不过这些东西在项目里面最好做一下封装，目前比较喜欢用的是FlexLite里面的加载器感觉封装的比较彻底。流处理，URLStream啊NetStream这类的东西很多。后台交互，Socket，AMF(这个比较好用，用来实现HTTP通讯，实际上Flex的RemoteObject就是基于这个的)，另外还有RTMP，RTMFP协议，FMS上面用到的。</p>
<p><strong>6.文件访问</strong>。在web上面的文件访问用FileReference来进行读写，可惜是需要把整个文件加载到浏览器内存才能操作。air的文件读写不用。ShareObject的使用俗称FlashCookie，存一些简单信息比较好用。对象序列化反序列化的ByteArray操作，文件操作少不了这个的。以及反射的使用。还有恶心的Flash跨域问题。</p>
<p><strong>7.性能优化</strong>。每个ASer都在与名为性能的怪物战斗。这方面需要了解Flash的垃圾回收机制。常用的优化技巧有 ，事件的监听和移除，强引用弱引用，总之就是想办法去除不必要的引用，以便垃圾回收器能回收对象实例防止内存泄露。对于CPU的优化，主要是渲染方式的优化，像bitmap几个方法的快慢啊，矢量图与位图的区别啊。还有一些框架优化这类的。</p>
<p><strong>8.flex</strong>。由于项目需要我完整的学习了FlexLite这个框架，核心思想就是Flex来的。我很喜欢这种架构设计(第2次说了)，他的组件生命周期，3层验证失效机制，布局管理，皮肤适配，UI层管理。无论哪一个拿出来都要说好久。所以这里就不说了，有时间单独补上。</p>
<p><strong>9.air</strong>。air里面有很多新的东西我都没接触到，这个也是一个领域啊。不过我还是更喜欢web开发一下。</p>
<p><strong>10.图形基础</strong>。说是图形基础，对于我这个色盲来说，真的很难。什么色相，颜色矩阵，bitmap操作什么的有待学习，教材已经订好，ActionScript3.0图像处理基础教程，根本一点都不基础好么。</p>
<p><strong>11.架构设计</strong>。这也是目前我着重学习的，毕竟一个人要想独当一面这个东西不可或缺。目前很好的一个学习办法就是阅读商业项目的成熟代码去体会，然后在平时的码码中实际应用上去。</p>
<p><strong>12.开源库</strong>。一个纯OOP开发语言当然离不开各类开源库以及引擎。上面说的几个是做动画用的比较多的开源库。像 UI框架之类的有,官方的Flex(Flex的架构设计简直赞，第3次了喂，可惜体积太大了), Aswing(没用过不说了) , FlexLite (很不错的一款国人开发的UI框架，包含了Flex4的精髓) ，Features(和Starling配合)。物理引擎有 Box2D ， Nape，这部分我暂时没接触。3D引擎有官方的3d底层Stage3D , 以及Away3D ，PV3D , Flar3D ，这些我都鲜有接触。MVC框架有 官方的Cairngorm(据说太大，所以应用的不是很广) ， pureMVC(最近看的比较多的，蛮不错)，Robotlegs(貌似比前者好，最近准备学)。游戏引擎类的有 Starling(移动平台应用比较多，没时间学) ， D5Power(国人开发的rpg引擎，比较感兴趣，很有可能是我以后学rpg开发的敲门砖)。还有各种开源的小组件，开源的工具库这些的，都是每个Aser或多或少需要了解的东西，如果能深入理解源码那就更好了。</p>
<p>还有很多知识都是没有涉及到的比如各类游戏算法啊，工具啊之类的。<strong>希望此文能为我自己立一面旗帜(俗称立Flag)，在今后的学习路上，像这面旗帜看齐，总之，那句话怎么说来着，我不在乎路的尽头有什么，我只在乎路边的风景，路还很长，且行且珍惜</strong>。</p>
]]></content>
    <summary type="html"><![CDATA[<p>博客建站以来也快有一个月了，每次想写点什么都不得而终。究其原因还是自己太懒了。所以现在趁自己不懒的时候，记录自己在前端开发路上的点滴。 希望此文能做一个好的开始，以此共勉。</p>
<p>flash开发到了如今，也到了日落西山，穷途末路的时候吧。从官方上来看，Adobe已经对Flash力不从心了，停止了移动端的FP的更新 ，把Flex捐给了Apache 。从开发者来看，大量新技术如html5，cocos2d，unity3D的出现让开发者有了更多的选择，好多flash老程序员都转行了，这似乎成了一个趋势  。 从市场上来看，如今的页游市场，已经不复当年的辉煌了，前篇一律的感觉玩家会卖账么？而且各种坑爹的运营导致flash游戏的名声越来越臭。总之，对于即将毕业的我选择flash开发这条路显然不是一个明智的选择。</p>
]]></summary>
    
      <category term="感悟" scheme="http://xzper.com/categories/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
</feed>
