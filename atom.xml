<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[xzper]]></title>
  <subtitle><![CDATA[前行在被夕阳染红的街道]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xzper.com/"/>
  <updated>2015-05-11T16:05:40.563Z</updated>
  <id>http://xzper.com/</id>
  
  <author>
    <name><![CDATA[xzper]]></name>
    <email><![CDATA[f111fei1@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[一次曲折的调试经历]]></title>
    <link href="http://xzper.com/2015/05/11/%E4%B8%80%E6%AC%A1%E6%9B%B2%E6%8A%98%E7%9A%84%E8%B0%83%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    <id>http://xzper.com/2015/05/11/一次曲折的调试经历/</id>
    <published>2015-05-11T13:31:26.000Z</published>
    <updated>2015-05-11T16:05:27.000Z</updated>
    <content type="html"><![CDATA[<p>前不久在FlexLite的开发者群里面遇到一个开发者的提问，说是在使用List的时候水平滚动条的大小有错误。截图大概是下面这样：</p>
<p><img src="http://xzper.qiniudn.com/2015/05/01.png" alt=""></p>
<a id="more"></a>

<p>可以看到水平滚动条的宽度是不对的。经过简单的了解，发现代码没错。本着(好)助(奇)人(害)为(死)乐(猫)的精神，决定找出问题所在。我简化代码，写了个DEMO，也复现了这个问题。代码大致如下只有两个类：<br>主类：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">FlexLiteTest</span><span class="params">()</span>
</span>{
    super();
    Injector.mapClass(Theme, VectorTheme);
    Debugger.initialize(stage);
}

override <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">createChildren</span><span class="params">()</span>:<span class="title">void</span>
</span>{
    <span class="keyword">var</span> <span class="keyword">array</span>:<span class="keyword">Array</span> = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> i:int = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) 
    {
        <span class="keyword">array</span>.push(i);
    }
    <span class="keyword">var</span> <span class="keyword">list</span>:<span class="keyword">List</span> = <span class="keyword">new</span> <span class="keyword">List</span>();
    <span class="keyword">list</span>.x = <span class="number">10</span>;
    <span class="keyword">list</span>.y = <span class="number">10</span>;
    <span class="keyword">list</span>.skinName = MyListSkin;
    <span class="keyword">list</span>.width = <span class="number">400</span>;
    <span class="keyword">var</span> hLayout:HorizontalLayout = <span class="keyword">new</span> HorizontalLayout();
    hLayout.verticalAlign = VerticalAlign.CONTENT_JUSTIFY; 
    <span class="keyword">list</span>.layout = hLayout;
    <span class="keyword">list</span>.dataProvider = <span class="keyword">new</span> ArrayCollection(<span class="keyword">array</span>);
    this.addElement(<span class="keyword">list</span>);
}
</code></pre><p>List皮肤类：</p>
<pre><code><span class="package"><span class="keyword">package</span>
{</span>
    <span class="preprocessor"><span class="keyword">import</span> org.flexlite.domUI.skins.vector.ListSkin;</span>

    <span class="comment">/**
     * @author xzper
     */</span>
    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListSkin</span> <span class="keyword">extends</span> <span class="title">ListSkin</span>
    </span>{
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">MyListSkin</span><span class="params">()</span>
        </span>{
            <span class="keyword">super</span>();
        }

        <span class="keyword">override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">createChildren</span><span class="params">()</span><span class="type">:void</span>
        </span>{
            <span class="keyword">super</span>.createChildren();
            scroller.horizontalScrollBar.skinName = MyHScrollBarSkin;
        }
    }
}
<span class="preprocessor"><span class="keyword">import</span> org.flexlite.domUI.skins.vector.HScrollBarSkin;</span>

<span class="class"><span class="keyword">class</span> <span class="title">MyHScrollBarSkin</span> <span class="keyword">extends</span> <span class="title">HScrollBarSkin</span>
</span>{
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">createChildren</span><span class="params">()</span><span class="type">:void</span>
    </span>{
        <span class="keyword">super</span>.createChildren();
    }
}
</code></pre><p>代码大意很简单，就是想换一下List的水平滚动条的皮肤，有不想写重复代码于是就是继承自ListSkin和HScrollBarSkin写了个皮肤。</p>
<p>经过简单的一番排查，发现注释掉</p>
<pre><code><span class="attribute">list.skinName </span>=<span class="string"> MyListSkin; </span>
</code></pre><p>或者</p>
<pre><code><span class="attribute">scroller.horizontalScrollBar.skinName </span>=<span class="string"> MyHScrollBarSkin; </span>
</code></pre><p>最后的结果是没问题的，如下图：</p>
<p><img src="http://xzper.qiniudn.com/2015/05/02.png" alt=""></p>
<p>那么问题肯定就出在了那个滚动条皮肤上面了。细看代码，发现其实滚动条皮肤就重写了一个createChildren的方法，啥也没干。此时思维陷入僵局…看来此路不通。</p>
<p>既然是显示结果的问题，那么换种思路，从结果入手，滚动条的宽度比预期值小了很多，通过FlexLite框架自带的一个调试工具，可以清楚地看到运行时各个组件大小位置的实际值测量值和布局结果。调试工具需要在项目开始初始化</p>
<pre><code>Debugger.initialize(stage);
</code></pre><p>然后默认按F11开启。通过调试面板定位到滚动条，如下图：</p>
<p><img src="http://xzper.qiniudn.com/2015/05/03.png" alt=""></p>
<p>发现水平滚动条的宽度是对的，布局宽为400，但是皮肤的宽是错的。<br>因为FlexLite里面有两种皮肤，一种是Skin可显示对象版的皮肤和StateSkin非显示对象皮肤。这里用到的是继承自Skin的可显示对象皮肤。布局的宽和测量宽是一样的都是86。</p>
<p><img src="http://xzper.qiniudn.com/2015/05/04.png" alt=""></p>
<p>那么问题就出在这里了。滚动条皮肤的布局宽(layoutBoundsWidth)是错误的，理应该也是400。这时可以回到代码了，在适当的地方下断点，找到原因，问题就能解决了。</p>
<p>我给重写了下MyHScrollBarSkin的setLayoutBoundsSize，并在这里下断点。这样可以找出什么地方给MyHScrollBarSkin设置了一个错误的布局尺寸。</p>
<p><img src="http://xzper.qiniudn.com/2015/05/05.png" alt=""></p>
<p>启动程序。发现这个断点根本就进不去，也就是说没有任何地方设置水平滚动条的布局尺寸，那么滚动条的布局尺寸是哪里来的呢，通过UIComponent的源码发现，没有设置布局尺寸的话，通过getter方法获取到的layoutBoundsWidth值就是explicitWidth或者measuredWidth，显然这地方是使用的measuredWidth。看到这里，问题就变成了setLayoutBoundsSize这个方法为何没有被调用。</p>
<p>通过查看调用层次结构，发现本来setLayoutBoundsSize应该在UIAssets的updateDisplayList方法里面被调用的（因为SkinnableComponent继承自UIAssets，刷新显示列表的时候会设置皮肤的布局属性）。于是我在UIAssets的updateDisplayList方法里面下断点，尝试找到皮肤没有被布局的原因。由于updateDisplayList会被反复调用，为了更精确我给断点加了条件表达式这样会少很多麻烦。</p>
<p><img src="http://xzper.qiniudn.com/2015/05/06.png" alt=""></p>
<p><img src="http://xzper.qiniudn.com/2015/05/07.png" alt=""></p>
<p>因为只有滚动条才有value属性，用这个表达式可以确保断点每次进入时都是滚动条触发的。经过几次断点，发现问题是出了在一个scaleSkin的实例变量上面。这个变量不知是何原因变成了false，导致条件判断不通过，导致皮肤没有被布局。</p>
<p><img src="http://xzper.qiniudn.com/2015/05/08.png" alt=""></p>
<p>答案似乎近在眼前了，scaleSkin被设置成了false导致皮肤没有跟着主机组件进行缩放。那么找到设置scaleSkin这个值为false的位置就行了。理所当然的，我使用调用层次结构和查找引用的功能企图找到项目中设置这个值的地方，然而得到的结果却是除了初始化给这个属性赋值了一次true以外，没有任何地方给这个属性重新赋值。甚至使用了Ctrl+H全局搜索这个scaleSkin的字符串得到结果也是一样。这个结果难免让我无法接受。scaleSkin被莫名其妙地改了值？</p>
<p>既然这样，我决定改一下UIAssets的代码，将scaleSkin的定义方式从public的声明方式改为getter/setter方法，这样可以下断点调试何时设置了scaleSkin的值。</p>
<pre><code><span class="keyword">private</span> <span class="keyword">var</span> _scaleSkin:Boolean = <span class="literal">true</span>;
<span class="comment">/**
 * 是否缩放皮肤
 */</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span> <span class="title">scaleSkin</span><span class="params">()</span><span class="type">:Boolean</span>
</span>{
    <span class="keyword">return</span> _scaleSkin;
}
<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> <span class="title">scaleSkin</span><span class="params">(value:Boolean)</span><span class="type">:void</span>
</span>{
    _scaleSkin = value;
}
</code></pre><p>编译，运行。还没来得及设置断点，结果让我又惊有喜。这次运行结果居然是对的，我有点不敢相信，再次编译运行，结果还是对的。改回去，结果就是错的了。</p>
<p>心中暗骂，这他妈是什么gui。Flash编译器的bug？？？？反正不管怎样，这样写没错就是了，于是将解决方案告之。但是我心中总感觉似乎有哪里不对劲，难到这真的是编译器的bug？那么为什么将赋值皮肤的那一行去掉结果也没问题呢？</p>
<p>就在我神情恍惚之际，我一步一步地断点调试。发现一开始scaleSkin确实是true，然后某一个步骤之后scaleSkin就变成了false。我开始逐渐缩小这个区间，最后将目标锁定到了SkinnableComponent的这个函数里面</p>
<pre><code><span class="comment">/**
 * 卸载皮肤
 */</span>        
<span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">detachSkin</span><span class="params">(skin:Object)</span><span class="type">:void</span>
</span>{       
    <span class="keyword">if</span>(hasCreatedSkinParts)
    {
        removeSkinParts();
        hasCreatedSkinParts = <span class="literal">false</span>;
    }
    <span class="keyword">if</span>(skin <span class="keyword">is</span> ISkin)
    {
        <span class="keyword">var</span> skinParts:Vector.&lt;String&gt; = SkinPartUtil.getSkinParts(<span class="keyword">this</span>);
        <span class="keyword">for</span> <span class="keyword">each</span>(<span class="keyword">var</span> partName:String <span class="keyword">in</span> skinParts)
        {
            <span class="keyword">if</span>(!(partName <span class="keyword">in</span> <span class="keyword">this</span>))
                <span class="keyword">continue</span>;
            <span class="keyword">if</span> (<span class="keyword">this</span>[partName] != <span class="literal">null</span>)
            {
                partRemoved(partName,<span class="keyword">this</span>[partName]);
            }
            <span class="keyword">this</span>[partName] = <span class="literal">null</span>;
        }
        (skin <span class="keyword">as</span> ISkin).hostComponent = <span class="literal">null</span>;
    }
}
</code></pre><p>我发现在for each某一个循环之后，scaleSkin发生了变化。同时通过断点发现skinParts居然还包含了一个scaleSkin的值</p>
<p><img src="http://xzper.qiniudn.com/2015/05/09.png" alt=""></p>
<p>果然罪魁祸首找到了，就是这里。使用[]的方式对属性进行赋值，逃过了查找引用和全局搜索。真是天网恢恢，总会漏那么一点。</p>
<p>在卸载旧皮肤的时候（因为在ListSkin里面HScroller添加到显示列表会有一个主题皮肤，然后在MyListSkin会又设置一次HScroller的皮肤，所以会触发卸载皮肤的方法）框架内部将scaleSkin当成了皮肤部件，使用了 this[“scaleSkin”] = null 的方式改变了这个属性的值。</p>
<p>那么新的问题又产生了，scaleSkin怎么会成为了皮肤部件？通过查看SkinPartUtil的getSkinParts方法</p>
<p><img src="http://xzper.qiniudn.com/2015/05/10.png" alt=""></p>
<p>不难发现第47行，没有使用toString()，导致判断永远成立，这个类里面的所有public的属性都被当做了皮肤部件。解决办法就是加上toString()。</p>
<pre><code><span class="keyword">if</span>(basicTypes.indexOf(node.@<span class="class"><span class="keyword">type</span>.<span class="title">toString</span></span>())==-<span class="number">1</span>)
</code></pre><p>另外SkinnableComponent在卸载皮肤校验时,没有判断部件是否也存在与皮肤中，可以将</p>
<pre><code><span class="keyword">if</span>(!(partName <span class="keyword">in</span> <span class="keyword">this</span>))
    <span class="keyword">continue</span>;
</code></pre><p>改为</p>
<pre><code><span class="keyword">if</span>(!(partName <span class="keyword">in</span> <span class="keyword">this</span>)||!(partName <span class="keyword">in</span> <span class="keyword">this</span>.skin))
    <span class="keyword">continue</span>;
</code></pre><p>到这里问题才算是彻底解决了。遇到问题还是需要刨根问底，不然永远只能停留在表面上。<br>最后附上错误代码的DEMO项目，<s>留个纪念</s>：</p>
<p><a href="http://xzper.qiniudn.com/2015/05/FlexLiteTest.zip" title="FlexLiteTest" target="_blank" rel="external">http://xzper.qiniudn.com/2015/05/FlexLiteTest.zip</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>前不久在FlexLite的开发者群里面遇到一个开发者的提问，说是在使用List的时候水平滚动条的大小有错误。截图大概是下面这样：</p>
<p><img src="http://xzper.qiniudn.com/2015/05/01.png" alt=""></p>
]]></summary>
    
      <category term="FlexLite" scheme="http://xzper.com/tags/FlexLite/"/>
    
      <category term="ActionScript3" scheme="http://xzper.com/tags/ActionScript3/"/>
    
      <category term="未分类" scheme="http://xzper.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[突破AIR程序的权限限制]]></title>
    <link href="http://xzper.com/2015/01/24/%E7%AA%81%E7%A0%B4AIR%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9D%83%E9%99%90%E9%99%90%E5%88%B6/"/>
    <id>http://xzper.com/2015/01/24/突破AIR程序的权限限制/</id>
    <published>2015-01-24T05:27:45.000Z</published>
    <updated>2015-01-24T07:44:35.000Z</updated>
    <content type="html"><![CDATA[<p>AIR中有些API在没有权限的情况下是不生效的，甚至不报错也没没有任何提示。例如文件系统中对敏感目录的文件操作，File.applicationDirectory这个API的文档是这样说的</p>
<blockquote>
<p>出于安全原因，不推荐修改应用程序目录中的内容，有些平台上的操作系统会阻止此操作。<br>如果要存储特定于应用程序的数据，请考虑使用应用程序存储目录 (File.applicationStorageDirectory)。</p>
</blockquote>
<p>可以看到File.applicationDirectory这个目录是无法保证有权限写入的。这篇文章讲解如何在Windows和Mac下突破这一限制，能获取系统中任何目录的操作权限。</p>
<a id="more"></a>

<p>解决这个问题基本思路是想办法让程序获得管理员所有权，一旦程序有了权限就可以肆无忌惮了。但是，一个没有权限的程序在运行时是无法提升权限的，只能在程序启动时，赋予权限。也就是说要想让程序有权限，必须通过另一个程序。假设我们的AIR程序叫A，这个可以提升其他AIR程序权限的程序叫elevate，调用elevate，传入A的路径，启动A就行了。这里有两种方案：</p>
<p>1.使用一个壳，壳启动时调用elevate以管理员方式启动A，这样A就获得了权限。</p>
<p>2.启动A，这时A是没有权限的，然后A调用elevate，启动程序B，由B来执行一切需要权限的敏感操作。</p>
<p>elevate这个程序在为其他程序申请权限的时候是需要认证的。在Windows7及其以上，如果用户开启了用户账户控制(UAC)，那么会弹出提示框，让用户点击确认的。在Mac上是需要输入用户密码，来完成授权的。那么方案1，程序A在启动时，会提示用户确认，然后一劳永逸，A想干啥就干啥了。方案2，程序A只有在需要进行敏感操作时就会提示用户确认，如果B在执行完任务后退出了，那么下次需要权限时又得确认了。两种方案各有好处。我们最终选用了方案B，毕竟程序启动时来那么一个提示框对用户体验不太好。</p>
<p>说了这么多，下面祭出大杀器elevate。</p>
<p>Windows下使用下面提供的elevate.exe。<br>Mac下使用下面提供的elevate.scpt。</p>
<p>有了elevate在AIR下使用NativeProcess启动elevate，并传入参数。用法如下：</p>
<pre><code><span class="comment">/**
 * 以管理员方式执行程序
 * @param exePath 要执行的程序路径
 * @param args 要传入的参数
 */</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">(exePath:String , exeArgs:Vector.&lt;String&gt; = null)</span><span class="type">:void</span>
</span>{
    <span class="keyword">var</span> elevateFolder:File = File.applicationDirectory.resolvePath(<span class="string">"bin"</span>);
    <span class="keyword">var</span> nativeProcess:NativeProcess = <span class="keyword">new</span> NativeProcess();
    <span class="keyword">var</span> nativeProcessInfo:NativeProcessStartupInfo = <span class="keyword">new</span> NativeProcessStartupInfo();
    <span class="keyword">var</span> args:Vector.&lt;String&gt; = <span class="keyword">new</span> Vector.&lt;String&gt;();
    <span class="keyword">if</span>(Capabilities.os.indexOf(<span class="string">"Mac OS"</span>)&gt;=<span class="number">0</span>)
    {
        nativeProcessInfo.executable = <span class="keyword">new</span> File(<span class="string">"/usr/bin/osascript"</span>);
        args.push(elevateFolder.resolvePath(<span class="string">"elevate.scpt"</span>).nativePath);
        args.push(exePath);
    }
    <span class="keyword">else</span>
    {
        <span class="keyword">if</span>(Capabilities.os.indexOf(<span class="string">"XP"</span>)&lt;<span class="number">0</span>)
        {
            <span class="comment">//非xp系统直接调用elevate申请权限</span>
            nativeProcessInfo.executable = elevateFolder.resolvePath(<span class="string">"elevate.exe"</span>);
            args.push(exePath);
        }
        <span class="keyword">else</span>
        {
            <span class="comment">//xp系统下没有UAC，直接运行目标程序即可</span>
            nativeProcessInfo.executable = <span class="keyword">new</span> File(exePath);
        }
    }
    <span class="keyword">if</span>(exeArgs)
        args = args.concat(exeArgs);
    nativeProcessInfo.arguments = args;
    nativeProcess.start(nativeProcessInfo);
}
</code></pre><p>如果觉得这种传参调用不好用，可以改一下。在目标程序启动后，可以实现A程序与B程序的进程通讯。A向B程序相互发消息就更加灵活了。我们的方案是把B程序也做成一个AIR应用，这样就可以使用LocalConnection实现两个AIR程序的通讯了。</p>
<p>elevate的下载地址,有兴趣的可以hack下:</p>
<p>Windows：<a href="http://xzper.qiniudn.com/2015/01/elevate.exe" target="_blank" rel="external">elevate.exe</a></p>
<p>Mac：<a href="http://xzper.qiniudn.com/2015/01/elevate.scpt" target="_blank" rel="external">elevate.scpt</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>AIR中有些API在没有权限的情况下是不生效的，甚至不报错也没没有任何提示。例如文件系统中对敏感目录的文件操作，File.applicationDirectory这个API的文档是这样说的</p>
<blockquote>
<p>出于安全原因，不推荐修改应用程序目录中的内容，有些平台上的操作系统会阻止此操作。<br>如果要存储特定于应用程序的数据，请考虑使用应用程序存储目录 (File.applicationStorageDirectory)。</p>
</blockquote>
<p>可以看到File.applicationDirectory这个目录是无法保证有权限写入的。这篇文章讲解如何在Windows和Mac下突破这一限制，能获取系统中任何目录的操作权限。</p>
]]></summary>
    
      <category term="ActionScript3" scheme="http://xzper.com/categories/ActionScript3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AIR中一些隐藏特性]]></title>
    <link href="http://xzper.com/2015/01/17/AIR%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%9A%90%E8%97%8F%E7%89%B9%E6%80%A7/"/>
    <id>http://xzper.com/2015/01/17/AIR中一些隐藏特性/</id>
    <published>2015-01-17T13:52:01.000Z</published>
    <updated>2015-01-17T16:03:16.000Z</updated>
    <content type="html"><![CDATA[<p>分享一下在使用AIR开发跨平台应用的几个坑。在此之前不得不说，stackoverflow这个网站帮了我很多。每次遇到一些棘手的技术问题寻找答案未果的情况下，stackoverflow总能找到令人满意的答案。这里分享两个我遇到的一些问题。</p>
<a id="more"></a>

<p><strong>1.打印异常堆栈信息</strong></p>
<p>当产品发布时，没人能保证程序百分之百稳定运行。难免会有一些bug，而用户遇到了bug需要反馈的时候，报错的堆栈信息如果能够得到保留能省很多事。所幸AIR有这样的API能输出堆栈信息。看下面这段代码。</p>
<pre><code>loaderInfo.uncaughtErrorEvents.addEventListener(UncaughtErrorEvent.UNCAUGHT_ERROR,errorHandle);

<span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">errorHandle</span><span class="params">(event:UncaughtErrorEvent)</span><span class="type">:void</span>
</span>{
    <span class="keyword">var</span> message:String; 
    <span class="keyword">if</span> (event.error <span class="keyword">is</span> Error) { 
        message = Error(event.error).message; 
        message+=<span class="string">"\n"</span>+Error(event.error).getStackTrace();
    } <span class="keyword">else</span> <span class="keyword">if</span> (event.error <span class="keyword">is</span> ErrorEvent) { 
        message = ErrorEvent(event.error).text;
    } <span class="keyword">else</span> { 
        message = event.error.toString(); 
    } 
}
</code></pre><p>当时这样做每次得到的结果却是这样的</p>
<pre><code><span class="preprocessor">at</span> xxx/uncaughtErrorHandler()
</code></pre><p>堆栈显示不全，但这不是我们想要的结果。解决办法就是将下面这一行</p>
<pre><code>message+=<span class="string">"\n"</span>+<span class="keyword">Error</span>(<span class="keyword">event</span>.<span class="keyword">error</span>).getStackTrace();
</code></pre><p>改为</p>
<pre><code>message+=<span class="string">"\n"</span>+<span class="keyword">event</span>.<span class="keyword">error</span>.getStackTrace();
</code></pre><p>去掉强制转换就行了。</p>
<hr>
<p><strong>2.重启AIR程序</strong></p>
<p>重启AIR程序，这个问题似乎很好解决，百度或者Google之，发现几乎所有的相关文章都介绍了使用ProductManager的相关api实现。具体的实现参考<a href="http://blog.domlib.com/articles/577.html" target="_blank" rel="external">http://blog.domlib.com/articles/577.html</a></p>
<p>可是这个方法有时并不管用。</p>
<p>比如嵌入运行时的本地AIR程序，这种程序需要在应用程序描述文件里面配置</p>
<pre><code><span class="tag">&lt;<span class="title">supportedProfiles</span>&gt;</span>extendedDesktop<span class="tag">&lt;/<span class="title">supportedProfiles</span>&gt;</span>
</code></pre><p>打包好的程序在Windows下面是一个exe程序，mac下是一个app文件夹。这种程序的重启似乎有点麻烦，不过下面的代码确实能使程序重启。</p>
<pre><code>var id:<span class="typename">String</span> = NativeApplication.nativeApplication.applicationID;
var info:NativeProcessStartupInfo = <span class="keyword">new</span> NativeProcessStartupInfo();
<span class="keyword">if</span>(Capabilities.os.indexOf(<span class="string">"Mac OS"</span>)&gt;=<span class="number">0</span>)
    info.executable = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="keyword">File</span>.applicationDirectory.nativePath).parent.resolvePath(<span class="string">"MacOS/"</span>+id);
<span class="keyword">else</span>
    info.executable = <span class="keyword">File</span>.applicationDirectory.resolvePath(id+<span class="string">".exe"</span>);
var <span class="keyword">process</span>:NativeProcess = <span class="keyword">new</span> NativeProcess();
<span class="keyword">process</span>.start(info);
NativeApplication.nativeApplication.<span class="keyword">exit</span>();
</code></pre><p>没错，先打开程序，然后立马执行退出就是重启。不过这种方式之所以生效还是有一定道理的，NativeProcess是系统级的东西，系统执行的时候有一定延迟，而exit是立马就生效的。</p>
]]></content>
    <summary type="html"><![CDATA[<p>分享一下在使用AIR开发跨平台应用的几个坑。在此之前不得不说，stackoverflow这个网站帮了我很多。每次遇到一些棘手的技术问题寻找答案未果的情况下，stackoverflow总能找到令人满意的答案。这里分享两个我遇到的一些问题。</p>
]]></summary>
    
      <category term="ActionScript3" scheme="http://xzper.com/categories/ActionScript3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Flex框架中样式的实现原理与AS3中的原型链继承]]></title>
    <link href="http://xzper.com/2014/10/25/Flex%E6%A1%86%E6%9E%B6%E4%B8%AD%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8EAS3%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/"/>
    <id>http://xzper.com/2014/10/25/Flex框架中样式的实现原理与AS3中的原型链继承/</id>
    <published>2014-10-25T05:53:06.000Z</published>
    <updated>2014-10-25T09:46:12.000Z</updated>
    <content type="html"><![CDATA[<p>在Flex中setStyle这个特性特别好用，当一个容器Group的样式时，那么这个容器的子项的样式也会跟着起作用。比如设置Application的<code>fontSize</code>这个样式为20，那么如果不显式设置子项的<code>fontSize</code>，子项的字体大小就都会是20，而不用每次子项再去重复设置了，这个特性对于开发者来讲是至关重要的，能减少很多重复的代码。而这个特性的实现，离不开原型链继承这个重要概念。</p>
<a id="more"></a>

<p>原型链继承这个词已经不是陌生词汇了，对于JS程序员来说更是再熟悉不过了。AS3作为一个面向对象的脚本语言，原型链继承早已淡出AS3程序员的视野。说到AS语言，其实AS1，AS2都很像JS，AS3则来了个180°转变，变成了面向对象了。早在AS1，AS2的时代，对象间的继承就是使用原型链继承的方式实现的，事实上这一特性也得到了保留，AS3也可以使用这种方式实现继承。</p>
<hr>
<p>下面我们来看一个神奇的DEMO来体会原型链继承。先上代码</p>
<pre><code><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">styleTest</span><span class="params">()</span><span class="type">:void</span>
</span>{
    <span class="keyword">var</span> parentStyle:Object = 
        {
            <span class="string">"fontSize"</span>:<span class="number">12</span> , 
            <span class="string">"fontColor"</span>:<span class="number">0xffffff</span> , 
            <span class="string">"fontFamily"</span>:<span class="string">"微软雅黑"</span>
        };

    <span class="keyword">var</span> childStyle:Object = addStyleToProtoChain(parentStyle);
    childStyle[<span class="string">"fontSize"</span>] = <span class="number">20</span>;
    childStyle[<span class="string">"fontWeight"</span>] = <span class="string">"bold"</span>;

    parentStyle[<span class="string">"fontSize"</span>] = <span class="number">18</span>;
    parentStyle[<span class="string">"fontFamily"</span>] = <span class="string">"宋体"</span>;

    <span class="keyword">trace</span>(<span class="string">"-----以下为parent的样式信息-----"</span>);
    traceObject(parentStyle);

    <span class="keyword">trace</span>(<span class="string">"-----以下为child的样式信息-----"</span>);
    traceObject(childStyle);
}

<span class="comment">/**
 * 将样式信息添加到原型链
 * @param originalStyle 原始样式 
 * @return 原始样式的子样式
 */</span>
<span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">addStyleToProtoChain</span><span class="params">(originalStyle:Object)</span><span class="type">:Object</span>
</span>{
    <span class="keyword">var</span> inheritStyle:Object;
    <span class="keyword">var</span> factory:Function = <span class="function"><span class="keyword">function</span><span class="params">()</span><span class="type">:void</span></span>{};
    factory.prototype = originalStyle;
    inheritStyle = <span class="keyword">new</span> factory();
    factory.prototype = <span class="literal">null</span>;
    <span class="keyword">return</span> inheritStyle;
}

<span class="comment">/**
 * 打印排序后的对象的属性
 */</span>
<span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">traceObject</span><span class="params">(obj:Object)</span><span class="type">:void</span>
</span>{
    <span class="keyword">var</span> keys:Array = [];
    <span class="keyword">var</span> valueMap:Object = {};

    <span class="keyword">for</span>(<span class="keyword">var</span> key:String <span class="keyword">in</span> obj)
    {
        <span class="keyword">if</span>(keys.indexOf(key)&gt;=<span class="number">0</span>)
            <span class="keyword">continue</span>;
        keys.push(key);
        valueMap[key] = obj[key];
    }
    keys.sort();
    <span class="keyword">for</span> each (key <span class="keyword">in</span> keys)
    {
        <span class="keyword">trace</span>(key+<span class="string">":"</span>+valueMap[key]);
    }
}
</code></pre><p>程序定义了两个对象<code>parentStyle</code>和<code>childStyle</code>来存储一些样式属性。通过<code>addStyleToProtoChain</code>将<code>parentStyle</code>加入到<code>childStyle</code>原型链中，然后不断改变这两个对象的属性，最后输出两个对象的结果。在答案揭晓之前我们先来分析一下每个属性的设置过程。</p>
<h4 id="fontSize"><code>fontSize</code></h4>
<p><code>fontSize</code>这个属性在<code>parentStyle</code>初始化时为12，后来在<code>childStyle</code>中设置为20，最后<code>parentStyle</code>中又重新设置为18。 那么最后childStyle的<code>fontSize</code>是多少呢?是12，还是20，还是18?</p>
<h4 id="fontColor"><code>fontColor</code></h4>
<p><code>fontColor</code>只有在<code>parentStyle</code>初始化时设置了一次为<code>0xffffff</code>,并没有在<code>childStyle</code>中设置，那么最终<code>childStyle</code>中会有这个属性吗?</p>
<h4 id="fontFamily"><code>fontFamily</code></h4>
<p><code>fontFamily</code>被设置两次，初始化时为<code>微软雅黑</code>，后来设置成了<code>宋体</code>，都在<code>parentStyle</code>的属性中设置的。同样那么最终<code>childStyle</code>会有这个属性吗，有的话值是多少呢?是<code>微软雅黑</code>还是<code>宋体</code>?</p>
<h4 id="fontWeight"><code>fontWeight</code></h4>
<p><code>fontWeight</code>这个属性只在<code>childStyle</code>进行了设置，那么最终<code>parentStyle</code>会有这个属性吗?</p>
<hr>
<p>那么答案揭晓，控制台输出如下：</p>
<pre><code>-----以下为parent的样式信息-----
<span class="label">fontColor:</span><span class="number">16777215</span>
<span class="label">fontFamily:</span>宋体
<span class="label">fontSize:</span><span class="number">18</span>
-----以下为child的样式信息-----
<span class="label">fontColor:</span><span class="number">16777215</span>
<span class="label">fontFamily:</span>宋体
<span class="label">fontSize:</span><span class="number">20</span>
<span class="label">fontWeight:</span>bold
</code></pre><p>结果是否出人意料?</p>
<p>其实最终的结果可以可以归纳为child的改变不会影响parent的属性，而parent的属性改变<strong>可能</strong>会影响到child的属性。这个可能分两种情况，一种情况是child没有这个属性，parent改变了child就会跟着改变，再一种就是child有这个属性parent改变了不会影响child。</p>
<p>为什么<code>fontColor</code>，<code>fontFamily</code>这类的在<code>parentStyle</code>中定义，会在<code>childStyle</code>中出现呢，因为<code>childStyle</code>的原型链是<code>parentStyle</code>，当在自身找不到这个属性时，就会从原型链里面找，直到找到为止。</p>
<hr>
<p>我们再来看一下是如何将<code>parentStyle</code>设置成<code>childStyle</code>的原型链的。将<code>addStyleToProtoChain</code>执行的操作翻译过来就是下面这样</p>
<pre><code><span class="keyword">var</span> factory:Function = <span class="function"><span class="keyword">function</span><span class="params">()</span><span class="type">:void</span></span>{};
factory.prototype = parentStyle;
childStyle = <span class="keyword">new</span> factory();
factory.prototype = <span class="literal">null</span>;
</code></pre><hr>
<p>这种原型链的描述方式完全符合Flex样式的设计思想。Flex的每个组件都持有两套样式表，可继承的样式和不可继承的样式。不可继承的样式不做传递，可继承的样式会添加到原型链中。当一个容器的子组件被添加的时候，子组件的样式表会被重新初始化，将父级的样式表添加到自己的原型链，然后添加自己的样式。最终自己的样式改变不会影响父级，父级的样式改变，如果自己没有显式定义就会跟随父级改变。关于Flex样式的原理详细的可以看下面的参考文章。</p>
<p>本文代码下载: <a href="http://xzper.qiniudn.com/2014%2F10%2FStyleTest.zip" target="_blank" rel="external">Click Me</a></p>
<p>参考文章：</p>
<p>[1] <a href="http://blog.csdn.net/terryzero/article/details/4581459" target="_blank" rel="external">Flex样式工作原理</a></p>
<p>[2] <a href="http://blog.csdn.net/holybozo/article/details/1345606" target="_blank" rel="external">AS3 面向对象 高级话题</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>在Flex中setStyle这个特性特别好用，当一个容器Group的样式时，那么这个容器的子项的样式也会跟着起作用。比如设置Application的<code>fontSize</code>这个样式为20，那么如果不显式设置子项的<code>fontSize</code>，子项的字体大小就都会是20，而不用每次子项再去重复设置了，这个特性对于开发者来讲是至关重要的，能减少很多重复的代码。而这个特性的实现，离不开原型链继承这个重要概念。</p>
]]></summary>
    
      <category term="ActionScript3" scheme="http://xzper.com/categories/ActionScript3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分享一个小巧的快捷键管理工具类]]></title>
    <link href="http://xzper.com/2014/09/04/%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://xzper.com/2014/09/04/快捷键管理/</id>
    <published>2014-09-04T13:58:03.000Z</published>
    <updated>2014-09-06T04:55:37.000Z</updated>
    <content type="html"><![CDATA[<p>最近要完成软件中的快捷键模块。基本需求就是能做到让用户自由设置。基本之前的所有按键都是写死在代码中的，就像下面这样糟糕：</p>
<pre><code><span class="keyword">this</span>.addEventListener(KeyboardEvent.KEY_DOWN,onKeyDown);

<span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onKeyDown</span><span class="params">(event:KeyboardEvent)</span><span class="type">:void</span>
</span>{
    <span class="keyword">if</span>(event.keyCode==Keyboard.S&amp;&amp;event.ctrlKey)
    {
        ...dosomething
    }
}
</code></pre><a id="more"></a>

<p>这样写是无法做到在后期维护中把快捷键分离出来让用户自由设置的。而且会造成代码冗余，比如这个面板需要Ctrl+S执行保存操作，那个面板也需要Ctrl+S执行那个面板的保存操作。这样Ctrl+S这种组合的快捷键每个面板都需要判断一下，这样相同的逻辑判断会多次出现。还有一种比较严格的情况，比如上面的那种判断严格意义上来讲是不能判断Ctrl+S的，因为用户可能同时也按下了Shift键或者Alt键，那这样这个判断要完全写对，代码量又要多不少。</p>
<p>比较好的解决方式是使用一个快捷键管理类Shortcut，统一管理这些操作。在程序初始化的时候注入快捷键的映射，然后在各个面板注册需要响应的事件类型以及对应的函数。比如一个Ctrl+S的操作可以这样表示：</p>
<p>程序初始化的时候，添加快捷键映射</p>
<pre><code>Shortcut.addBinding(<span class="string">"save"</span> , [Keyboard.S , Keyboard.CONTROL]);
</code></pre><p>具体的面板注册监听事件</p>
<pre><code>Shortcut.addRegister(<span class="keyword">this</span> , “save” , onShortcut);
</code></pre><p><code>addBinding</code>这个方法第一个参数就是事件类型，第二个类型就是事件对应的按键，用一个数组表示，可以是多个具体的解析交由Shortcut实现。</p>
<p><code>addRegister</code>这个方法第一个参数就是要监听这个事件的对象，第二个参数是监听的类型，第三个参数是对应的回调函数。当然只有满足了按键条件才会触发这个回调函数。</p>
<p>这样具体的按键事件监听，按键逻辑都交由Shortcut这个管理类去实现。要响应事件的对象不再需要去写繁琐的事件监听与逻辑判断了。这个面板只关心save这个事件，而不关心按了什么键，这样解耦了按键事件与面板的关系。用户如果需要改变快捷键，只需要改变那个binding的映射表就行了，具体的面板不需要任何改变。</p>
<p>当然基于以上两个方法我们可以继续添加扩展，比如批量初始化快捷键映射</p>
<pre><code>Shortcut.addBindindBatch(config);
</code></pre><p>这种方式可以用于初始化的时候或者用户修改了快捷键的时候，传入一个映射表配置就行了。</p>
<p>事件的类型也可以从简单的字符串变为一个静态常量，比如可以定义一个ShortcutType类存放这些事件：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortcutType</span>
</span>{
    <span class="javadoc">/**
     * 保存
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">const</span> SAVE:String = <span class="string">"save"</span>;
}
</code></pre><p>基本上API就是这样，使用很简单，也很灵活。然后是重点<code>No Code You Say A Diao</code></p>
<pre><code><span class="package"><span class="keyword">package</span>
{</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.display.InteractiveObject;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.display.Stage;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.events.Event;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.events.FocusEvent;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.events.KeyboardEvent;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.ui.Keyboard;</span>
    <span class="preprocessor"><span class="keyword">import</span> flash.utils.Dictionary;</span>

    <span class="comment">/**
     * 快捷键管理类， 执行initialize初始化一个全局管理。
     * &lt;br&gt;使用 addBinding 添加一个事件类型 与 按键的绑定
     * &lt;br&gt;使用 addRegister 注册一个监听对象
     * &lt;br&gt;下面是一个简单的使用例子
     * &lt;code&gt;
     *    &lt;br&gt;Shortcut.addBinding("example" , [Keyboard.S , Keyboard.CONTROL]);
     *    &lt;br&gt;Shortcut.addRegister(this , "example" , onSave);
     * &lt;/code&gt;
     */</span>
    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shortcut</span>
    </span>{
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Shortcut</span><span class="params">(stage:Stage)</span>
        </span>{
            stage.addEventListener(KeyboardEvent.KEY_DOWN,onStageKeyDown,<span class="literal">true</span>,<span class="number">2000</span>);
            stage.addEventListener(KeyboardEvent.KEY_UP,onStageKeyUp,<span class="literal">true</span>,<span class="number">2000</span>);
            stage.addEventListener(FocusEvent.FOCUS_OUT,onDeactive);
        }

        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> instance:Shortcut;
        <span class="comment">/**
         * 初始化
         */</span>        
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">initialize</span><span class="params">(stage:Stage)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">if</span>(instance)
                <span class="keyword">return</span>;
            instance = <span class="keyword">new</span> Shortcut(stage);
        }

        <span class="comment">/**
         * @copy  Shortcut#addRegister()
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">addRegister</span><span class="params">(target:InteractiveObject , type:String , callBack:Function)</span><span class="type">:void</span>
        </span>{
            instance.addRegister(target , type , callBack);
        }

        <span class="comment">/**
         * @copy  Shortcut#removeRegister()
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">removeRegister</span><span class="params">(target:InteractiveObject , type:String , callBack:Function)</span><span class="type">:void</span>
        </span>{
            instance.removeRegister(target , type , callBack);
        }

        <span class="comment">/**
         * 移除一个对象所有注册的快捷键
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">removeTargetRegister</span><span class="params">(target:InteractiveObject)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">if</span>(instance.targetDic[target])
            {
                <span class="keyword">var</span> shortcutMapList:Array = instance.targetDic[target];
                <span class="keyword">for</span> <span class="keyword">each</span> (<span class="keyword">var</span> shortcutMap:ShortcutMap <span class="keyword">in</span> shortcutMapList) 
                {
                    instance.removeRegister(target , shortcutMap.type , shortcutMap.callBack);
                }
            }
        }

        <span class="comment">/**
         * @copy  Shortcut#addBinding()
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">addBinding</span><span class="params">(type:String , keyCodeValue:Array)</span><span class="type">:void</span>
        </span>{
            instance.addBinding(type , keyCodeValue);
        }

        <span class="comment">/**
         * 批量添加绑定事件类型 与 按键值的映射
         * @param data 数据中的每一项格式参照addBinding方法中的参数
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">addBindindBatch</span><span class="params">(data:Object)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">for</span> (<span class="keyword">var</span> key:String <span class="keyword">in</span> data) 
            {
                instance.addBinding(key , data[key]);
            }
        }

        <span class="comment">/**
         * @copy  Shortcut#removeBinding()
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">removeBinding</span><span class="params">(type:String)</span><span class="type">:void</span>
        </span>{
            instance.removeBinding(type);
        }

        <span class="comment">/**
         * 移除所有的事件类型
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">removeAllBinding</span><span class="params">()</span><span class="type">:void</span>
        </span>{
            instance.bindingDic = <span class="keyword">new</span> Dictionary();
        }

        <span class="comment">/**
         * 判断指定键是否按下
         */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">isKeyDown</span><span class="params">(keyCode:uint)</span><span class="type">:Boolean</span>
        </span>{
            <span class="keyword">return</span> instance.isKeyDown(keyCode);
        }


        <span class="comment">//======================== 快捷键相关=====================start=======================</span>

        <span class="comment">/**
         * 监听快捷键的对象 与 持有的注册列表字典
         */</span>
        <span class="keyword">private</span> <span class="keyword">var</span> targetDic:Dictionary = <span class="keyword">new</span> Dictionary(<span class="literal">true</span>);

        <span class="comment">/**
         * 事件类型 与 具体按键值的关系映射表
         */</span>
        <span class="keyword">private</span> <span class="keyword">var</span> bindingDic:Dictionary = <span class="keyword">new</span> Dictionary();

        <span class="comment">/**
         * 注册一个监听对象
         * @param target 监听事件的目标对象
         * @param type 按键要触发的事件类型
         * @param callBack 回调函数示例：不含参数 callBack():void
         * 带一个参数callBack(type:String):void , 带两个参数callBack(type:String , event:KeyboardEvent):void
         */</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addRegister</span><span class="params">(target:InteractiveObject , type:String , callBack:Function)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">if</span>(getRegisterIndex(target , type , callBack) &gt;= <span class="number">0</span>)
            {
                <span class="keyword">return</span>;
            }
            <span class="keyword">if</span>(targetDic[target] === <span class="literal">undefined</span>)
            {
                targetDic[target] = [];
                target.addEventListener(KeyboardEvent.KEY_DOWN , onKeyDown , <span class="literal">false</span> ,<span class="number">0</span> , <span class="literal">true</span>);
            }
            <span class="keyword">var</span> map:ShortcutMap = <span class="keyword">new</span> ShortcutMap();
            map.type = type;
            map.callBack = callBack; 
            targetDic[target].push(map);
        }

        <span class="comment">/**
         * 移除一个监听对象
         * @param target 监听事件的目标对象
         * @param type 按键要触发的事件类型
         * @param callBack 回调函数
         */</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">removeRegister</span><span class="params">(target:InteractiveObject , type:String , callBack:Function)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">var</span> registerIndex:int = getRegisterIndex(target , type , callBack);
            <span class="keyword">if</span>(registerIndex &gt;= <span class="number">0</span>)
            {
                <span class="keyword">var</span> shortcutMapList:Array = targetDic[target];
                shortcutMapList.splice(registerIndex , <span class="number">1</span>);
                <span class="keyword">if</span>(shortcutMapList.length == <span class="number">0</span>)
                {
                    target.removeEventListener(KeyboardEvent.KEY_DOWN , onKeyDown);
                    <span class="keyword">delete</span> targetDic[target];
                }
            }
        }

        <span class="comment">/**
         * 测试是否注册了指定类型的指定方法，并返回注册的索引
         */</span>
        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">getRegisterIndex</span><span class="params">(target:InteractiveObject , type:String , callBack:Function)</span><span class="type">:int</span>
        </span>{
            <span class="keyword">if</span>(targetDic[target])
            {
                <span class="keyword">var</span> shortcutMapList:Array = targetDic[target];
                <span class="keyword">var</span> shortcutMap:ShortcutMap;
                <span class="keyword">for</span> (<span class="keyword">var</span> i:int = <span class="number">0</span>; i &lt; shortcutMapList.length; i++) 
                {
                    shortcutMap = shortcutMapList[i] <span class="keyword">as</span> ShortcutMap;
                    <span class="keyword">if</span>(shortcutMap.type == type &amp;&amp; shortcutMap.callBack == callBack)
                    {
                        <span class="keyword">return</span> i;
                    }
                }
            }
            <span class="keyword">return</span> -<span class="number">1</span>;
        }

        <span class="comment">/**
         * 绑定一个事件类型 与 按键值的映射
         * @param type  事件类型
         * @param keyCodeValue 按下的键的对象， 可以是一个数组也可以每一项是一个数组，数组中的元素对应Keyboard中的常量
         *     &lt;br/&gt;如果数组的长度等于1，则 按照对应的键值触发事件
         * &lt;br/&gt;如果数组的长度大于1，则 按照数组中的第一项对应的键值触发事件，其他的键为触发事件需要按下的键
         * &lt;br/&gt;下面是一些例子
         * &lt;code&gt;
         *    &lt;br&gt;[Keyboard.S , Keyboard.CONTROL] 表示 Ctrl+S
         *    &lt;br&gt;[[Keyboard.BACKSPACE] , [Keyboard.DELETE]] 表示退格或者删除
         * &lt;/code&gt;
         */</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addBinding</span><span class="params">(type:String , keyCodeValue:Array)</span><span class="type">:void</span>
        </span>{
            bindingDic[type] = keyCodeValue;
        }

        <span class="comment">/**
         * 移除一个事件类型
         */</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">removeBinding</span><span class="params">(type:String)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">if</span>(bindingDic[type])
            {
                <span class="keyword">delete</span> bindingDic[type];
            }
        }

        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onKeyDown</span><span class="params">(event:KeyboardEvent)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">var</span> shortcutMapList:Array = targetDic[event.currentTarget];
            <span class="keyword">if</span>(!shortcutMapList || shortcutMapList.length &lt; <span class="number">1</span>)
                <span class="keyword">return</span>;

            <span class="keyword">var</span> shortcutMap:ShortcutMap;
            <span class="keyword">for</span> (<span class="keyword">var</span> i:int = <span class="number">0</span>; i &lt; shortcutMapList.length; i++) 
            {
                shortcutMap = shortcutMapList[i] <span class="keyword">as</span> ShortcutMap;
                <span class="keyword">var</span> keyCodeValue:Array = bindingDic[shortcutMap.type];
                <span class="keyword">var</span> result:Boolean = <span class="literal">false</span>;
                <span class="keyword">if</span>(keyCodeValue[<span class="number">0</span>] <span class="keyword">is</span> Array)
                {
                    <span class="keyword">for</span> <span class="keyword">each</span> (<span class="keyword">var</span> keyCodeArray:* <span class="keyword">in</span> keyCodeValue) 
                    {
                        <span class="keyword">if</span>(keyCodeArray <span class="keyword">is</span> uint)
                            result = check(event , [keyCodeArray]);
                        <span class="keyword">else</span>
                            result = check(event , keyCodeArray);
                        <span class="keyword">if</span>(result)
                            <span class="keyword">break</span>;
                    }
                }
                <span class="keyword">else</span>
                {
                    result = check(event , keyCodeValue);
                }
                <span class="keyword">if</span>(result)
                {
                    <span class="keyword">if</span>(shortcutMap.callBack.length == <span class="number">0</span>)
                        shortcutMap.callBack();
                    <span class="keyword">else</span> <span class="keyword">if</span>(shortcutMap.callBack.length == <span class="number">1</span>)
                        shortcutMap.callBack(shortcutMap.type);
                    <span class="keyword">else</span> <span class="keyword">if</span>(shortcutMap.callBack.length == <span class="number">2</span>)
                        shortcutMap.callBack(shortcutMap.type , event);
                    <span class="keyword">else</span>
                        shortcutMap.callBack();
                }
            }
        }

        <span class="comment">/**
         * 检查事件是否符合指定按键
         */</span>
        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">check</span><span class="params">(event:KeyboardEvent , keyCodeArray:Array)</span><span class="type">:Boolean</span>
        </span>{
            <span class="keyword">if</span>(!keyCodeArray || keyCodeArray.length &lt; <span class="number">0</span>)
                <span class="keyword">return</span> <span class="literal">false</span>;
            <span class="keyword">if</span>(event.keyCode == keyCodeArray[<span class="number">0</span>])
            {
                <span class="keyword">if</span>(keyCodeArray.length == <span class="number">1</span>)
                {
                    <span class="keyword">return</span> <span class="literal">true</span>;
                }
                <span class="keyword">else</span>
                {
                    <span class="keyword">var</span> firstKey:uint = keyCodeArray[<span class="number">0</span>];
                    <span class="keyword">var</span> hopeKeys:Array = keyCodeArray.concat();
                    <span class="keyword">var</span> allDownkeyCodes:Array = compositeKeys(event);
                    <span class="keyword">if</span>(allDownkeyCodes.indexOf(firstKey)&lt;<span class="number">0</span>)
                        allDownkeyCodes.push(firstKey);

                    <span class="keyword">if</span>(hopeKeys.length != allDownkeyCodes.length)
                        <span class="keyword">return</span> <span class="literal">false</span>;

                    hopeKeys.sort();
                    allDownkeyCodes.sort();

                    <span class="keyword">for</span> (<span class="keyword">var</span> i:int = <span class="number">0</span>; i &lt; hopeKeys.length; i++) 
                    {
                        <span class="keyword">if</span>(hopeKeys[i] != allDownkeyCodes[i])
                        {
                            <span class="keyword">return</span> <span class="literal">false</span>;
                        }
                    }
                    <span class="keyword">return</span> <span class="literal">true</span>;
                }
            }
            <span class="keyword">return</span> <span class="literal">false</span>;
        }

        <span class="comment">/**
         * 获取按下的组合键
         */</span>
        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">compositeKeys</span><span class="params">(event:KeyboardEvent)</span><span class="type">:Array</span>
        </span>{
            <span class="keyword">var</span> keys:Array = [];
            <span class="keyword">if</span>(event.altKey)
                keys.push(Keyboard.ALTERNATE);
            <span class="keyword">if</span>(event.shiftKey)
                keys.push(Keyboard.SHIFT);
            <span class="keyword">if</span>(event.controlKey)
                keys.push(Keyboard.CONTROL);
            <span class="keyword">if</span>(event.commandKey)
                keys.push(Keyboard.COMMAND);
            <span class="keyword">return</span> keys;
        }

        <span class="comment">//======================== 快捷键相关=====================end=======================</span>

        <span class="comment">//======================== 全局舞台按键 =====================start=======================</span>

        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onDeactive</span><span class="params">(event:Event)</span><span class="type">:void</span>
        </span>{
            downKeyCodes = <span class="keyword">new</span> Dictionary();
        }
        <span class="comment">/**
         * 按下的键代码列表
         */</span>        
        <span class="keyword">private</span> <span class="keyword">var</span> downKeyCodes:Dictionary = <span class="keyword">new</span> Dictionary();

        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onStageKeyDown</span><span class="params">(event:KeyboardEvent)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">var</span> keyCode:uint = event.keyCode;
            downKeyCodes[keyCode] = <span class="literal">true</span>;
        }

        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onStageKeyUp</span><span class="params">(event:KeyboardEvent)</span><span class="type">:void</span>
        </span>{
            <span class="keyword">var</span> keyCode:uint = event.keyCode;
            <span class="keyword">if</span>(downKeyCodes[keyCode])
                <span class="keyword">delete</span> downKeyCodes[keyCode];
        }

        <span class="comment">/**
         * 是否按下了指定键
         */</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isKeyDown</span><span class="params">(keyCode:uint)</span><span class="type">:Boolean</span>
        </span>{
            <span class="keyword">return</span> Boolean(downKeyCodes[keyCode]);
        }

        <span class="comment">//======================== 全局舞台按键 =====================end=======================</span>

    }
}

<span class="class"><span class="keyword">class</span> <span class="title">ShortcutMap</span>
</span>{
    <span class="comment">/**
     * 事件类型
     */</span>
    <span class="keyword">public</span> <span class="keyword">var</span> type:String;

    <span class="comment">/**
     * 回调函数
     */</span>
    <span class="keyword">public</span> <span class="keyword">var</span> callBack:Function;
}
</code></pre><p>基本上代码已经说明一切了。主要思路就是给注册的对象监听一个KeyDown事件，在事件内部判断有哪些键按下了，是否符合这个对象某一个注册了的事件对应的按键映射，如果有就执行回调。</p>
<p>有一个关键点，给对象监听的按键事件<code>useWeakReference = true</code> 以及 <code>targetDic</code>也是使用了弱引用。只有这样我们无须手动调用<code>removeRegister</code>，当对象的引用计数为0时，就会被垃圾回收器GC自动回收了，不用担心内存泄露。</p>
<p>另外，这个工具类一开始需要传入一个舞台对象<code>stage</code>进行初始化，这个主要是用于保存一个全局有那些键是被按下了，就是后面那一段代码。这一段可有可无，主要是提供一个公共方法外界可以获取哪些键按下了。</p>
<p>基本上这个Shortcut已经能够满足大多数需求了。之前看过几个快捷键管理的工具类都是直接监听舞台上的事件，这个是有问题的。因为有些情况下，快捷键是针对指定面板的，当焦点不在面板上时快捷键是不起作用的，所以<code>removeRegister</code>这个方法的第一个参数就是设置快捷键应用的对象。<br>这个也能实现同一个事件可以注册给不同的对象，也可以一个对象注册同一个事件但是有不同的回调。就是说同一个快捷键可以给不同面板，同一个面板同一个快捷键也可以响应多个回调。</p>
<p>另外还支持一个事件多种快捷键，比如一个type为delete的事件，可以这样定义</p>
<pre><code>Shortcut.binding(<span class="string">"delete"</span> , <span class="string">[[Keyboard.BACKSPACE] , [Keyboard.DELETE]]</span>)
</code></pre><p>使用一个二维数组，每一个数组表示一组快捷键。delete事件既可以是退格键也可以是删除键。</p>
<p>再一个就是快捷键冲突的问题，同一个快捷键可以派发不同的事件。这种设计也是允许冲突的，因为有可能事件的对象不同，比如面板1里面Ctrl+S是保存，面板2里面Ctrl+S是删除一行，也就不冲突了。</p>
<p>差不多就这些啦。这个类可以拿来直接用，没有和其他的类耦合，也不需要定义接口啥的。另外，这些东西真的要到项目前期规划好，不然到了后面想改都蛋疼。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近要完成软件中的快捷键模块。基本需求就是能做到让用户自由设置。基本之前的所有按键都是写死在代码中的，就像下面这样糟糕：</p>
<pre><code><span class="keyword">this</span>.addEventListener(KeyboardEvent.KEY_DOWN,onKeyDown);

<span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">onKeyDown</span><span class="params">(event:KeyboardEvent)</span><span class="type">:void</span>
</span>{
    <span class="keyword">if</span>(event.keyCode==Keyboard.S&amp;&amp;event.ctrlKey)
    {
        ...dosomething
    }
}
</code></pre>]]></summary>
    
      <category term="ActionScript3" scheme="http://xzper.com/categories/ActionScript3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析Hexo的Generate命令]]></title>
    <link href="http://xzper.com/2014/08/17/%E6%B5%85%E6%9E%90Hexo%E7%9A%84Generate%E5%91%BD%E4%BB%A4/"/>
    <id>http://xzper.com/2014/08/17/浅析Hexo的Generate命令/</id>
    <published>2014-08-16T22:54:10.000Z</published>
    <updated>2014-09-06T04:48:49.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/hexojs/hexo" target="_blank" rel="external">Hexo</a>是一个轻量级的静态博客站点生成框架，使用NodeJS开发。经过我两个通宵的努力总算把这个东西研究了一个大概，这里拿来分享一下。</p>
<a id="more"></a>

<h2 id="Processor">Processor</h2>
<p><a href="http://hexo.io/docs/plugins.html#Processor" target="_blank" rel="external">Processor</a>决定文件按照何种方式处理。在lib/plugins/processor文件夹下可以看到默认的处理方式。Processor在该模块的index.js中注册，默认的有下面几种</p>
<ol>
<li><strong>post</strong> 当文件是可渲染的，并且在_posts文件夹下的处理方式</li>
<li><strong>post_assets</strong> 当文件是不可渲染的，并且配置文件中的”post_asset_folder”属性存在，并且在_posts文件夹下的处理方式 </li>
<li><strong>page</strong> 文件不在_posts下，当文件是可渲染时的处理方式</li>
<li><strong>assets</strong> 文件不在_posts下，当文件是不可渲染时的处理方式</li>
</ol>
<p>另外隐藏文件是不会被处理的。Processor会读取文件文件信息调用Renderer，将处理后的文件内容以及相关信息写入数据库。以便Generator读取。</p>
<h2 id="Renderer">Renderer</h2>
<p><a href="http://hexo.io/docs/plugins.html#Renderer" target="_blank" rel="external">Renderer</a>将源文件转换成最终结果。在lib/plugins/renderer文件夹下可以看到默认的Renderer。默认的转换格式有html,htm,swig,yml等。另外hexo安装时会默认安装md,ejs和stylus的Renderer。</p>
<h2 id="Generator">Generator</h2>
<p><a href="http://hexo.io/docs/plugins.html#Generator" target="_blank" rel="external">Generator</a>根据Processor处理的结果生成静态文件。在lib/plugins/generator文件夹下可以看到默认的Generator。主要有下面几种</p>
<pre><code>generator.<span class="keyword">register</span>(<span class="string">'archive'</span>, <span class="keyword">require</span>(<span class="string">'./archive'</span>));
generator.<span class="keyword">register</span>(<span class="string">'category'</span>, <span class="keyword">require</span>(<span class="string">'./category'</span>));
generator.<span class="keyword">register</span>(<span class="string">'home'</span>, <span class="keyword">require</span>(<span class="string">'./home'</span>));
generator.<span class="keyword">register</span>(<span class="string">'page'</span>, <span class="keyword">require</span>(<span class="string">'./page'</span>));
generator.<span class="keyword">register</span>(<span class="string">'post'</span>, <span class="keyword">require</span>(<span class="string">'./post'</span>));
generator.<span class="keyword">register</span>(<span class="string">'tag'</span>, <span class="keyword">require</span>(<span class="string">'./tag'</span>));
generator.<span class="keyword">register</span>(<span class="string">'asset'</span>, <span class="keyword">require</span>(<span class="string">'./asset'</span>));
</code></pre><p>每一种Generator会根据数据库中的数据，对数据进一步加工生成最后的文件。比如post和page中的内容是html，在生成阶段会根据对应主题在html的基础上加上头尾。而asset类型的，这时数据库中只有文件信息还没有文件内容，这时asset生成器将处理方式存入hexo.route中在之后的生成阶段使用route记录的处理方式获取内容然后复制到目标位置。</p>
<h2 id="Box">Box</h2>
<p><a href="http://hexo.io/api/classes/Box.html" target="_blank" rel="external">Box</a>遍历Source文件夹下的所有文件，将具体文件分派给对应的Processor处理。</p>
<h2 id="Model">Model</h2>
<p><a href="http://hexo.io/api/classes/Model.html" target="_blank" rel="external">Model</a>是Hexo的数据库和数据模型，由Processor和Renderer写入数据，Generator读取数据。数据库是使用的warehouse, 主要的表有</p>
<pre><code>  model.<span class="keyword">register</span>(<span class="string">'Asset'</span>, schema.Asset);
  model.<span class="keyword">register</span>(<span class="string">'Cache'</span>, schema.Cache);
  model.<span class="keyword">register</span>(<span class="string">'Category'</span>, schema.Category, <span class="keyword">require</span>(<span class="string">'../model/category'</span>));
  model.<span class="keyword">register</span>(<span class="string">'Page'</span>, schema.Page);
  model.<span class="keyword">register</span>(<span class="string">'Post'</span>, schema.Post, <span class="keyword">require</span>(<span class="string">'../model/post'</span>));
  model.<span class="keyword">register</span>(<span class="string">'Tag'</span>, schema.Tag, <span class="keyword">require</span>(<span class="string">'../model/tag'</span>));
</code></pre><p>每次生成都会在根目录生成一个db.json，这个就是数据库的结构了。</p>
<h2 id="Theme">Theme</h2>
<p><a href="http://hexo.io/api/classes/Theme.html" target="_blank" rel="external">Theme</a>是连接Hexo核心库的桥梁。特别是在生成阶段当前主题进一步加工有Renderer生成的内容，生成最终的文件。</p>
<h2 id="Route">Route</h2>
<p><a href="http://hexo.io/api/classes/Router.html" target="_blank" rel="external">Route</a>有一个叫routes的属性，这是一个由文件路径作为key，和一个Function作为value的Map。这个Function的返回值就是文件的content。在生成阶段Generator会将最终数据存入这个Map里面。</p>
<h2 id="总结Hexo_Generate命令的工作流程">总结Hexo Generate命令的工作流程</h2>
<ul>
<li>用户终端输入命令 hexo generate。hexo启动，完成各模块初始化。 代码参见： <a href="https://github.com/hexojs/hexo/blob/master/lib/plugins/console/generate.js" target="_blank" rel="external">lib/plugins/console/generate.js</a>。</li>
<li>Box遍历source文件夹中的文件，将要处理的文件分类。代码参见：<a href="https://github.com/hexojs/hexo/blob/master/lib/box/index.js" target="_blank" rel="external">lib/box/index.js</a> 和 <a href="https://github.com/hexojs/hexo/blob/master/lib/plugins/processor/index.js" target="_blank" rel="external">lib/plugins/processor/index.js</a>。</li>
<li>各Processor处理对应文件，需要渲染的文件交由对应的Renderer渲染。并将渲染的数据写入数据库。代码参见：<a href="https://github.com/hexojs/hexo/tree/master/lib/plugins/processor" target="_blank" rel="external">lib/plugins/processor/</a> 和 <a href="https://github.com/hexojs/hexo/tree/master/lib/post" target="_blank" rel="external">lib/post/</a>。</li>
<li>各Generator根据数据库中的数据，根据对应主题进一步加工，将数据存入Route，最后写入目标位置。代码参见：<a href="https://github.com/hexojs/hexo/tree/master/lib/plugins/generator" target="_blank" rel="external">lib/plugins/generator/</a> 和 <a href="https://github.com/hexojs/hexo/blob/master/lib/theme/index.js" target="_blank" rel="external">lib/theme/index.js</a>。</li>
</ul>
<h2 id="一个小插件">一个小插件</h2>
<p>明白了基本原理之后，现在要实现一个小插件。需求是我现在的站点有一个文件夹project专门存放项目代码。但是每次hexo generate 都将public文件夹清空，然后写入文件。所以project文件夹要放在source下面。这样generate生成的时候就将project复制到public里面了。但是这又有一个问题，project我的项目文件夹不可避免的有代码，有些html文件他会自动加上页头和页尾，这个很不好。于是这个插件的功能就是在 _config.yml 配置一个参数允许自定义那些文件夹的内容是不需要渲染的直接复制到public文件夹。 基本思路就是 自定义一个processor，注册一个rule，只要是在这个列表中的文件就按照asset的方式处理。 附上插件地址 : <a href="https://github.com/f111fei/hexo-processor-copyassets" target="_blank" rel="external">https://github.com/f111fei/hexo-processor-copyassets</a></p>
<h2 id="题外:搭建NodeJS调试环境">题外:搭建NodeJS调试环境</h2>
<p>具体的步骤看这里:<a href="http://blog.domlib.com/articles/686.html" target="_blank" rel="external">http://blog.domlib.com/articles/686.html</a>。</p>
<p>这里我补充一下如何调试Hexo，其他的使用命令行的NodeJS调试也是同理。首先当然要下载好Hexo的源代码。然后比如源代码目录是 E:/workspace/hexo/ ，然后在该目录下执行 </p>
<pre><code>cd <span class="constant">E</span><span class="symbol">:/workspace/hexo/</span>
npm install -g 
</code></pre><p>安装一下，这一步是从npm服务器下载Hexo的依赖库，不然调试的时候会报错找不到依赖库。<br>然后创建一个Hexo站点(已经有的忽略下面这一步，直接cd到你的站点目录)</p>
<pre><code>cd <span class="constant">E</span><span class="symbol">:/workSpace/</span>
hexo init xzper.com
</code></pre><p>创建一个站点，这里假定站点目录是 E:/workSpace/xzper.com/ 。然后按照上面的教程，安装好调试工具并启动。</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> -g node-inspector
node-inspector</span>
</code></pre><p> 输入 node-inspector 启动调试工具。 最后最关键的一步，我们要调试hexo generate这个命令，那么在命令行中输入 </p>
<pre><code>cd <span class="constant">E</span><span class="symbol">:/workSpace/xzper</span>.com/
node --debug-brk=<span class="number">5858</span> <span class="constant">E</span><span class="symbol">:/workSpace/hexo/bin/hexo</span> generate
</code></pre><p>这时按照提示打开Chrome输入 <a href="http://127.0.0.1:8080/debug?port=5858" target="_blank" rel="external">http://127.0.0.1:8080/debug?port=5858</a> 断点会停在程序入口第一行，接下来你爱在哪设置断点就在哪设置。</p>
<h2 id="吐槽">吐槽</h2>
<p>我本来就得了一看JS代码就不好的病。然后这次为了搞懂Hexo，先初步学习了一下NodeJS，教程在<a href="http://www.open-open.com/lib/view/1392611872538" target="_blank" rel="external">这里</a>，不得不说本来就很讨厌的JS，再加上NodeJS最大的卖点-异步编程，那各种逼格极高的回调函数，看的我心花怒放，累觉不爱了。</p>
]]></content>
    <summary type="html"><![CDATA[<p><a href="https://github.com/hexojs/hexo" target="_blank" rel="external">Hexo</a>是一个轻量级的静态博客站点生成框架，使用NodeJS开发。经过我两个通宵的努力总算把这个东西研究了一个大概，这里拿来分享一下。</p>
]]></summary>
    
      <category term="Hexo" scheme="http://xzper.com/tags/Hexo/"/>
    
      <category term="解读" scheme="http://xzper.com/categories/%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[框架包结构的设计]]></title>
    <link href="http://xzper.com/2014/08/09/%E6%A1%86%E6%9E%B6%E5%8C%85%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://xzper.com/2014/08/09/框架包结构的设计/</id>
    <published>2014-08-08T16:43:25.000Z</published>
    <updated>2014-09-05T18:26:45.000Z</updated>
    <content type="html"><![CDATA[<p>这里的框架拿Flex或者FlexLite以及Egret做例子。框架的包结构划分应该是以调用关系为依据划分的，尽量把需要相互调用的类放在一个包下面。这样最终得到的结果就是各个包之间相互独立，理想情况下即使你删除一个包，其他的也不受影响。但是现实肯定不是理想的，包之间总是还有依赖。这些有依赖的东西，大部分就是框架里面核心的东西了。这时候就把这些公共依赖的部分抽出来，放到一个核心包下，比如叫core。 从另一种角度上来讲，所谓的框架”核心类”，实际上就是一些公共耦合的类。这样其他的包都和这个核心包有依赖关系，但是他们彼此之间没有依赖关系。</p>
<a id="more"></a>

<p>举一个例子：上面说到的三种框架都有一些枚举类，提供一下静态字符串，通常为其他类的某些属性提供值。再具体一点可以在Flex的spark.components包下面可以看到有一个PopUpPosition的一个枚举类，这里可能会奇怪，这个叫做components的包下面不应该都是放一些UI组件么，怎么多出了这么一个东西。别急，我们来看一下官方API描述：</p>
<p><pre class="lang:as decode:true">PopUpAnchor.popUpPosition 属性的枚举类型。该类型描述了 PopUpAnchor 锚定的 popUp 控件的位置。该位置与 PopUpAnchor 位置相关。</pre><br>这里明确指出了这个枚举类是和这个PopUpAnchor组件配套使用的，也不会作为其他类的某些属性的枚举类型。那么这个枚举类和组件放在一起也就无可厚非了。 我们再来看一下FlexLite里面的PopUpPosition这个类，同样的这也是一个枚举类，甚至全部的代码都和Flex里面的这个一样，但是这个类却不是在components包下面，而是在core包下面。同样的看一下API描述：</p>
<p><pre class="lang:as decode:true">定义弹出位置的常量值。 该常量决定目标对象相对于父级组件的弹出位置。</pre><br>看到这里结合上面所说的，那么这个类一定是和其他的某些类产生了依赖关系。在打开调用结构层次关系的时候会发现，不光是PopUpAnchor这个组件使用了这个常量，还有IToolTipManagerClient这个包含提示功能的组件接口也用到了这个，甚至DropDownList的默认皮肤以及ComboBox的默认皮肤也用到了这个弹出位置的常量，而这些在Flex里面是没有的。所有这两个类的包位置是不一致的。</p>
<p>通常，还有一些公共的依赖包比如managers以及layouts这些全局的管理类。还有一个utils的工具包，这些公共的类都有一个特点，就是除了依赖core包以外不会再依赖于其他的包了。再比如skins这个包，这个包提供组件的默认皮肤，我们完全可以直接删除这个包，整个框架也不会报错，但是他还是存在于框架中，因为他提供了一个默认的实现方式，方便了开发者以及调试。所有最后的结论就是，框架中包的划分是<strong>根据类的依赖关系来放，而不是类的特征。</strong></p>
]]></content>
    <summary type="html"><![CDATA[<p>这里的框架拿Flex或者FlexLite以及Egret做例子。框架的包结构划分应该是以调用关系为依据划分的，尽量把需要相互调用的类放在一个包下面。这样最终得到的结果就是各个包之间相互独立，理想情况下即使你删除一个包，其他的也不受影响。但是现实肯定不是理想的，包之间总是还有依赖。这些有依赖的东西，大部分就是框架里面核心的东西了。这时候就把这些公共依赖的部分抽出来，放到一个核心包下，比如叫core。 从另一种角度上来讲，所谓的框架”核心类”，实际上就是一些公共耦合的类。这样其他的包都和这个核心包有依赖关系，但是他们彼此之间没有依赖关系。</p>
]]></summary>
    
      <category term="架构" scheme="http://xzper.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="框架" scheme="http://xzper.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解读DXML编译器]]></title>
    <link href="http://xzper.com/2014/07/02/%E8%A7%A3%E8%AF%BBDXML%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <id>http://xzper.com/2014/07/02/解读DXML编译器/</id>
    <published>2014-07-02T08:22:49.000Z</published>
    <updated>2014-09-06T04:48:09.000Z</updated>
    <content type="html"><![CDATA[<p>DXML就是FlexLite中由FlexLiteStdio生成的皮肤文件，类似于Flex中的MXML。实际上区别没多少，可能最大的区别就是MXML支持Script脚本。DXML架构设计对编写各类UI编辑器，各类代码生成工具都有很好的参考价值。这里主要分析DXML编译器是如何将DXML文件转换为as代码。</p>
<a id="more"></a>

<p><strong>1.如何使用DXML编译器</strong></p>
<p>DXML编译器在源代码在FlexLiteExtends中的org.flexlite.domCompile包下。导入相应的类后，先导入配置文件manifest.xml(这个文件可以在FlexLiteStdio的安装目录的bin文件夹下可以找到，也可以通过ManifestUtil这个类生成)。这是一个全局静态属性，导入代码如下:</p>
<pre><code><span class="attribute">DXMLCompiler.configData </span>=<span class="string"> manifestXml;</span>
</code></pre><p>然后创建一个DXMLCompiler实例，调用compile方法得到编译后的结果:</p>
<pre><code><span class="keyword">var</span> compiler:<span class="type">DXMLCompiler</span> = new <span class="type">DXMLCompiler</span>();
<span class="keyword">var</span> <span class="literal">result</span>:<span class="type">String</span>  = compiler.compile(buttonSkinXml , <span class="string">"Button"</span>);
</code></pre><p>完整的代码如下:</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">DXMLCompilerTest</span> <span class="keyword">extends</span> <span class="title">Sprite</span></span>
{
    [Embed(source=<span class="string">"resource/xml/flexlite-manifest.xml"</span> , mimeType = <span class="string">"application/octet-stream"</span>)]
    <span class="keyword">private</span> <span class="keyword">var</span> manifest:Class;

    [Embed(source=<span class="string">"resource/xml/ButtonSkin.dxml"</span> , mimeType = <span class="string">"application/octet-stream"</span>)]
    <span class="keyword">private</span> <span class="keyword">var</span> buttonSkin:Class;

    public function DXMLCompilerTest()
    {
        <span class="keyword">super</span>();

        <span class="keyword">var</span> manifestBy:ByteArray = <span class="keyword">new</span> manifest();
        <span class="comment">//flexlite-manifest.xml对象</span>
        <span class="keyword">var</span> manifestXml:XML = XML(manifestBy.readUTFBytes(manifestBy.length));

        <span class="keyword">var</span> buttonSkinBy:ByteArray = <span class="keyword">new</span> buttonSkin();
        <span class="comment">//ButtonSkin.dxml对象</span>
        <span class="keyword">var</span> buttonSkinXml:XML = XML(buttonSkinBy.readUTFBytes(buttonSkinBy.length));

        <span class="comment">//flexlite-manifest框架清单文件</span>
        DXMLCompiler.configData = manifestXml;

        <span class="keyword">var</span> compiler:DXMLCompiler = <span class="keyword">new</span> DXMLCompiler();
        <span class="keyword">var</span> result:String  = compiler.compile(buttonSkinXml , <span class="string">"Button"</span>);
        trace(result);
    }
}
</code></pre><p><strong>2.配置文件manifest</strong></p>
<p>manifest是由编译器使用的配置文件，定义了编译器能识别的各类组件。</p>
<pre><code>&lt;componentPackage <span class="variable">crc32=</span><span class="string">"a32782dd"</span>&gt;
    &lt;component <span class="variable">id=</span><span class="string">"ArrayCollection"</span> <span class="variable">p=</span><span class="string">"org.flexlite.domUI.collections.ArrayCollection"</span> <span class="variable">s=</span><span class="string">"flash.utils.Proxy"</span> <span class="variable">d=</span><span class="string">"source"</span> <span class="variable">array=</span><span class="string">"true"</span>/&gt;
    &lt;component <span class="variable">id=</span><span class="string">"Button"</span> <span class="variable">p=</span><span class="string">"org.flexlite.domUI.components.Button"</span> <span class="variable">s=</span><span class="string">"org.flexlite.domUI.components.supportClasses.ButtonBase"</span> <span class="variable">show=</span><span class="string">"true"</span>/&gt;
    &lt;component <span class="variable">id=</span><span class="string">"ButtonBase"</span> <span class="variable">p=</span><span class="string">"org.flexlite.domUI.components.supportClasses.ButtonBase"</span> <span class="variable">s=</span><span class="string">"org.flexlite.domUI.components.SkinnableComponent"</span> <span class="variable">d=</span><span class="string">"label"</span> <span class="variable">state=</span><span class="string">"up,over,down,disabled"</span>/&gt;
    &lt;component <span class="variable">id=</span><span class="string">"Group"</span> <span class="variable">p=</span><span class="string">"org.flexlite.domUI.components.Group"</span> <span class="variable">s=</span><span class="string">"org.flexlite.domUI.components.supportClasses.GroupBase"</span> <span class="variable">d=</span><span class="string">"elementsContent"</span> <span class="variable">show=</span><span class="string">"true"</span> <span class="variable">array=</span><span class="string">"true"</span>/&gt;
&lt;/componentPackage&gt;
</code></pre><p>以上节选自flexlite-manifest.xml。manifest.xml由各类component组成，包括但不限于UI组件。主要是用来配置对dxml文件中可能出现的节点的定义供编译器解析。component节点对应编译器中的Component类，各个属性解释如下</p>
<p><strong>id</strong>，这个组件的短名ID，对应Component的id属性</p>
<p><strong>p</strong>，组件的完整类名，对应Component的className属性</p>
<p><strong>s</strong>，父级类名，对应Component的superClass属性</p>
<p><strong>d</strong>，默认属性，对应Component的defaultProp属性，这个实际就是表示这个组件的子节点对应的属性</p>
<p><strong>array</strong>，默认属性是否为数组类型，对应Component的isArray属性</p>
<p><strong>states</strong>，视图状态列表，对应Component的states属性</p>
<p>比如：</p>
<pre><code>&lt;dx:Group <span class="variable">left=</span><span class="string">"16"</span> <span class="variable">right=</span><span class="string">"16"</span> <span class="variable">top=</span><span class="string">"41"</span> <span class="variable">id=</span><span class="string">"contentGroup"</span> <span class="variable">bottom=</span><span class="string">"42"</span>/&gt;
    &lt;dx:Label <span class="variable">text=</span><span class="string">"标签"</span> <span class="variable">size=</span><span class="string">"14"</span> <span class="variable">maxWidth=</span><span class="string">"310"</span> <span class="variable">textColor=</span><span class="string">"0xFFFFFF"</span>/&gt;
&lt;/dx:Group&gt;
</code></pre><p>这里有一个Group组件，然后对应一个子节点Label。那么Group的defaultProp也就是elementsContent这个属性对应的值是个数组，其中的一项就是Label。同理，比如ArrayCollection节点有子节点，那么source属性对应的值就是这些子节点。</p>
<p><strong>2. 代码定义CodeBase</strong></p>
<p>CodeBase是代码定义的基类，其中的toCode方法就是生成代码的关键。编译器中扩展了CodeBase实现了各种代码定义，比如注释，变量定义，参数定义，函数定义，类定义和代码块。这里挑几个重点的说:</p>
<p><strong>函数定义CpFunction</strong>。一个函数主要由 修饰符(private,protected,public)，函数名 ，参数列表(CpArguments数组)和代码块(CpCodeBlock)组成。另外还有一些override，static之类的关键词标示符。</p>
<p><strong>代码块CpCodeBlock</strong>。代码块就是函数中的内容，主要提供了一些添加语句的方法，比如 添加变量声明语句addVar，添加赋值语句addAssignment，添加一行代码addCodeLine等。开发者调用这些方法从而完成代码块的内容。</p>
<p><strong>类定义CpClass</strong>。定义了一个类的代码，类的组成主要有 定义部分(例如:类注释， 类名，包名，修饰符，父类，接口)，导入包区块，构造函数，成员变量，成员函数。CpClass提供各种方法来完善这些内容，比如:导入包addImport，添加变量addVariable，添加函数addFunction。</p>
<p>有了这些，在完成类中各个区块的定义和赋值之后，调用toCode方法转换成as代码。</p>
<p><strong>3.解析配置文件DXMLConfig</strong></p>
<p>manifest.xml的解析交给DXMLConfig来完成，DXMLConfig解析完成后存储配置文件中的组件对应的基本属性已经映射关系。解析完成后，外界可以使用的主要方法有:<br>    /**</p>
<pre><code> * 根据类的短名ID和命名空间获取完整类名(以<span class="string">"."</span>分隔)
 * @param id 类的短名ID
 * @param ns 命名空间
 */                
<span class="function"><span class="keyword">function</span> <span class="title">getClassNameById</span><span class="params">(id:String,ns:Namespace)</span><span class="type">:String</span></span>;

<span class="comment">/**
 * 根据ID获取对应的默认属性
 * @param id 类的短名ID
 * @param ns 命名空间
 * @return {name:属性名(String),isArray:该属性是否为数组(Boolean)}
 */</span>        
<span class="function"><span class="keyword">function</span> <span class="title">getDefaultPropById</span><span class="params">(id:String,ns:Namespace)</span><span class="type">:Object</span></span>;

<span class="comment">/**
 * 获取指定属性的类型,返回基本数据类型："uint","int","Boolean","String","Number","Class"。
 * @param prop 属性名
 * @param className 要查询的完整类名
 * @param value 属性值
 */</span>            
<span class="function"><span class="keyword">function</span> <span class="title">getPropertyType</span><span class="params">(prop:String,className:String,value:String)</span><span class="type">:String</span></span>;
</code></pre><p><strong>4.了解DXML文件结构</strong></p>
<p>在了解编译器是如何工作之前，需要了解DXML文件的结构。这里通过一个典型例子来了解DXML的结构。</p>
<pre><code>&lt;xml <span class="variable">version=</span><span class="string">"1.0"</span> <span class="variable">encoding=</span><span class="string">"utf-8"</span>&gt;
&lt;dx:StateSkin <span class="variable">width=</span><span class="string">"100"</span> xmlns:<span class="variable">dx=</span><span class="string">"http://www.flexlite.org/dxml/2012"</span> xmlns:<span class="variable">fs=</span><span class="string">"http://www.flexlite.org/studio/2012"</span>&gt;
    &lt;fs:HostComponent <span class="variable">name=</span><span class="string">"org.flexlite.domUI.components.Button"</span>/&gt;
    &lt;fs:Declarations&gt;
        &lt;dx:DropShadowFilter <span class="variable">alpha=</span><span class="string">"1.00"</span> <span class="variable">angle=</span><span class="string">"0.00"</span> <span class="variable">blurY=</span><span class="string">"4"</span> <span class="variable">color=</span><span class="string">"0x000000"</span> <span class="variable">quality=</span><span class="string">"1"</span> <span class="variable">blurX=</span><span class="string">"4"</span> <span class="variable">hideObject=</span><span class="string">"false"</span> <span class="variable">distance=</span><span class="string">"0"</span> <span class="variable">inner=</span><span class="string">"false"</span> <span class="variable">strength=</span><span class="string">"10"</span> <span class="variable">knockout=</span><span class="string">"false"</span> <span class="variable">id=</span><span class="string">"__DropShadowFilter0"</span>/&gt;
    &lt;/fs:Declarations&gt;
    &lt;dx:states&gt;
        &lt;dx:State <span class="variable">name=</span><span class="string">"up"</span>/&gt;
        &lt;dx:State <span class="variable">name=</span><span class="string">"over"</span>/&gt;
        &lt;dx:State <span class="variable">name=</span><span class="string">"down"</span>/&gt;
        &lt;dx:State <span class="variable">name=</span><span class="string">"disabled"</span>/&gt;
    &lt;/dx:states&gt;
    &lt;dx:UIAsset <span class="variable">left=</span><span class="string">"0"</span> <span class="variable">y=</span><span class="string">"0"</span> <span class="variable">top=</span><span class="string">"0"</span> <span class="variable">right=</span><span class="string">"0"</span> <span class="variable">skinName=</span><span class="string">"DXR__1C5D2D62"</span> <span class="variable">bottom=</span><span class="string">"0"</span> <span class="variable">x=</span><span class="string">"0"</span> <span class="variable">includeIn=</span><span class="string">"disabled"</span>/&gt;
    &lt;dx:UIAsset <span class="variable">left=</span><span class="string">"0"</span> <span class="variable">top=</span><span class="string">"0"</span> <span class="variable">bottom=</span><span class="string">"0"</span> <span class="variable">skinName=</span><span class="string">"DXR__276F2CB5"</span> <span class="variable">right=</span><span class="string">"0"</span> <span class="variable">includeIn=</span><span class="string">"up"</span>/&gt;
    &lt;dx:UIAsset <span class="variable">left=</span><span class="string">"0"</span> <span class="variable">top=</span><span class="string">"0"</span> <span class="variable">bottom=</span><span class="string">"0"</span> <span class="variable">skinName=</span><span class="string">"DXR__7905FD81"</span> <span class="variable">right=</span><span class="string">"0"</span> <span class="variable">includeIn=</span><span class="string">"down"</span>/&gt;
    &lt;dx:UIAsset <span class="variable">left=</span><span class="string">"0"</span> <span class="variable">top=</span><span class="string">"0"</span> <span class="variable">bottom=</span><span class="string">"0"</span> <span class="variable">skinName=</span><span class="string">"DXR__F2888F03"</span> <span class="variable">right=</span><span class="string">"0"</span> <span class="variable">includeIn=</span><span class="string">"over"</span>/&gt;
    &lt;dx:Label <span class="variable">paddingTop=</span><span class="string">"4"</span> <span class="variable">id=</span><span class="string">"labelDisplay"</span> <span class="variable">horizontalCenter=</span><span class="string">"0"</span> <span class="variable">text=</span><span class="string">"按钮"</span> <span class="variable">size=</span><span class="string">"14"</span> <span class="variable">textAlign=</span><span class="string">"center"</span> <span class="variable">paddingBottom=</span><span class="string">"4"</span> <span class="variable">filters=</span><span class="string">"{[__DropShadowFilter0]}"</span> <span class="variable">paddingLeft=</span><span class="string">"10"</span> <span class="variable">bold=</span><span class="string">"false"</span> <span class="variable">textColor=</span><span class="string">"0xFFFFCD"</span> <span class="variable">paddingRight=</span><span class="string">"10"</span> <span class="variable">fontFamily=</span><span class="string">"FZShaoEr-M11S"</span> <span class="variable">verticalCenter=</span><span class="string">"0"</span>/&gt;
&lt;/dx:StateSkin&gt;
</code></pre><p><strong>根节点</strong>。每个DXML文件对应一个as类，根节点就是这个类定义，在这里可以定义类的属性以及对应的值。另外这里还有命名空间NameSpace的定义。默认的命名空间有dx和fs。命名空间主要用来快速区别节点，从而快速过滤对节点执行对应操作。</p>
<p><strong>声明节点</strong>。DXML中一些不可视的一些元素可以定义在声明节点中，作为fs:Declarations这个节点的子节点。上述例子中的阴影滤镜就是在这个节点中。</p>
<p><strong>States节点</strong>。States定义了组件的各个状态。</p>
<p><strong>组件节点</strong>。一般以dx开头的节点就是组件节点，当然组件节点也可以自定义(使用自定义组件所在的包作为新的命名空间，添加到根节点中)。这里可使用的组件是和manifest.xml中对应的。在组件节点中可以对组件的各个属性赋值。另外，组件节点有一些共有的特殊属性，比如: id 表示组件对应的实例名，includeIn，excludeFrom表示组件对应的状态。还有上面提到的，组件如果有子节点，那么这些子节点就是组件对应的默认值。</p>
<p><strong>5.DXML编译器</strong></p>
<p><strong>编译开始的准备工作</strong></p>
<p>在编译开始前，创建DXMLConfig实例解析manifest配置，读取dxml文件。创建一个CpClass实例currentClass。</p>
<p><strong>编译开始</strong></p>
<p>调用startCompile编译开始，通过getStateNames方法获取dxml中定义的所有状态并使用stateCode保存。然后为根节点加入currentState的属性并赋值。使用declarations保存dxml的声明节点。然后调用addIds方法遍历各个节点添加成员变量以及函数。最后是生成构造函数。</p>
<p><strong>导入包，添加import区块</strong></p>
<p>包的导入，并不是一次性导入，而是贯彻在整个编译过程中。通常在调用getPackageByNode这个方法时来添加import区块。因为每个节点一般对应一个class，这样在分析节点时就能获取到节点的className，从而导入。</p>
<p><strong>依据id添加成员变量，以及自动为组件添加id属性</strong></p>
<p>某些节点具有id属性，那么一般这个节点对应的实例就是这个类的成员变量，实例名就是这个id的值，调用createVarForNode方法将节点添加进成员变量列表。某些组件没有id属性，那么调用createIdForNode给每一个组件节点加上id属性，赋值也遵循一定规范不会重复。另外有些组件是只存在于某些特定状态下的，这时会使用stateIds记录下来，随后在构造函数里面单独实例化。以上过程的具体实现参考addIds这个方法，整个过程是递归的。</p>
<p><strong>创建构造函数</strong></p>
<p>函数的主要内容就是代码块，首先创建一个代码块实例。通过addAttributesToCodeBlock方法解析根节点的所有属性，并生成赋值语句。解析declarations的子节点，调用createFuncForNode为每一个子节点创建对应的方法。使用initlizeChildNode方法遍历组件的子组件，对组件的默认属性赋值。最后解析状态代码，完成所有状态的赋值。</p>
<p>简而言之，解析一个组件的大致思路就是，通过addAttributesToCodeBlock方法解析节点的属性并赋值，然后使用initlizeChildNode方法遍历节点的子节点为默认属性赋值。在initlizeChildNode方法中调用createFuncForNode，为每个子节点创建单独的函数。而createFuncForNode这个方法中又会调用addAttributesToCodeBlock和initlizeChildNode解析节点属性和为默认属性赋值，如此递归调用下去。</p>
<p><strong>重要方法解析</strong></p>
<p><strong>createVarForNode</strong></p>
<p>创建成员变量。一般带有id的组件节点都会被调用这个方法创建对应id的实例名变量。</p>
<p><strong>addAttributesToCodeBlock</strong></p>
<p>解析组件的属性并赋值。对应一些特殊属性比如id，includeIn，locked已经带有”.”操作符的属性是不理会的。这样获取一个keyList，读取对应的value，格式化key和value然后添加赋值语句。有些key比较特殊比如height，因为对应的值可能是一个百分比所以需要格式化key转换成percentHeight。格式化value就比较麻烦了，有些value是带”{}”的要去掉{}，有些特殊的key比如skinName对应的value可能是一个class，这些key-value的转换规则通过DXMLConfig的getPropertyType来获取。最后如果对应的值是一个id即成员变量，则需要延迟赋值，到那个成员变量的创建函数中赋值。</p>
<p><strong>initlizeChildNode</strong></p>
<p>某些组件含有子节点，这些子节点就是这个组件对应的默认属性的值。这个方法首先获取直接子节点directChild，然后调用createFuncForNode，为每个子节点创建单独的函数。最后生成默认属性的赋值语句。对于一些包含状态的子节点是会被过滤掉的，因为有专门的状态生成代码。</p>
<p><strong>createFuncForNode</strong></p>
<p>实际上创建构造函数也是实现了这个方法。先调用addAttributesToCodeBlock，然后调用initlizeChildNode。只是创建构造函数多了一个解析声明节点和解析状态的过程。这个方法有一个创建构造函数没有的过程就是，添加一个变量声明(实际上就是实例化这个节点对应的类)，为节点的id属性赋值为这个节点变量。原来还会在延迟赋值字典里面加入对应的延迟赋值语句。</p>
<p><strong>createStates</strong></p>
<p>这个是在创建构造函数时被调用的，主要用来解析视图状态代码。本身是一个递归函数。遍历所有的子节点，找到那些在特定状态下出现节点。分解成每一个CpState填充进stateCode。</p>
]]></content>
    <summary type="html"><![CDATA[<p>DXML就是FlexLite中由FlexLiteStdio生成的皮肤文件，类似于Flex中的MXML。实际上区别没多少，可能最大的区别就是MXML支持Script脚本。DXML架构设计对编写各类UI编辑器，各类代码生成工具都有很好的参考价值。这里主要分析DXML编译器是如何将DXML文件转换为as代码。</p>
]]></summary>
    
      <category term="FlexLite" scheme="http://xzper.com/tags/FlexLite/"/>
    
      <category term="ActionScript3" scheme="http://xzper.com/tags/ActionScript3/"/>
    
      <category term="解读" scheme="http://xzper.com/categories/%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用egret开发2048]]></title>
    <link href="http://xzper.com/2014/06/22/%E4%BD%BF%E7%94%A8egret%E5%BC%80%E5%8F%912048/"/>
    <id>http://xzper.com/2014/06/22/使用egret开发2048/</id>
    <published>2014-06-22T12:41:00.000Z</published>
    <updated>2014-09-05T18:25:07.000Z</updated>
    <content type="html"><![CDATA[<p>2048是最近很火的一个小游戏，<a href="http://gabrielecirulli.github.io/2048/" target="_blank" rel="external">原版</a> 就是用JavaScript写的。恰巧最近Egret PublicBeta，观望和学习了一阵后，发现egret正好适合开发这类游戏。Egret使用TypeScript作为开发语言，最终编译为JavaScript，正好和原始版本PK一下。</p>
<p>游戏预览：<a href="http://xzper.com/project/2048egret/" target="_blank" rel="external">点我体验</a></p>
<a id="more"></a>

<p><strong>1.准备开始</strong></p>
<p>在开始之前，我们需要学习一下TypeScript和阅读官方的教程从Egret开发环境的部署到创建，编译，发布项目，以及Egret相关工具。在安装好开发环境后，在工作空间目录下使用命令行，创建2048egret新项目</p>
<pre><code>egret <span class="operator"><span class="keyword">create</span> <span class="number">2048</span>egret</span>
</code></pre><p><strong>2.准备素材</strong></p>
<p>每一个游戏都离不开美术资源，我们需要做的就是把美术资源打包，然后加载进来使用。这一方面egret有一套完整的工作流。</p>
<p><strong>①资源打包</strong></p>
<p>这里我们用到的资源主要有按钮，背景，文字以及数字这些图片。我们选择把这些图片都打包在一起合成一张大图就像 <a href="http://xzper.com/project/2048egret/resource/assets/source.png" target="_blank" rel="external">这样</a> 和 <a href="http://xzper.com/project/2048egret/resource/assets/number.png" target="_blank" rel="external">这样</a> 这样做可以减少URL请求数，还能减少资源的体积，把一些具有相同特征的图片放在一起便于管理。在egret里面这种类型的资源就是sheet。只有图片是不够的，还需要一个json描述文件来说明这张图每一张小图片的位置和大小。目前已经有成熟的工具来生成sheet和json。这里我用到的是 <a href="http://www.renderhjs.net/shoebox/" target="_blank" rel="external">ShoeBox</a> 配合这个 <a href="https://github.com/runinspring/egretTools" target="_blank" rel="external">插件</a> 来生成egret能识别的json。安装好插件后， 将每一张图片命名，然后将这些图片选中拖入Sprites Sheet中然后配置好生成的文件名点击save就能得到一张大图和一个json了，将图片和json放入”resource/assets/“文件夹下以备使用。此外ShoeBox还能读取swf将MovieClip导出为这种大图，按每一帧自动命名，这里的number.png就是这样导出的，下面有原始素材下载地址。</p>
<p><strong>②资源加载</strong></p>
<p>接下来我们需要生成一个资源描述文件resource.json，在游戏开始之前读取这个json来加载对应的文件。egret的资源加载机制可以参考 <a href="https://github.com/egret-labs/egret-core/wiki/Using%20Resource%20System" target="_blank" rel="external">这里</a> 现在已经有 <a href="http://bbs.egret-labs.org/thread-48-1-1.html" target="_blank" rel="external">工具</a> 能自动生成这个resource.json了。按照下图配置。<strong>注意：虽然我们的资源有图片，但是对应的json文件已经记录了图片的位置，所以在这个工具中我们不需要添加对应的图片只添加json文件就行了。</strong></p>
<center><img src="http://xzper.qiniudn.com/2014/06/ResTool.png" alt=""></center>

<p>在项目初始化时，使用RES加载资源，简单明了。</p>
<pre><code><span class="keyword">private</span> <span class="title">onAddToStage</span>(event:egret.Event){
    ........
    ........
    <span class="comment">//初始化Resource资源加载库</span>
    RES.addEventListener(RES.ResourceEvent.CONFIG_COMPLETE,<span class="keyword">this</span>.onConfigComplete,<span class="keyword">this</span>);
    RES.loadConfig(<span class="string">"resource/resource.json"</span>,<span class="string">"resource/"</span>);
}

<span class="javadoc">/**
 *配置文件加载完成,开始预加载preload资源组。
 */</span>
<span class="keyword">private</span> <span class="title">onConfigComplete</span>(event:RES.ResourceEvent):<span class="keyword">void</span>{
    RES.removeEventListener(RES.ResourceEvent.CONFIG_COMPLETE,<span class="keyword">this</span>.onConfigComplete,<span class="keyword">this</span>);
    RES.addEventListener(RES.ResourceEvent.GROUP_COMPLETE,<span class="keyword">this</span>.onResourceLoadComplete,<span class="keyword">this</span>);
    RES.addEventListener(RES.ResourceEvent.GROUP_PROGRESS,<span class="keyword">this</span>.onResourceProgress,<span class="keyword">this</span>);
    RES.loadGroup(<span class="string">"preload"</span>);
}
</code></pre><p><strong>③资源使用</strong></p>
<p>在项目中我们可以使用RES来使用资源，参照对应的API。对于没有写进配置文件的资源使用RES.getResByUrl方法来异步获取。开发人员能使用极其少量的代码来完成各类资源的加载。</p>
<p><strong>3.更改模板生成的代码</strong></p>
<p><strong>①修改细节</strong></p>
<p>默认的文档类是GameApp。我觉得还是叫Main比较亲切，修改类名称，然后修改项目目录下的egretProperties.json文件，将document_class的值改为Main</p>
<pre><code>{
    "<span class="attribute">document_class</span>" : <span class="value"><span class="string">"Main"</span></span>,
    "<span class="attribute">native</span>": <span class="value">{
        "<span class="attribute">path_ignore</span>": <span class="value">[
            <span class="string">"libs"</span>
        ]
    </span>}
</span>}
</code></pre><p>默认生成的html的背景是黑色的，这里全部改成白色。将index.html里面的背景替换成#ffffff。</p>
<p>默认尺寸是480x800的尺寸。由于我们使用的部分图片宽度大于500，以及部分PC的分辨率太小为了不出现垂直滚动条影响体验，将尺寸换成520x650。这个不影响移动设备上的尺寸，移动设备默认是自适应宽度的。</p>
<p>index.html中</p>
<pre><code>&lt;div <span class="variable">style=</span><span class="string">"display:inline-block;width:100%; height:100%;margin: 0 auto; background: #ffffff; position:relative;"</span> <span class="variable">id=</span><span class="string">"gameDiv"</span>&gt;
    &lt;canvas <span class="variable">id=</span><span class="string">"gameCanvas"</span> <span class="variable">width=</span><span class="string">"520"</span> <span class="variable">height=</span><span class="string">"650"</span> <span class="variable">style=</span><span class="string">"background-color: #ffffff"</span>&gt;&lt;/canvas&gt;
&lt;/div&gt;
</code></pre><p>egret_loader.js中</p>
<pre><code>//设置屏幕适配策略
egret.StageDelegate.getInstance().setDesignSize(<span class="number">520</span>, <span class="number">650</span>);
context.<span class="variable">stage =</span> new egret.Stage();
var <span class="variable">scaleMode =</span>  egret.MainContext.<span class="variable">deviceType =</span>= egret.MainContext.DEVICE_MOBILE ? egret.StageScaleMode.SHOW_ALL : egret.StageScaleMode.NO_SCALE;
context.stage.<span class="variable">scaleMode =</span> scaleMode;
</code></pre><p><strong>③引入第三方库pureMVC</strong></p>
<p>这次我们要使用到一个mvc开发框架-pureMVC，熟悉as3的朋友一定也对这个框架不陌生吧。不熟悉的也没关系，这个框架不是这次的主角。我们从 <a href="https://github.com/PureMVC/puremvc-typescript-standard-framework" target="_blank" rel="external">这里</a> 下载pureMVC的TypeScript版本。得到puremvc-typescript-standard-1.0.d.ts 和 puremvc-typescript-standard-1.0.js这两个文件，其实.d.ts就类似于c++里面的.h头文件，只有空方法和空属性，真正的实现是在js文件或者ts文件里面。在项目里面的src文件夹下建立一个puremvc的文件夹，将这个js文件和d.ts文件放进去。然后在项目根目录下建立一个puremvc.json的文件内容如下</p>
<pre><code>{
    "<span class="attribute">name</span>": <span class="value"><span class="string">"puremvc"</span></span>,
    "<span class="attribute">source</span>":<span class="value"><span class="string">"src/puremvc/"</span></span>,
    "<span class="attribute">file_list</span>": <span class="value">[
        <span class="string">"puremvc-typescript-standard-1.0.js"</span>,
        <span class="string">"puremvc-typescript-standard-1.0.d.ts"</span>
    ]
</span>}
</code></pre><p>这样就表示配置了一个第三方模块。之后在编译器编译时会把相应的模块对应的js文件夹编译进libs文件夹下。项目里面我们还使用了gui模块，这些模块的配置是在egretProperties.json中，部分代码如下</p>
<pre><code><span class="string">"modules"</span>: [
    {
        <span class="string">"name"</span>: <span class="string">"core"</span>
    },
    {
        <span class="string">"name"</span>: <span class="string">"gui"</span>
    },
    {
        <span class="string">"name"</span>: <span class="string">"puremvc"</span>,<span class="string">"path"</span>:<span class="string">"."</span>
    }
],
</code></pre><p><strong>④注入AssetAdapter和SkinAdapter</strong></p>
<p>我们这次的主角是egret的GUI。找到官方<a href="https://github.com/egret-labs/egret-examples" target="_blank">GUIExample</a>中的这两个ts文件复制到项目的src文件夹下面，由于这个项目没有用到默认皮肤，删除ShinAdapter里面getDefaultSkin方法的默认皮肤。最后不要忘了一点，在引擎初始化的时候注入这两个Adapter。</p>
<pre><code><span class="keyword">private</span> onAddToStage(event:egret<span class="built_in">.</span>Event){
        <span class="comment">//注入自定义的素材解析器</span>
        egret<span class="built_in">.</span>Injector<span class="built_in">.</span>mapClass(<span class="string">"egret.gui.IAssetAdapter"</span>,AssetAdapter);
        <span class="comment">//注入自定义的皮肤解析器</span>
        egret<span class="built_in">.</span>Injector<span class="built_in">.</span>mapClass(<span class="string">"egret.gui.ISkinAdapter"</span>,SkinAdapter);
        <span class="attribute">...</span><span class="attribute">...</span>
        <span class="attribute">...</span><span class="attribute">...</span>
}
</code></pre><p>这两个的Adapter的作用至关重要，AssetAdapter负责解释UIAsset的source属性 ，SkinAdapter负责解释SkinnableCompent的skinName属性。这里官方提供了两个默认已经写好了的，当然我们可以自己扩展。 没有他们，UIAsset素材包装器的source属性 和 可设置皮肤的GUI组件的skinName属性毫无作用。而这两种组件是今后使用最多的。不信可以往下看 。</p>
<p><strong>⑤修改createGameScene方法</strong></p>
<p>在生成的模板中，文档类Main在经过一系列的前期准备工作之后，终于轮到GUI组件的老大UIStage上场了。UIStage类似于Flex里面的SystemManager，内置弹出窗口层，工具提示层和鼠标样式层，所有的GUI组件都应该添加到他的下面，并且UIStage全局唯一。  这里我们实现了一个AppContainer继承自UIStage。 同时在这里pureMVC框架正式启动，开始运作。</p>
<pre><code><span class="javadoc">/**
 * 创建游戏场景
 */</span>
<span class="keyword">private</span> <span class="title">createGameScene</span>():<span class="keyword">void</span> {
    var appContainer:game.AppContainer = <span class="keyword">new</span> game.AppContainer();
    <span class="keyword">this</span>.addChild(appContainer);
    game.ApplicationFacade.getInstance().startUp(appContainer);
}
</code></pre><p><strong>4.pureMVC</strong></p>
<p><strong>①Mediator</strong></p>
<p>Mediator(中介器)是连接视图也就是egret的GUI和pureMVC的桥梁。Mediator受到消息时(handleNotification)调用GUI组件的方法和设置属性，来改变视图。或者视图发生改变时通知Mediator由其发送消息到pureMVC(sendNotification)。</p>
<p><strong>ApplicationMediator</strong> 监听键盘事件或者手势发送消息到GameCommand通知移动</p>
<p><strong>MainGameMediator</strong> 接收消息，调用MainGameUI的方法处理格子的移动，添加，删除，重置，以及接收游戏结果，显示结果面板</p>
<p><strong>MainMenuMediator</strong> 接收更新分数的消息，调用MainGameUI的方法更新分数与重置</p>
<p><strong>ResultWindowMediator</strong> 发送游戏重置的消息，以及自销毁。</p>
<p><strong>②Command</strong></p>
<p>command属于控制器。负责收发消息和处理简单的事务。在StartupCommand中使用ControllerPrepCommand，ModelPrepCommand，ViewPrepCommand三个子任务。分别注册控制器，数据和视图。</p>
<p><strong>GameCommand</strong> 处理各类事务。比如 玩家按下了方向键，收到消息调用GridProxy的移动方法改变数据，比如GridProxy移动格子分数改变了，通知GameCommand 调用GameProxy的更新分数方法改变分数，比如处理重置游戏的事务，通知各个数据模块重置数据</p>
<p><strong>③Proxy</strong></p>
<p>处理数据，提供公共方法供Command调用以改变数据。改变数据了然后sendNotification通知Mediator改变视图。</p>
<p><strong>GameProxy</strong> 处理游戏数据，比如更新分数，处理游戏结果</p>
<p><strong>GridProxy</strong> 这个游戏的核心数据，操作每一个格子的数据，通知视图格子的移动，添加，删除，重置。这里包含2048这个游戏的精髓。有兴趣的可以研究下，源码里面有详细注释，这篇文章不做重点讲解。</p>
<p><strong>5.egret的GUI</strong></p>
<p><strong>①制作菜单———-认识皮肤部件</strong></p>
<p>先来看看菜单长什么样子</p>
<p><img src="http://xzper.qiniudn.com/2014/06/菜单.jpg" alt=""></p>
<p>我们会发现这个菜单。有些是静态文本，是一直不变的，我偷懒直接用了一张图片代替了，图片可以用egret.gui.UIAsset。</p>
<p>还有当前得分和最高分已经那个向上飘的数字是动态的，可以选用egret.gui.Label这个组件。</p>
<p>一个重试按钮，既然已经说了是按钮了我们就用egret.gui.Button好了。</p>
<p>接下来我们要做到皮肤和组件分离。那几个需要参与逻辑的组件自然就成了皮肤部件了。来看看MainMenuUISkin：</p>
<pre><code><span class="javadoc">/**
 * 和主机组件匹配的皮肤部件
 */</span>
<span class="keyword">private</span> <span class="keyword">static</span> _skinParts:Array&amp;lt;string&amp;gt; = [<span class="string">"addLabel"</span>,<span class="string">"scoreLabel"</span>,<span class="string">"highScoreLabel"</span>,<span class="string">"resetButton"</span>];

<span class="keyword">public</span> get <span class="title">skinParts</span>():Array&amp;lt;string&amp;gt;{
    <span class="keyword">return</span> MainMenuUISkin._skinParts;
}

<span class="javadoc">/**
 * 加分文本
 */</span>
<span class="keyword">public</span> addLabel:egret.gui.Label;

<span class="javadoc">/**
 * 总分文本
 */</span>
<span class="keyword">public</span> scoreLabel:egret.gui.Label;

<span class="javadoc">/**
 * 最高分文本
 */</span>
<span class="keyword">public</span> highScoreLabel:egret.gui.Label;

<span class="javadoc">/**
 * 重置按钮
 */</span>
<span class="keyword">public</span> resetButton:egret.gui.Button;

<span class="keyword">public</span> <span class="title">createChildren</span>():<span class="keyword">void</span>
{
    <span class="keyword">super</span>.createChildren;
    var uiAsset:egret.gui.UIAsset = <span class="keyword">new</span> egret.gui.UIAsset();
    uiAsset.source = <span class="string">"source.menu"</span>;
    <span class="keyword">this</span>.addElement(uiAsset);

    <span class="keyword">this</span>.resetButton = <span class="keyword">new</span> egret.gui.Button();
    <span class="keyword">this</span>.resetButton.skinName = ResetButtonSkin;
    <span class="keyword">this</span>.resetButton.right = <span class="number">10</span>;
    <span class="keyword">this</span>.resetButton.top = <span class="number">80</span>;
    <span class="keyword">this</span>.resetButton.label = <span class="string">"重置游戏"</span>;
    <span class="keyword">this</span>.addElement(<span class="keyword">this</span>.resetButton);

    <span class="keyword">this</span>.highScoreLabel = <span class="keyword">new</span> egret.gui.Label();
    ...省略若干代码
    <span class="keyword">this</span>.scoreLabel = <span class="keyword">new</span> egret.gui.Label();
    ...省略若干代码
    <span class="keyword">this</span>.addLabel = <span class="keyword">new</span> egret.gui.Label();
    ...省略若干代码
}
</code></pre><p>篇幅有限，省略了createChildren方法里面的子组件布局。<strong>skin的createChildren方法是在皮肤和主机组件匹配的时候被调用的。皮肤和主机组件匹配是在主机组件被添加到显示列表的时候完成的。所以只要主机组件hostComponent还没有添加到显示舞台，获取hostComponent的皮肤部件都是无效的。</strong>这也是为什么我将Mediator的注册放在GUI组件的createComplete后。以防Mediator访问出现空对象的情况。</p>
<p>再来看看主机组件MainMenuUI是怎么写的。</p>
<pre><code>export class MainMenuUI extends egret.gui.SkinnableComponent{
    <span class="keyword">public</span> addLabel:egret.gui.Label;
    <span class="keyword">public</span> scoreLabel:egret.gui.Label;
    <span class="keyword">public</span> highScoreLabel:egret.gui.Label;
    <span class="keyword">public</span> resetButton:egret.gui.Button;

    <span class="keyword">public</span> <span class="title">constructor</span>(){
        <span class="keyword">super</span>();
        <span class="keyword">this</span>.skinName = MainMenuUISkin;
        <span class="keyword">this</span>.addEventListener(egret.gui.UIEvent.CREATION_COMPLETE , <span class="keyword">this</span>.createCompleteEvent, <span class="keyword">this</span>);
    }

    <span class="keyword">public</span> <span class="title">createCompleteEvent</span>(event:egret.gui.UIEvent):<span class="keyword">void</span>{
        <span class="keyword">this</span>.removeEventListener(egret.gui.UIEvent.CREATION_COMPLETE , <span class="keyword">this</span>.createCompleteEvent, <span class="keyword">this</span>);
        ApplicationFacade.getInstance().registerMediator( <span class="keyword">new</span> MainMenuMediator(<span class="keyword">this</span>) );
    }

    <span class="keyword">public</span> <span class="title">partAdded</span>(partName:string, instance:any):<span class="keyword">void</span>{
        <span class="keyword">super</span>.partAdded(partName , instance);
        <span class="keyword">if</span>(<span class="keyword">this</span>.addLabel == instance){
            <span class="keyword">this</span>.addLabel.visible = <span class="keyword">false</span>;
        }
    }

    <span class="keyword">private</span> <span class="title">moveEffect_effectEndHandler</span>():<span class="keyword">void</span>
    {
        <span class="keyword">this</span>.addLabel.visible = <span class="keyword">false</span>;
    }

    <span class="javadoc">/**
    * 加分效果
    */</span>
    <span class="keyword">public</span> <span class="title">playScoreEffect</span>(addScore:number):<span class="keyword">void</span>{
        <span class="keyword">this</span>.addLabel.visible = <span class="keyword">true</span>;
        <span class="keyword">this</span>.addLabel.text = <span class="string">"+"</span>.concat(addScore.toString());
        egret.Tween.removeTweens(<span class="keyword">this</span>.addLabel);
        <span class="keyword">this</span>.addLabel.y = <span class="number">25</span>;
        egret.Tween.get(<span class="keyword">this</span>.addLabel).to({y:<span class="number">0</span>},<span class="number">300</span>).call(<span class="keyword">this</span>.moveEffect_effectEndHandler , <span class="keyword">this</span>);
    }
</code></pre><p>   }</p>
<p>在构造函数里面赋值skinName传入皮肤的类引用，这个解析过程就是SkinAdapter完成的。 可以看到主机组件有一个partAdded进行皮肤组件的配对。这个时候我们就可以获取到对应的皮肤组件，来进行操作了，</p>
<p><strong>②制作游戏区域————了解九宫格和容器布局</strong></p>
<p><img src="http://xzper.qiniudn.com/2014/06/游戏演示.png" alt=""></p>
<p>再次来观察这个游戏的主界面。有一张纯色的背景图，还有4x4个空白的格子，随着游戏的进行会多出带数字的格子，游戏结束了还会出现胜利的界面。</p>
<p>先来看看第一张图。也许你认为这个背景一张4x4的图片不就搞定了么。不过我们这个2048单元格的数量可是可以任意调整的，可以是5x5，或者6x6甚至更多，这样才具备灵活性。你只需要改变CommandData的size属性就可以了(PS:游戏胜利的条件默认是达成2048，也可以通过修改CommandData的winValue属性来修改条件比如8192时胜利或者像上面那样32的时候胜利，想不输都难)。</p>
<p>我们继承SkinnableContainer建立一个MainGameUI的类作为容器来显示上面的界面，当然同时还需要一个皮肤MainGameUISkin。先来确定skinParts，如下：</p>
<pre><code><span class="javadoc">/**
 * 和主机组件匹配的皮肤部件
 */</span>
<span class="keyword">private</span> <span class="keyword">static</span> _skinParts:Array&amp;lt;string&amp;gt; = [
    <span class="string">"tileGroup"</span>,<span class="string">"contentGroup"</span>
];

<span class="keyword">public</span> get <span class="title">skinParts</span>():Array&amp;lt;string&amp;gt;{
    <span class="keyword">return</span> MainGameUISkin._skinParts;
}

<span class="javadoc">/**
 * 游戏底背景
 */</span>
<span class="keyword">private</span> backUIAsset:egret.gui.UIAsset;

<span class="javadoc">/**
 * 背景格子容器
 */</span>
<span class="keyword">private</span> backGroundGroup:egret.gui.Group;

<span class="javadoc">/**
 * 格子容器
 */</span>
<span class="keyword">public</span> tileGroup:egret.gui.Group;

<span class="javadoc">/**
 * 内容
 */</span>
<span class="keyword">public</span> contentGroup:egret.gui.Group;
</code></pre><p>游戏游戏的底背景backUIAsset和背景格子容器backGroundGroup由于逻辑组件MainGameUI不需要关心所有这里不将其设置为skinParts。tileGroup是放置单元格的容器，contentGroup是SkinnableContainer的皮肤部件，SkinnableContainer的addElement方法实际上是添加到这个里面，换言之如果皮肤缺少这个contentGroup那么调用MainGameUI的addElement是看不到你要添加的子项的。 然后override这个createChildren方法将这些组件加入到显示列表。</p>
<pre><code><span class="keyword">public</span> createChildren():<span class="keyword">void</span>
{
    <span class="keyword">super</span>.createChildren;
    <span class="keyword">this</span>.backUIAsset = <span class="keyword">new</span> egret.gui.UIAsset();
    <span class="keyword">this</span>.backUIAsset.<span class="keyword">source</span> = <span class="string">"source.background"</span>;
    <span class="comment">//使用九宫格</span>
    <span class="keyword">this</span>.backUIAsset.scale9Grid = <span class="keyword">new</span> egret.gui.Rectangle(<span class="number">20</span>, <span class="number">20</span>, <span class="number">65</span>, <span class="number">65</span>);
    <span class="keyword">this</span>.backUIAsset.width = CommonData.<span class="keyword">size</span>*(TileUI.<span class="keyword">size</span> + <span class="keyword">this</span>.gap) + <span class="keyword">this</span>.gap;
    <span class="keyword">this</span>.backUIAsset.height = <span class="keyword">this</span>.backUIAsset.width;
    <span class="keyword">this</span>.addElement(<span class="keyword">this</span>.backUIAsset);

    <span class="comment">//使用格子布局</span>
    var layout:egret.gui.TileLayout = <span class="keyword">new</span> egret.gui.TileLayout();
    layout.columnCount = layout.rowCount = CommonData.<span class="keyword">size</span>;
    layout.horizontalGap = layout.verticalGap = <span class="keyword">this</span>.gap;
    <span class="keyword">this</span>.backGroundGroup = <span class="keyword">new</span> egret.gui.<span class="keyword">Group</span>();
    <span class="keyword">this</span>.backGroundGroup.x = <span class="keyword">this</span>.backGroundGroup.y = <span class="keyword">this</span>.gap;
    <span class="keyword">this</span>.backGroundGroup.layout = layout;
    <span class="keyword">this</span>.addElement(<span class="keyword">this</span>.backGroundGroup);
    <span class="keyword">this</span>.initBackGround(CommonData.<span class="keyword">size</span>);

    <span class="keyword">this</span>.tileGroup = <span class="keyword">new</span> egret.gui.<span class="keyword">Group</span>();
    <span class="keyword">this</span>.tileGroup.x = <span class="keyword">this</span>.tileGroup.y = <span class="keyword">this</span>.gap;
    <span class="keyword">this</span>.addElement(<span class="keyword">this</span>.tileGroup);

    <span class="keyword">this</span>.contentGroup = <span class="keyword">new</span> egret.gui.<span class="keyword">Group</span>();
    <span class="keyword">this</span>.contentGroup.percentHeight = <span class="keyword">this</span>.contentGroup.percentWidth = <span class="number">100</span>;
    <span class="keyword">this</span>.contentGroup.touchEnabled = <span class="keyword">false</span>;
    <span class="keyword">this</span>.addElement(<span class="keyword">this</span>.contentGroup);
}
</code></pre><p>先看backUIAsset，由于图片素材只是一个小的纯色圆角矩形，使用scale9Grid属性来设置九宫格缩放，这样设置了宽高就不会变形了。这里backGroundGroup设置了一个layout来确定布局。设置好间距以及行列数，向容器里面添加子项时就自动设置了位置了，不需要设置子项的x，y属性。TileLayout会自动布局。</p>
<pre><code><span class="keyword">private</span> initBackGround(size:<span class="built_in">number</span>):<span class="built_in">void</span>{
        <span class="comment">//背景格子</span>
        <span class="keyword">var</span> tile:egret.gui.UIAsset;
        <span class="keyword">var</span> totalNum:<span class="built_in">number</span> = size * size;
        <span class="keyword">for</span>(<span class="keyword">var</span> i:<span class="built_in">number</span> = <span class="number">0</span>;i &amp;lt; totalNum ; i++)
        {
            tile = <span class="keyword">new</span> egret.gui.UIAsset();
            tile.width = tile.height = TileUI.size;
            tile.source = <span class="string">"source.backtile"</span>;
            <span class="keyword">this</span>.backGroundGroup.addElement(tile);
        }
}
</code></pre><p><strong>③制作单元格————自定义属性</strong></p>
<p>单元格使用TileUI来定义。单元格有一个很重要的属性就是单元格的数据，这里使用value属性来表示。</p>
<pre><code><span class="keyword">private</span> valueChanged:<span class="keyword">boolean</span>;
<span class="keyword">private</span> _value:number;
<span class="javadoc">/**
 * 格子的数字
 */</span>
<span class="keyword">public</span> get <span class="title">value</span>():number{
    <span class="keyword">return</span> <span class="keyword">this</span>._value;
}

<span class="keyword">public</span> set <span class="title">value</span>(value:number){
    <span class="keyword">if</span>(value == <span class="keyword">this</span>._value){
        <span class="keyword">return</span>;
    }
    <span class="keyword">this</span>.valueChanged = <span class="keyword">true</span>;
    <span class="keyword">this</span>._value = value;
    <span class="keyword">this</span>.invalidateProperties();
}

<span class="keyword">public</span> <span class="title">commitProperties</span>():<span class="keyword">void</span>{
    <span class="keyword">if</span>(<span class="keyword">this</span>.valueChanged){
        <span class="keyword">this</span>.valueChanged = <span class="keyword">false</span>;
        <span class="keyword">this</span>.updateValue();
    }
}

<span class="keyword">private</span> <span class="title">updateValue</span>():<span class="keyword">void</span>{
    var mi:number = Math.log(<span class="keyword">this</span>._value)/Math.log(<span class="number">2</span>);
    <span class="keyword">this</span>.source = <span class="string">"number.number_"</span>+mi;
}
</code></pre><p>这里使用了invalidateProperties和commitProperties来完成属性的失效验证。当设置value的时候调用invalidateProperties，失效属性，GUI框架在下一次渲染的时候会调用commitProperties来完成属性的提交。失效验证简单说就是一种延迟应用改变的措施，这种失效验证在egret的GUI组件内部随处可见。这种自定义属性的例子只是其中之一，当组件的commitProperties方法被调用时组件已经准备完毕，所有的皮肤部件也匹配上了。这样也不用担心应用属性的时候报空的情况。这里通过设置TileUI的source属性来改变数字。还记得一开始的resource.json加载的number.json么。</p>
<pre><code>{
"<span class="attribute">frames</span>": <span class="value">{
    "<span class="attribute">number_1</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">106</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">212</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_10</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">0</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">318</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_11</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">0</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">212</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_12</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">0</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">106</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_13</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">0</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">0</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_2</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">212</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">318</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_3</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">212</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">212</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_4</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">212</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">106</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_5</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">212</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">0</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_6</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">106</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">318</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_7</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">318</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">0</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_8</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">106</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">106</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}</span>,
    "<span class="attribute">number_9</span>": <span class="value">{"<span class="attribute">x</span>":<span class="value"><span class="number">106</span></span>, "<span class="attribute">y</span>":<span class="value"><span class="number">0</span></span>, "<span class="attribute">w</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">h</span>":<span class="value"><span class="number">105</span></span>, "<span class="attribute">offX</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">offY</span>":<span class="value"><span class="number">0</span></span>,"<span class="attribute">sourceW</span>":<span class="value"><span class="number">105</span></span>,"<span class="attribute">sourceH</span>":<span class="value"><span class="number">105</span></span>}

</span>}</span>,
"<span class="attribute">file</span>": <span class="value"><span class="string">"number.png"</span>
</span>}
</code></pre><p>这个sheet记录的每一张图也有一个名称比如2这个数字就是number_1加上number这个sheet名称使用”.”符号连接，所以获取”2”这个数字的图片就可以这样写this.source = “number.number_1”。根据值的不同取2的对数得到相应的下标数字。</p>
<p><strong>④制作胜负界面————自定义组件状态</strong></p>
<p>游戏结束之后会出现胜负的界面。但是胜负界面应该是两套不同的素材，那么我们是不是可以制作两个皮肤来根据胜负来切换？这样当然可以。但是，还有一种更简单的办法就是使用自定义状态，只需要一个皮肤类就可以完成两种视图的切换。</p>
<p>新建一个ResultWindow类继承自SkinnableComponent，然后新建ResultWindowSkin。在ResultWindowSkin的构造函数中定义两个状态win和failed。</p>
<pre><code><span class="keyword">public</span> <span class="constructor"><span class="keyword">constructor</span>()</span>{
    <span class="keyword">super</span>();
    <span class="keyword">this</span>.states = [<span class="string">"win"</span>,<span class="string">"failed"</span>];
}
</code></pre><p>然后加入两个皮肤部件button和resultUI</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> _skinParts:Array&lt;string&gt; = [<span class="string">"button"</span>,<span class="string">"resultUI"</span>];

<span class="keyword">public</span> get <span class="title">skinParts</span>():Array&lt;string&gt;{
    <span class="keyword">return</span> ResultWindowSkin._skinParts;
}

<span class="javadoc">/**
 * 按钮
 */</span>
<span class="keyword">public</span> button:egret.gui.Button;

<span class="javadoc">/**
 * 结果文本
 */</span>
<span class="keyword">public</span> resultUI:egret.gui.UIAsset;
</code></pre><p>在createChildren里面将皮肤部件布局好位置。最后重写commitCurrentState方法来根据对应的状态来改变部件的skin。</p>
<pre><code><span class="keyword">public</span> <span class="title">commitCurrentState</span>():<span class="keyword">void</span> {
    <span class="keyword">super</span>.commitCurrentState();
    <span class="keyword">if</span>(<span class="keyword">this</span>.currentState == <span class="string">"win"</span>)
    {
        <span class="keyword">this</span>.resultUI.source = <span class="string">"source.result_sucess"</span>;
        <span class="keyword">this</span>.button.skinName = ContinueButtonSkin;
    }
    <span class="keyword">else</span>
    {
        <span class="keyword">this</span>.resultUI.source = <span class="string">"source.result_failed"</span>;
        <span class="keyword">this</span>.button.skinName = ResetButtonSkin;
    }
}
</code></pre><p>这样还没有完，我们需要在主机组件里面定义何时是何种状态，在ResultWindow中重写getCurrentSkinState来定义皮肤状态。</p>
<pre><code><span class="keyword">private</span> _win:boolean = <span class="keyword">false</span>;
<span class="keyword">public</span> <span class="keyword">get</span> <span class="title">win</span>():boolean{
    <span class="keyword">return</span> <span class="keyword">this</span>._win;
}

<span class="keyword">public</span> <span class="keyword">set</span> <span class="title">win</span>(<span class="keyword">value</span>:boolean){
    <span class="keyword">if</span>(<span class="keyword">value</span> == <span class="keyword">this</span>._win)
        <span class="keyword">return</span>;
    <span class="keyword">this</span>._win = <span class="keyword">value</span>;
    <span class="keyword">this</span>.invalidateSkinState();
}

<span class="keyword">public</span> <span class="title">getCurrentSkinState</span>():<span class="keyword">string</span> {
    <span class="keyword">return</span> <span class="keyword">this</span>.win?<span class="string">"win"</span>:<span class="string">"failed"</span>;
}
</code></pre><p>当外界设置win的值时调用invalidateSkinState来失效皮肤状态，在框架下次渲染的时候，调用SkinnableComponent的validateSkinState方法同时通过getCurrentSkinState来获取皮肤状态，通知皮肤去改变视图。这又是失效验证机制的一次完美使用。我们只需要调用失效，然后重写对应的验证方法就行了。事实上，按钮的up，down，disable之类的状态也是这样实现的。</p>
<p>egret的GUI库，集合了Flex和<a href="http://flexlite.org" target="_blank" rel="external">FlexLite</a>的核心思想。实现了自动布局，皮肤分离，组件的三层失效验证机制。快来膜拜作者<a href="http://blog.domlib.com/" target="_blank" rel="external">DOM</a>大神吧。</p>
<p><strong>6.优化游戏</strong></p>
<p><strong>①使用对象池</strong></p>
<p>在游戏里面随着游戏的进行，每一次移动都有一个格子组件TileUI的创建，当游戏久了会造成巨大的内存开销。这里使用对象池技术。当一个对象使用完毕时，放入对象池，下次需要使用时取出来，这样避免了对象的重复创建，节约了内存。具体的实现参考ObjectPool这个类。具体使用在MainGameUI里面，如下：</p>
<pre><code><span class="javadoc">/**
 * 创建一个格子
 */</span>
<span class="keyword">public</span> <span class="title">createTile</span>(tileVO:TileVO):<span class="keyword">void</span>{
    var tile:TileUI = &amp;lt;TileUI&amp;gt;(ObjectPool.getPool(<span class="string">"game.TileUI"</span>).borrowObject());  <span class="comment">//从对象池创建</span>
   ......
   ......
}
</code></pre><p>当对象池里面没有TileUI时使用会new一个出来，否则直接从对象池获取。</p>
<pre><code><span class="javadoc">/**
 * 清除一个格子
 */</span>
<span class="keyword">public</span> <span class="title">removeTile</span>(tileVO:TileVO):<span class="keyword">void</span>{
    var tileUI:TileUI = <span class="keyword">this</span>.getTileUI(tileVO.x , tileVO.y);
    <span class="keyword">if</span>(tileUI){
        <span class="keyword">this</span>.tileGroup.removeElement(tileUI);
        ObjectPool.getPool(<span class="string">"game.TileUI"</span>).returnObject(tileUI);
    }
}
</code></pre><p>当格子销毁时，回收到对象池，以备下次使用。</p>
<p>另外由于js没有提供弱引用特性，在对象池里面的对象要彻底销毁就需要手动了。</p>
<p><strong>②针对不同设备</strong></p>
<p>游戏在PC我们使用键盘上的方向键操控游戏，但是在移动设备上就需要使用手势来操控了，通过egret.MainContext.deviceType这个值来获取平台 。具体实现在ApplicationMediator中：</p>
<pre><code><span class="comment">//为PC和移动端设置不同的移动策略</span>
<span class="keyword">if</span>(egret.MainContext.deviceType != egret.MainContext.DEVICE_MOBILE)
{
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="built_in">document</span>.addEventListener(<span class="string">"keydown"</span>,<span class="function"><span class="keyword">function</span><span class="params">(event:KeyboardEvent)</span></span>{
        <span class="keyword">switch</span> (event.keyCode) {
            ....省略键盘事件......
        }
    });
}
<span class="keyword">else</span>
{
    <span class="keyword">this</span>.main.addEventListener(egret.TouchEvent.TOUCH_BEGIN , <span class="keyword">this</span>.mouseDownHandle , <span class="keyword">this</span>)
}
</code></pre><p>由于egret目前没有提供手势的API，这里我们自己实现手势。监听TOUCH_BEGIN，TOUCH_MOVE，TOUCH_END和LEAVE_STAGE这四个事件。具体实现如下：</p>
<pre><code><span class="keyword">private</span> downPoint:egret.Point;
<span class="keyword">private</span> movePoint:egret.Point;
<span class="keyword">private</span> <span class="title">mouseDownHandle</span>(<span class="keyword">event</span>:egret.TouchEvent):<span class="keyword">void</span>
{
    egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_MOVE,<span class="keyword">this</span>.stage_mouseMoveHandler,<span class="keyword">this</span>);
    egret.UIGlobals.stage.addEventListener(egret.TouchEvent.TOUCH_END,<span class="keyword">this</span>.stage_mouseUpHandler,<span class="keyword">this</span>);
    egret.UIGlobals.stage.addEventListener(egret.Event.LEAVE_STAGE,<span class="keyword">this</span>.stage_mouseUpHandler,<span class="keyword">this</span>);

    <span class="keyword">this</span>.downPoint = <span class="keyword">this</span>.main.globalToLocal(<span class="keyword">event</span>.stageX, <span class="keyword">event</span>.stageY);
}

<span class="keyword">private</span> needMove:boolean;
<span class="keyword">private</span> <span class="title">stage_mouseMoveHandler</span>(<span class="keyword">event</span>:egret.TouchEvent):<span class="keyword">void</span>{
    <span class="keyword">if</span>(!<span class="keyword">this</span>.movePoint)
        <span class="keyword">this</span>.movePoint = <span class="keyword">new</span> egret.Point();
    <span class="keyword">this</span>.movePoint.x = <span class="keyword">event</span>.stageX;
    <span class="keyword">this</span>.movePoint.y = <span class="keyword">event</span>.stageY;
    <span class="keyword">if</span> (<span class="keyword">this</span>.needMove)
        <span class="keyword">return</span>;
    <span class="keyword">this</span>.needMove = <span class="keyword">true</span>;
}

<span class="keyword">public</span> <span class="title">stage_mouseUpHandler</span>(<span class="keyword">event</span>:egret.Event):<span class="keyword">void</span>{
    egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_MOVE,
        <span class="keyword">this</span>.stage_mouseMoveHandler,
        <span class="keyword">this</span>);
    egret.UIGlobals.stage.removeEventListener(egret.TouchEvent.TOUCH_END,
        <span class="keyword">this</span>.stage_mouseUpHandler,
        <span class="keyword">this</span>);
    egret.UIGlobals.stage.addEventListener(egret.Event.LEAVE_STAGE,
        <span class="keyword">this</span>.stage_mouseUpHandler,
        <span class="keyword">this</span>);
    <span class="keyword">if</span>(<span class="keyword">this</span>.needMove){
        <span class="keyword">this</span>.updateWhenMouseUp();
        <span class="keyword">this</span>.needMove = <span class="keyword">false</span>;
    }
}

<span class="comment">/**
 * 移动设备上，判断移动方向
 */</span>
<span class="keyword">private</span> <span class="title">updateWhenMouseUp</span>():<span class="keyword">void</span>
{
    <span class="keyword">var</span> p:egret.Point = <span class="keyword">this</span>.main.globalToLocal(<span class="keyword">this</span>.movePoint.x, <span class="keyword">this</span>.movePoint.y ,egret.Point.identity);
    <span class="keyword">var</span> offSetX:number = p.x - <span class="keyword">this</span>.downPoint.x;
    <span class="keyword">var</span> offSetY:number = p.y - <span class="keyword">this</span>.downPoint.y;

    <span class="keyword">if</span>(offSetY&amp;lt;<span class="number">0</span> &amp;amp;&amp;amp; Math.abs(offSetY)&amp;gt;Math.abs(offSetX))  <span class="comment">//上</span>
    {
        <span class="keyword">this</span>.doMove(<span class="number">0</span>);
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(offSetX&amp;gt;<span class="number">0</span> &amp;amp;&amp;amp; offSetX&amp;gt;Math.abs(offSetY))  <span class="comment">//右</span>
    {
        <span class="keyword">this</span>.doMove(<span class="number">1</span>);
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(offSetY&amp;gt;<span class="number">0</span> &amp;amp;&amp;amp; offSetY&amp;gt;Math.abs(offSetX))  <span class="comment">//下</span>
    {
        <span class="keyword">this</span>.doMove(<span class="number">2</span>);
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(offSetX&amp;lt;<span class="number">0</span> &amp;amp;&amp;amp; Math.abs(offSetX)&amp;gt;Math.abs(offSetY))  <span class="comment">//左</span>
    {
        <span class="keyword">this</span>.doMove(<span class="number">3</span>);
    }
}
</code></pre><p><strong>③动画效果</strong></p>
<p>游戏里面格子的创建，移动，合并，都需要一个缓动效果来支持。这里面最大的问题就是，缓动效果是持续时间的，而往往数据的改变是一瞬间。比如：一个操作合并了两个格子，其中一个需要移动，并且移动完成后要移除掉，此时新的格子也要出现。但是往往数据层把这些数据是同时发过来的，所以我们需要调节时机来让效果更好。比如格子的创建，我们延迟100毫秒显示在舞台上，因为在创建的同时其他格子会移动，所以等其他格子移动完成了后显示出来比较好。再比如格子的合并，实际上就是一个格子移动，移动完成后消失，目标位置格子改变数字并且出现缩放效果。这样要注意的就是移动之前调整将移动的格子的层级显示在最下面，避免移动的时候挡在目标位置格子的上面。</p>
<p><strong>7.性能</strong></p>
<p>egret的工作流还是很高效的，工具也不少，架构设计集各家所长。最后发布游戏在PC上运行是满帧运行，比原版甚至更快。在手机上运行也不错，体验超过了某些原生语言开发的2048。</p>
<p>最后交出源代码：<a href="https://github.com/f111fei/2048egret" target="_blank" rel="external">点我传送</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>2048是最近很火的一个小游戏，<a href="http://gabrielecirulli.github.io/2048/" target="_blank" rel="external">原版</a> 就是用JavaScript写的。恰巧最近Egret PublicBeta，观望和学习了一阵后，发现egret正好适合开发这类游戏。Egret使用TypeScript作为开发语言，最终编译为JavaScript，正好和原始版本PK一下。</p>
<p>游戏预览：<a href="http://xzper.com/project/2048egret/" target="_blank" rel="external">点我体验</a></p>
]]></summary>
    
      <category term="Egret" scheme="http://xzper.com/tags/Egret/"/>
    
      <category term="Egret" scheme="http://xzper.com/categories/Egret/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[新手引导—脚本设计]]></title>
    <link href="http://xzper.com/2014/06/15/%E6%96%B0%E6%89%8B%E5%BC%95%E5%AF%BC%E2%80%94%E8%84%9A%E6%9C%AC%E8%AE%BE%E8%AE%A1/"/>
    <id>http://xzper.com/2014/06/15/新手引导—脚本设计/</id>
    <published>2014-06-14T19:49:56.000Z</published>
    <updated>2014-09-05T16:46:59.000Z</updated>
    <content type="html"><![CDATA[<p>最近在做游戏的新手引导模块。由于是关卡式的引导，所以很适合用读取引导脚本的方式来开发。</p>
<p><strong>脚本和命令配置</strong></p>
<a id="more"></a>

<p>程序中通过GuideLib这个类来解析命令配置和脚本。脚本以行为单位运行，每一行就是一条指令。每一条指令有指令的名称和指令的参数。就像下面这样。</p>
<pre><code><span class="tag">goto</span> <span class="tag">step</span><span class="pseudo">:+1</span>
<span class="tag">showArrow</span> <span class="tag">direction</span><span class="pseudo">:down</span> <span class="tag">position</span>:<span class="attr_selector">[200,300]</span> <span class="tag">clickRect</span>:<span class="attr_selector">[100,30]</span>
<span class="tag">delayCall</span> <span class="tag">step</span><span class="pseudo">:-1</span> <span class="tag">time</span><span class="pseudo">:2</span>
</code></pre><p>第一个单词表示命令名称，然后后面的参数以空格分开，参数名称和参数值用冒号分开。由若干条命令就组成了一个完整的脚本。但是光有脚本还是不够，从脚本里面我们看不出来参数的类型。比如position应该是一个Number数组，所以我们还需要一个配置文件来说明每一条命令的详细细节。这里配置文件用xml表示。</p>
<p><pre class="lang:xhtml decode:true">&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;commands&gt;<br>    &lt;command name=”goto”&gt;<br>        &lt;param name=”step” type=”String”/&gt;<br>    &lt;/command&gt;<br>    &lt;command name=”delayCall”&gt;<br>        &lt;param name=”step” type=”String”/&gt;<br>        &lt;param name=”time” type=”Number”/&gt;<br>    &lt;/command&gt;<br>    &lt;command name=”showArrow”&gt;<br>        &lt;param name=”direction” type=”String”/&gt;<br>        &lt;param name=”position” type=”Array_Number”/&gt;<br>        &lt;param name=”clickRect” type=”Array_Number”/&gt;<br>    &lt;/command&gt;<br>&lt;/commands&gt;</pre><br>可以看到param有一个type的属性用来说明参数类型。查看GuideLib的源代码会发现有一个ITypeAdapter，这个就是用来解析参数类型的，在解析脚本的时候，调用ITypeAdapter的convert方法自动将脚本中param的值由字符串转换为命令配置文件中的type。默认的类型解释器是TypeAdapter。</p>
<pre><code><span class="javadoc">/**
 * 将命令参数的值转换成正确的类型
 */</span>
public function convert(<span class="keyword">type</span>:String , value:String):*
{
    <span class="keyword">var</span> result:String = value;
    <span class="keyword">if</span>(<span class="keyword">type</span> == <span class="string">"String"</span>)
    {
        <span class="keyword">return</span> value;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">type</span> == <span class="string">"Boolean"</span>)
    {
        <span class="keyword">return</span> value==<span class="string">"true"</span>?<span class="keyword">true</span>:<span class="keyword">false</span>;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">type</span>.indexOf(<span class="string">"Array"</span>) == <span class="number">0</span>)
    {
        <span class="keyword">if</span>(<span class="keyword">type</span>.split(<span class="string">"_"</span>,<span class="number">2</span>).length&amp;lt;<span class="number">2</span>)
        {
            <span class="keyword">return</span> convertStringToArray(<span class="string">"String"</span> , value);
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">return</span> convertStringToArray(<span class="keyword">type</span>.split(<span class="string">"_"</span>)[<span class="number">1</span>] , value);
        }
    }
    <span class="keyword">else</span>
    {
        <span class="keyword">return</span> getDefinitionByName(<span class="keyword">type</span>)(value);
    }
}
</code></pre><p><strong>执行命令</strong></p>
<p>GuideLib将通过getScript将脚本解析成一个数组。每一个元素就是一条命令，然后交给GuideSystem去处理每一条命令。在GuideSystem中又可以看到一个ICommandAdapter。这个就是用来运行命令的解释器，调用run方法执行命令。默认的命令解释器是CommandAdapter。</p>
<pre><code><span class="javadoc">/**
 * 默认的函数库
 */</span>
<span class="keyword">private</span> var guideFunction:GuideFunction = <span class="keyword">new</span> GuideFunction();
<span class="javadoc">/**
 * 运行命令
 *<span class="javadoctag"> @param</span> command 命令的名称
 *<span class="javadoctag"> @param</span> param 命令的参数
 *<span class="javadoctag"> @param</span> guideSystem 向导管理
 */</span>
<span class="keyword">public</span> function <span class="title">run</span>(command:String, param:Object, guideSystem:GuideSystem):<span class="keyword">void</span>
{
    var fun:Function;
    <span class="keyword">if</span>(guideFunction.hasOwnProperty(command))  <span class="comment">//函数库中存在这个函数</span>
        fun = guideFunction[command];
    fun(param);
    <span class="keyword">if</span>(guideSystem.auto)
        guideSystem.doNext();
}
</code></pre><p>GuideFunction就是默认的函数库，如果命令配置是调用其他的类的函数，可以自己实现这个run方法。</p>
<p><strong>函数库的自定义</strong></p>
<p>脚本中的每一条命令实际上就是调用的某一个类的某一个函数。默认情况下这个类就是GuideFunction。所以我们要实现功能，为GuideFunction添加方法就行了。方法名保存和命令名一致，参数就是命令的参数组成的Object。例如delayCall这个命令的实现</p>
<pre><code><span class="comment">/**
 * 延时 多少秒执行哪一步
 */</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delayCall</span><span class="params">(param:Object)</span><span class="type">:void</span>
</span>{
    <span class="keyword">var</span> step:String = param[<span class="string">"step"</span>];
    <span class="keyword">var</span> time:Number = param[<span class="string">"time"</span>];
    GuideSystem.getInstance().auto = <span class="literal">false</span>;
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span><span class="type">:void</span></span>{
        GuideSystem.getInstance().auto = <span class="literal">true</span>;
        GuideSystem.getInstance().goto(step);
    } , time*<span class="number">1000</span>);
}
</code></pre><p>我们可以根据业务逻辑的不同，自由的定制参数类型解析器，命令函数解析器和函数库。</p>
<p><strong>脚本编辑器</strong></p>
<p>脚本编辑器是一个可视化的工具，能方便快速的创建脚本，你只需要先写好命令配置xml。编辑器会根据xml自动生成命令列表，然后向脚本中自由的加入命令。预览图：</p>
<p><img src="http://xzper.qiniudn.com/2014/06/editor.png" alt=""></p>
<p>新手引导示例：<a href="http://xzper.qiniudn.com/2014/06/Guide.rar" target="_blank" rel="external">Guide</a></p>
<p>脚本编辑器：<a href="http://xzper.qiniudn.com/2014/06/ScriptEditor.rar" target="_blank" rel="external">ScriptEditor</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>最近在做游戏的新手引导模块。由于是关卡式的引导，所以很适合用读取引导脚本的方式来开发。</p>
<p><strong>脚本和命令配置</strong></p>
]]></summary>
    
      <category term="未分类" scheme="http://xzper.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从2048游戏谈PureMVC]]></title>
    <link href="http://xzper.com/2014/04/27/%E4%BB%8E2048%E6%B8%B8%E6%88%8F%E8%B0%88PureMVC/"/>
    <id>http://xzper.com/2014/04/27/从2048游戏谈PureMVC/</id>
    <published>2014-04-26T18:03:56.000Z</published>
    <updated>2014-09-06T04:49:57.000Z</updated>
    <content type="html"><![CDATA[<p>最近2048比较火，然后我又正好在学习pureMVC，之前对于pureMVC的了解只停留在理论上，正好拿这个游戏来练练手。废话不多说，游戏预览：<a href="http://xzper.qiniudn.com/2014/04/2048flexlite/Main.html" target="_blank" rel="external">2048</a></p>
<a id="more"></a>

<p><strong>1.MVC的基本运行原理</strong></p>
<p><img src="http://xzper.qiniudn.com/2014/04/mvc结构图.png" alt="mvc结构图"></p>
<p><span style="font-family: 微软雅黑;"><span>图：</span></span><span><span style="font-family: Calibri;">MVC</span><span style="font-family: 微软雅黑;">结构图（实线——&gt;表示依赖；虚线</span><span style="font-family: Calibri;">——&gt;</span><span style="font-family: 微软雅黑;">表示事件</span><span style="font-family: Calibri;">/</span></span><span style="font-family: 微软雅黑;"><span>通知等</span><span>）</span></span></p>
<ul>
<li><p><strong>模型（Model）</strong> 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。“模型”有对数据直接访问的权力，例如对数据库的访问。“模型”不依赖“视图”和“控制器”，也就是说，模型不关心它会被如何显示或是如何被操作。但是模型中数据的变化一般会通过一种刷新机制被公布。为了实现这种机制，那些用于监视此模型的视图必须事先在此模型上注册，从而，视图可以了解在数据模型上发生的改变。（比较：<a href="http://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F" title="观察者模式" target="_blank" rel="external">观察者模式</a>（<a href="http://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" title="软件设计模式" target="_blank" rel="external">软件设计模式</a>））</p>
</li>
<li><p><strong>视图(View)</strong> 能够实现数据有目的的显示（理论上，这不是必需的）。在视图中一般没有程序上的逻辑。为了实现视图上的刷新功能，视图需要访问它监视的数据模型（Model），因此应该事先在被它监视的数据那里注册。</p>
</li>
<li><p><strong>控制器(Controller)</strong> 起到不同层面间的组织作用，用于控制应用程序的流程。它处理事件并作出响应。“事件”包括用户的行为和数据模型上的改变。</p>
</li>
</ul>
<p><strong>2.pureMVC中的Proxy,Mediator,Command</strong></p>
<ul>
<li><strong>Proxy数据层(Model)</strong> 由于数据不关心视图是如何显示的，所以如果数据改变了引起了视图的改变，为了做到解耦，Proxy通过sendNotification方法向视图(Mediator)或者控制器(Command)发送通知，而不是获取视图实例调用里面的方法，通知发出去了Proxy的任务就完成了。另外Proxy通常还提供一些公共方法(public function)供控制器(Command)直接调用，从而改变数据（<strong>注意：Proxy是不接收Notification的</strong>）。</li>
<li><strong>Mediator视图层(View)</strong> 中介器(Mediator)持有对应视图的引用，他负责接收消息和发送消息，所以一般情况下Mediator只含有处理消息和发送消息的代码，不会有复杂的逻辑处理，逻辑处理放在视图组件(viewComponent)里面（<strong>注意：如果你的Mediator含有过多的公共方法不用想肯定有问题</strong> ）。当数据改变，Mediator收到消息时，调用viewComponent暴露的公共方法，处理视图的改变。另外，Mediator可以为视图组件添加事件监听器(addEventListener),发送消息(sendNotification)通知控制器(Command)视图的改变，而不是直接调用Proxy的公共方法改变数据。</li>
<li><strong>Command控制器(Controller)</strong> 这个的使用比较灵活。最常用的就是收到Mediator发来的消息，调用Proxy的公共方法改变数据。还有可能是收到某一个Proxy的消息，调用另外一个Proxy改变数据等等。他起到了一个桥梁的作用。协调Mediator和Proxy，Proxy1和Proxy2，Mediator1和Mediator2。所以Command也不应该有复杂的逻辑。</li>
</ul>
<p><strong>3.从实例学习pureMVC</strong></p>
<p>先来看下工程目录结构</p>
<p><img src="http://xzper.qiniudn.com/2014/04/2048工程结构.png" alt="2048工程结构"></p>
<p><strong>1.xxxPrepCommand</strong> 框架初始化时，注册对应必须的Command和Proxy。（另外说下由于FlexLite的组件需要在CreateComplete才能获取皮肤实例，所以Mediator的注册都是在viewComponent中完成的）</p>
<p><strong>2.GameCommand</strong> 处理各类事务。比如 玩家按下了方向键，收到消息调用GridProxy的移动方法改变数据，比如GridProxy移动格子分数改变了，通知GameCommand 调用GameProxy的更新分数方法改变分数，比如处理重置游戏的事务，通知各个数据模块重置数据</p>
<p><strong>3.GameProxy</strong> 处理游戏数据，比如更新分数，处理游戏结果</p>
<p><strong>4.GridProxy</strong> 这个游戏的核心数据，操作每一个格子的数据，通知视图格子的移动，添加，删除，重置</p>
<p><strong>5.ApplicationMediator</strong> 监听键盘事件发送消息到GameCommand通知移动</p>
<p><strong>6.MainGameMediator</strong> 接收消息，调用MainGameUI的方法处理格子的移动，添加，删除，重置，以及接收游戏结果，显示结果面板</p>
<p><strong>7.**</strong>MainMenuMediator** 接收更新分数的消息，调用MainGameUI的方法更新分数与重置</p>
<p><strong>8.ResultWindowMediator</strong> 发送游戏重置的消息，以及自销毁。这是一个短生命的Mediator</p>
<p>其实这个游戏本来一开始我是用Flex开发的，最后完成的时候发现swf太大加载太慢，于是换成了比较小巧的FlexLite。整个移植过程没有动Model和Controller的一行代码，Mediator改动的也很少。充分说明了MVC的代码重用和关注点分离。这也是我用pureMVC的初次尝试，可能理解还有很多不到位和错误的地方，在此抛砖引玉。最后附上源代码下载：</p>
<p>FlexLite版：<a href="http://xzper.qiniudn.com/2014/04/2048flexlite.rar" target="_blank" rel="external">2048flexlite</a></p>
<p>Flex版：<a href="http://xzper.qiniudn.com/2014/04/2048flex.rar" target="_blank" rel="external">2048flex</a></p>
<p>参考文章：</p>
<p>[1] <a href="http://www.cnblogs.com/skynet/archive/2012/12/29/2838303.html" target="_blank" rel="external">http://www.cnblogs.com/skynet/archive/2012/12/29/2838303.html</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>最近2048比较火，然后我又正好在学习pureMVC，之前对于pureMVC的了解只停留在理论上，正好拿这个游戏来练练手。废话不多说，游戏预览：<a href="http://xzper.qiniudn.com/2014/04/2048flexlite/Main.html" target="_blank" rel="external">2048</a></p>
]]></summary>
    
      <category term="puremvc" scheme="http://xzper.com/tags/puremvc/"/>
    
      <category term="框架" scheme="http://xzper.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在路上]]></title>
    <link href="http://xzper.com/2014/04/21/%E5%9C%A8%E8%B7%AF%E4%B8%8A/"/>
    <id>http://xzper.com/2014/04/21/在路上/</id>
    <published>2014-04-21T15:51:00.000Z</published>
    <updated>2014-09-06T04:49:14.000Z</updated>
    <content type="html"><![CDATA[<p>博客建站以来也快有一个月了，每次想写点什么都不得而终。究其原因还是自己太懒了。所以现在趁自己不懒的时候，记录自己在前端开发路上的点滴。 希望此文能做一个好的开始，以此共勉。</p>
<p>Flash开发到了如今，也到了日落西山，穷途末路的时候吧。从官方上来看，Adobe已经对Flash力不从心了，停止了移动端的FP的更新 ，把Flex捐给了Apache 。从开发者来看，大量新技术如Html5，Cocos2d，Unity3D的出现让开发者有了更多的选择，好多Flash老程序员都转行了，这似乎成了一个趋势  。 从市场上来看，如今的页游市场，已经不复当年的辉煌了，前篇一律的感觉玩家会卖账么？而且各种坑爹的运营导致Flash游戏的名声越来越臭。总之，对于即将毕业的我选择Flash开发这条路显然不是一个明智的选择。</p>
<a id="more"></a>

<p>但是对于一个能把一件衣服从新买到一直穿到破的人来说，东西用惯了想换下来，不是那么容易的。至少目前这件衣服对于我来说还是新的就足够了，穿破了再说。我喜欢AS3，喜欢Flex，喜欢Flash这就够了。再说程序员都认为自己使用的语言是最NB的，讨论哪种语言的好坏根本没有意义。</p>
<p>从2012年5月到现在，接触Flash编程也快有2年了。然而看了看Flash的<a href="http://www.xmind.net/m/bCk4/" target="_blank" rel="external">技能树</a>当真自愧不如。最近没事的时候我喜欢反编译一些看起来不错的游戏和软件，看着别人的代码，体会别人的开发思路。收获不少，同时也在感叹自己会的东西太少了。我发现，看博客，看开源项目或者成熟的商业作品的源码对自己的提升很有用。之前1年的学习可能仅仅只是让我上路了，知道怎么写代码，如何实现。但这些显然是不够的，要真真的独当一面要会的东西还有太多。</p>
<p>对于前端开发，一些人认为就是显示下界面，放放特效之类的，其实哪有那么简单。这里按照技能书大致列举下我做前端的过程自己会与不会的知识。认为写前端很轻松的可以体会下。</p>
<p><strong>1.显示对象基础</strong>。其实大多人对前端的认识也就留在这一块了。以为也就是操作下显示对象，把数据显示出来。且不说下面的11条，就这一条，也不是一个人能半年之内搞精通的。这个是基础，至少目前我还不能在不看API的情况下说出每一个显示对象的属性和方法，以及应用。</p>
<p><strong>2.特效和动画</strong>。对于一部分特效我们搞开发的做不来，还得交给美工特效大大们去做，还有一部分特效是可以用代码写的。那我们需要知道什么，做什么呢。1.矢量动画和帧动画的区别。2.如何用代码写动画，比如各类缓动，各类滤镜动画，Bitmap操作，Matrix操作等等。目前比较流行的动画开源库和引擎有，TweenLite(感觉体积比较大，所以一般自己实现)，SpriteSheet ，DragonBones，这2个久仰大名有待学习。还有个PixelBender也是最近才知道的，搞的是高级图像处理，渣渣表示学不来。</p>
<p><strong>3.媒体处理</strong>。之前写组件的时候写过音视频播放啊之类的(最近在倒腾bilibili的弹幕播放器，不弄不知道一弄才发现很是复杂。关于视频流的分段处理，流的数据生成模式，与主流视频网站的对接看的头都大了) ，后来接触到了FMS，玩过P2P通讯的视频语音文字图片文件的共享与收发，其实这也只是冰山一角。FMS主要的在于直播，点播方面比较好用。至于那些编码处理之类的那我也只是只闻其名了。媒体处理类的坑很深估计掉下去了就爬不起来了。</p>
<p><strong>4.文本处理</strong>。文本引擎FTE和TLF，看名字就看晕了。TLF是基于FTE的，对FTE做了一次封装，感觉这和Adobe的OSMF是基于底层的媒体处理类似。这些目前没有深入了解。对于一般的文本处理，目前遇到的图文混排算上要求最高的吧，我用的是RichTextField解决的，感觉还不错。最近关于文本的敏感词过滤好像也是要学的。</p>
<p><strong>5.网络通信</strong>。资源类，各种Loader的使用，不过这些东西在项目里面最好做一下封装，目前比较喜欢用的是FlexLite里面的加载器感觉封装的比较彻底。流处理，URLStream啊NetStream这类的东西很多。后台交互，Socket，AMF(这个比较好用，用来实现HTTP通讯，实际上Flex的RemoteObject就是基于这个的)，另外还有RTMP，RTMFP协议，FMS上面用到的。</p>
<p><strong>6.文件访问</strong>。在web上面的文件访问用FileReference来进行读写，可惜是需要把整个文件加载到浏览器内存才能操作。air的文件读写不用。ShareObject的使用俗称FlashCookie，存一些简单信息比较好用。对象序列化反序列化的ByteArray操作，文件操作少不了这个的。以及反射的使用。还有恶心的Flash跨域问题。</p>
<p><strong>7.性能优化</strong>。每个ASer都在与名为性能的怪物战斗。这方面需要了解Flash的垃圾回收机制。常用的优化技巧有 ，事件的监听和移除，强引用弱引用，总之就是想办法去除不必要的引用，以便垃圾回收器能回收对象实例防止内存泄露。对于CPU的优化，主要是渲染方式的优化，像bitmap几个方法的快慢啊，矢量图与位图的区别啊。还有一些框架优化这类的。</p>
<p><strong>8.flex</strong>。由于项目需要我完整的学习了FlexLite这个框架，核心思想就是Flex来的。我很喜欢这种架构设计(第2次说了)，他的组件生命周期，3层验证失效机制，布局管理，皮肤适配，UI层管理。无论哪一个拿出来都要说好久。所以这里就不说了，有时间单独补上。</p>
<p><strong>9.air</strong>。air里面有很多新的东西我都没接触到，这个也是一个领域啊。不过我还是更喜欢web开发一下。</p>
<p><strong>10.图形基础</strong>。说是图形基础，对于我这个色盲来说，真的很难。什么色相，颜色矩阵，Bitmap操作什么的有待学习，教材已经订好，ActionScript3.0图像处理基础教程，根本一点都不基础好么。</p>
<p><strong>11.架构设计</strong>。这也是目前我着重学习的，毕竟一个人要想独当一面这个东西不可或缺。目前很好的一个学习办法就是阅读商业项目的成熟代码去体会，然后在平时的码码中实际应用上去。</p>
<p><strong>12.开源库</strong>。一个纯OOP开发语言当然离不开各类开源库以及引擎。上面说的几个是做动画用的比较多的开源库。像 UI框架之类的有,官方的<code>Flex</code>(Flex的架构设计简直赞，第3次了喂，可惜体积太大了), <code>Aswing</code>(没用过不说了) , <code>FlexLite</code> (DOM大大开发的UI框架，包含了Flex4的精髓) ，<code>Features</code>(和<code>Starling</code>配合)。物理引擎有 <code>Box2D</code> ， <code>Nape</code>，这部分我暂时没接触。3D引擎有官方的3d底层Stage3D , 以及<code>Away3D</code> ，<code>PV3D</code> , <code>Flar3D</code> ，这些我都鲜有接触。MVC框架有 官方的<code>Cairngorm</code>(据说太大，所以应用的不是很广) ， <code>pureMVC</code>(最近看的比较多的，蛮不错)，<code>Robotlegs</code>(貌似比前者好，最近准备学)。游戏引擎类的有 <code>Starling</code>(移动平台应用比较多，没时间学) ， <code>D5Power</code>(国人开发的rpg引擎，比较感兴趣，很有可能是我以后学rpg开发的敲门砖)。还有各种开源的小组件，开源的工具库这些的，都是每个Aser或多或少需要了解的东西，如果能深入理解源码那就更好了。</p>
<p>还有很多知识都是没有涉及到的比如各类游戏算法啊，工具啊之类的。<strong>希望此文能为我自己立一面旗帜(俗称立Flag)，在今后的学习路上，像这面旗帜看齐，总之，那句话怎么说来着，我不在乎路的尽头有什么，我只在乎路边的风景，路还很长，且行且珍惜</strong>。</p>
]]></content>
    <summary type="html"><![CDATA[<p>博客建站以来也快有一个月了，每次想写点什么都不得而终。究其原因还是自己太懒了。所以现在趁自己不懒的时候，记录自己在前端开发路上的点滴。 希望此文能做一个好的开始，以此共勉。</p>
<p>Flash开发到了如今，也到了日落西山，穷途末路的时候吧。从官方上来看，Adobe已经对Flash力不从心了，停止了移动端的FP的更新 ，把Flex捐给了Apache 。从开发者来看，大量新技术如Html5，Cocos2d，Unity3D的出现让开发者有了更多的选择，好多Flash老程序员都转行了，这似乎成了一个趋势  。 从市场上来看，如今的页游市场，已经不复当年的辉煌了，前篇一律的感觉玩家会卖账么？而且各种坑爹的运营导致Flash游戏的名声越来越臭。总之，对于即将毕业的我选择Flash开发这条路显然不是一个明智的选择。</p>
]]></summary>
    
      <category term="感悟" scheme="http://xzper.com/categories/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
</feed>
